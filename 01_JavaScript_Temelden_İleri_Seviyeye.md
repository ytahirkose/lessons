## BÖLÜM 1: JAVASCRIPT - TEMELDEN İLERİ SEVİYEYE

### 1.1 JavaScript'in Tarihçesi ve Evrimi - Detaylı Analiz

JavaScript'in tarihçesi, modern web geliştirmenin en önemli dönüm noktalarından biridir. Bu dil, sadece bir programlama dili değil, aynı zamanda web'in evrimini ve modern yazılım geliştirme paradigmalarının değişimini temsil eder. JavaScript'in evrimi, web'in statik sayfalardan dinamik uygulamalara dönüşüm sürecini yansıtır.

**JavaScript'in Doğuşu - Tarihsel Bağlam ve Derinlemesine Analiz**

JavaScript'in doğuşu, web'in ilk dönemlerindeki sınırların aşılması ihtiyacından kaynaklanır. 1990'ların ortalarında, web sayfaları statik HTML ve CSS ile oluşturuluyordu. Bu yaklaşım, basit bilgi paylaşımı için yeterli olsa da, kullanıcı etkileşimi ve dinamik içerik için yetersizdi.

**Web'in İlk Dönemlerindeki Sınırlar:**

**Statik Web Sayfaları:**
Web'in ilk dönemlerinde, sayfalar tamamen statikti. Kullanıcılar, sadece link'lere tıklayarak farklı sayfalar arasında geçiş yapabiliyordu. Bu durum, kullanıcı deneyimini sınırlıyordu.

**CGI Scriptleri ve Sınırları:**
Dinamik içerik için CGI (Common Gateway Interface) scriptleri kullanılıyordu. Ancak bu scriptler, her istek için yeni bir process başlatıyordu ve performans sorunları yaratıyordu.

**Java Applets ve Sorunları:**
Java Applets, tarayıcıda çalışan küçük uygulamalar sağlıyordu. Ancak bu teknoloji, güvenlik açıkları, yavaş yükleme süreleri ve platform bağımlılığı gibi sorunlar yaratıyordu.

**Netscape'in Stratejik Yaklaşımı:**

Netscape Communications Corporation, web'in bu sınırlarını fark etmiş ve bu sorunları çözmek için stratejik bir yaklaşım benimsemiştir. Netscape'in amacı, tarayıcıda çalışan, güvenli ve hızlı bir programlama dili geliştirmekti.

**Brendan Eich'in Vizyonu:**

Brendan Eich, JavaScript projesinin başında, Scheme ve Self dillerinden esinlenerek, web için modern bir programlama dili tasarlamıştır. Eich'in vizyonu, web geliştirmenin esnekliğini korurken, performans ve güvenliği artırmaktı.

**JavaScript'in Tasarım Felsefesi - Derinlemesine Analiz:**

JavaScript, Brendan Eich tarafından 10 günde tasarlanmış ve özel bir felsefe ile geliştirilmiştir. Bu felsefe, JavaScript'i diğer programlama dillerinden ayıran temel özelliklerini oluşturur.

**Prototype-based OOP - Prototip Tabanlı Nesne Yönelimli Programlama - Derinlemesine Analiz**

JavaScript, geleneksel sınıf tabanlı OOP yerine prototip tabanlı OOP kullanır. Bu yaklaşım, JavaScript'in en önemli ve benzersiz özelliklerinden biridir.

**Sınıf Tabanlı OOP'nin Sınırları:**
Sınıf tabanlı OOP'de (Java, C++, C# gibi), önce bir sınıf tanımlanır, sonra bu sınıftan nesneler oluşturulur. Bu yaklaşım, statik ve katı bir yapı oluşturur. Sınıf tanımı, derleme zamanında sabitlenir ve çalışma zamanında değiştirilemez.

**Prototip Tabanlı OOP'nin Avantajları:**
Prototip tabanlı OOP'de, nesneler doğrudan oluşturulur ve diğer nesnelerden özellik ve metodları miras alır. Bu yaklaşım, dinamik ve esnek bir yapı oluşturur. Nesne yapısı, çalışma zamanında değiştirilebilir.

**Prototip Zinciri'nin Felsefesi:**
Prototip zinciri, JavaScript'in en güçlü özelliklerinden biridir. Bu zincir, nesneler arası ilişkileri dinamik olarak yönetir ve esnek bir miras sistemi sağlar.

**JavaScript'in Tasarım Prensipleri:**

**Simplicity (Basitlik):**
JavaScript, basit ve anlaşılır olmalıdır. Bu prensip, dilin öğrenilmesini kolaylaştırır.

**Flexibility (Esneklik):**
JavaScript, esnek ve uyarlanabilir olmalıdır. Bu prensip, farklı kullanım senaryolarını destekler.

**Performance (Performans):**
JavaScript, hızlı ve verimli olmalıdır. Bu prensip, web uygulamalarının performansını artırır.

**Security (Güvenlik):**
JavaScript, güvenli olmalıdır. Bu prensip, web güvenliğini sağlar.

**Compatibility (Uyumluluk):**
JavaScript, farklı tarayıcılarda uyumlu olmalıdır. Bu prensip, web standartlarını destekler.

**JavaScript'in Evrim Süreci:**

**1995-2000: Temel Kurulum**
Bu dönemde, JavaScript'in temel özellikleri geliştirildi. Prototip tabanlı OOP, function'lar ve temel DOM manipülasyonu eklendi.

**2000-2005: Standartlaşma**
Bu dönemde, ECMAScript standartları geliştirildi. JavaScript, resmi bir standart haline geldi.

**2005-2010: Modern JavaScript**
Bu dönemde, AJAX, JSON ve modern web geliştirme teknikleri eklendi. JavaScript, web uygulamalarının kalbi haline geldi.

**2010-2015: Framework Çağı**
Bu dönemde, jQuery, AngularJS, React gibi framework'ler geliştirildi. JavaScript, büyük uygulamalar için kullanılmaya başlandı.

**2015-Günümüz: Modern JavaScript**
Bu dönemde, ES6+, TypeScript, Node.js gibi teknolojiler geliştirildi. JavaScript, full-stack geliştirme için kullanılmaya başlandı.

**JavaScript'in Geleceği:**

JavaScript'in geleceği, web'in evrimi ile paralel olarak gelişmektedir. WebAssembly, Progressive Web Apps, ve modern web standartları, JavaScript'in geleceğini şekillendirmektedir.

**Öncesi - Web'in İlk Dönemlerindeki Sınırlar:**

**1995 - JavaScript'in Doğuşu**: 
- **Nisan 1995**: Netscape Communications Corporation, Marc Andreessen liderliğinde web tarayıcısına programlama dili ekleme kararı aldı
- **Mayıs 1995**: Brendan Eich, Netscape'de çalışmaya başladı ve "Mocha" adını verdiği programlama dilini geliştirmeye başladı
- **Eylül 1995**: Dil "LiveScript" olarak yeniden adlandırıldı
- **Aralık 1995**: Sun Microsystems ile yapılan pazarlama anlaşması sonucu "JavaScript" adını aldı
- **10 Günlük Geliştirme**: Brendan Eich, JavaScript'i 10 gün gibi kısa bir sürede geliştirdi
- **İlk Sürüm**: Netscape Navigator 2.0 ile birlikte yayınlandı

**JavaScript'in Tasarım Felsefesi**:

JavaScript, Brendan Eich tarafından 10 günde tasarlanmış ve özel bir felsefe ile geliştirilmiştir. Bu felsefe, JavaScript'i diğer programlama dillerinden ayıran temel özelliklerini oluşturur.

**Prototype-based OOP - Prototip Tabanlı Nesne Yönelimli Programlama**

JavaScript, geleneksel sınıf tabanlı OOP yerine prototip tabanlı OOP kullanır. Bu yaklaşım, JavaScript'in en önemli ve benzersiz özelliklerinden biridir.

**Sınıf Tabanlı OOP Nedir?**
Sınıf tabanlı OOP'de (Java, C++, C# gibi), önce bir sınıf tanımlanır, sonra bu sınıftan nesneler oluşturulur. Sınıf, nesnelerin şablonu görevi görür.

```java
// Java - Sınıf tabanlı OOP
class Animal {
    void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Woof!");
    }
}

Dog myDog = new Dog();
myDog.makeSound(); // "Woof!"
```

**Prototip Tabanlı OOP Nedir?**
Prototip tabanlı OOP'de, nesneler doğrudan oluşturulur ve diğer nesnelerden özellik ve metodları miras alır. Her nesne, başka bir nesnenin prototipi olabilir.

```javascript
// JavaScript - Prototip tabanlı OOP
const animal = {
    makeSound() {
        console.log('Some sound');
    }
};

const dog = Object.create(animal);
dog.makeSound(); // "Some sound" - prototip zincirinden gelir
```

**Temel Farklar:**

| Özellik | Sınıf Tabanlı | Prototip Tabanlı |
|---------|---------------|------------------|
| **Yapı** | Önce sınıf, sonra nesne | Doğrudan nesne oluşturma |
| **Miras** | Statik, derleme zamanında | Dinamik, çalışma zamanında |
| **Hiyerarşi** | Katı, sabit | Esnek, değişebilir |
| **Özellik Ekleme** | Sınıf tanımında | Çalışma zamanında |
| **Performans** | Daha yavaş başlatma | Daha hızlı başlatma |

**Prototip Zinciri (Prototype Chain) Nedir?**

JavaScript'te her nesne, başka bir nesneye referans tutar (prototype). Bu referanslar bir zincir oluşturur:

```javascript
// Prototip zinciri örneği
const grandParent = {
    name: 'GrandParent',
    sayHello() {
        console.log(`Hello from ${this.name}`);
    }
};

const parent = Object.create(grandParent);
parent.name = 'Parent';

const child = Object.create(parent);
child.name = 'Child';

child.sayHello(); // "Hello from Child"
// Zincir: child -> parent -> grandParent -> Object.prototype -> null
```

**Neden İhtiyaç Var?**

1. **Esneklik**: Çalışma zamanında nesne yapısını değiştirme
```javascript
const person = { name: 'John' };
// Çalışma zamanında metod ekleme
person.greet = function() { console.log(`Hello, I'm ${this.name}`); };
person.greet(); // "Hello, I'm John"
```

2. **Dinamiklik**: Dinamik özellik ekleme/çıkarma
```javascript
const obj = {};
// Özellik ekleme
obj.newProperty = 'value';
// Özellik silme
delete obj.newProperty;
```

3. **Basitlik**: Karmaşık sınıf tanımları gerektirmez
```javascript
// Basit nesne oluşturma
const car = {
    brand: 'Toyota',
    start() { console.log('Engine started'); }
};
```

4. **Performans**: Daha hızlı nesne oluşturma
```javascript
// Prototip paylaşımı ile bellek tasarrufu
const vehiclePrototype = {
    wheels: 4,
    move() { console.log('Moving...'); }
};

const car1 = Object.create(vehiclePrototype);
const car2 = Object.create(vehiclePrototype);
// Her iki araba da aynı prototipi paylaşır
```

**Ne İşe Yarar?**

1. **Object Composition**: Nesne kompozisyonu
```javascript
const canFly = { fly() { console.log('Flying...'); } };
const canSwim = { swim() { console.log('Swimming...'); } };

const duck = Object.assign({}, canFly, canSwim);
duck.fly(); // "Flying..."
duck.swim(); // "Swimming..."
```

2. **Dynamic Inheritance**: Dinamik miras
```javascript
const animal = { type: 'animal' };
const dog = Object.create(animal);
dog.breed = 'Labrador';

// Çalışma zamanında miras değiştirme
const cat = Object.create(animal);
dog.__proto__ = cat; // Prototip değiştirme (önerilmez)
```

3. **Mixin Pattern**: Mixin deseni
```javascript
const loggerMixin = {
    log(message) { console.log(`[${this.name}]: ${message}`); }
};

const user = { name: 'John' };
Object.assign(user, loggerMixin);
user.log('Hello'); // "[John]: Hello"
```

4. **Prototype Chain**: Prototip zinciri
```javascript
// Zincir: myArray -> Array.prototype -> Object.prototype -> null
const myArray = [1, 2, 3];
console.log(myArray.toString()); // "1,2,3" (Array.prototype'den)
console.log(myArray.hasOwnProperty); // function (Object.prototype'den)
```

**Constructor Function ile Prototip Kullanımı:**

```javascript
// Constructor function
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Prototip metodları
Person.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

Person.prototype.getAge = function() {
    return this.age;
};

// Nesne oluşturma
const john = new Person('John', 30);
john.greet(); // "Hello, I'm John"
console.log(john.getAge()); // 30

// Prototip zinciri kontrolü
console.log(john.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
```

**Modern JavaScript'te Class Syntax:**

ES6 ile gelen class syntax, aslında prototip tabanlı OOP'nin sözdizimsel şekeridir:

```javascript
// ES6 Class (arka planda prototip kullanır)
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    makeSound() {
        console.log('Some sound');
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    makeSound() {
        console.log('Woof!');
    }
}

const myDog = new Dog('Buddy', 'Labrador');
myDog.makeSound(); // "Woof!"

// Arka planda hala prototip kullanılır
console.log(myDog.__proto__ === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
```

**Prototip Tabanlı OOP'nin Avantajları:**

1. **Esneklik**: Çalışma zamanında nesne yapısını değiştirebilme
2. **Dinamiklik**: Özellik ve metodları dinamik olarak ekleme/çıkarma
3. **Bellek Verimliliği**: Prototip paylaşımı ile bellek tasarrufu
4. **Basitlik**: Karmaşık sınıf tanımları gerektirmez
5. **Performans**: Daha hızlı nesne oluşturma

**Prototip Tabanlı OOP'nin Dezavantajları:**

1. **Öğrenme Eğrisi**: Sınıf tabanlı dillerden gelenler için kafa karıştırıcı
2. **Hata Riski**: Prototip zinciri karmaşık olabilir
3. **Debug Zorluğu**: Prototip zincirini takip etmek zor olabilir
4. **Performans**: Derin prototip zincirleri performansı etkileyebilir

**First-class Functions - Birinci Sınıf Fonksiyonlar**

JavaScript'te fonksiyonlar, diğer değerler gibi işlenebilir. Bu, fonksiyonel programlama paradigmasının temelini oluşturur.

**First-class Functions Ne Demek?**

Bir programlama dilinde fonksiyonlar "first-class citizens" (birinci sınıf vatandaşlar) ise, o fonksiyonlar diğer değerler gibi işlenebilir. JavaScript'te fonksiyonlar tam olarak bu özelliğe sahiptir.

**Temel Özellikler:**

1. **Değişkene Atanabilir**: Fonksiyonlar değişkenlere atanabilir
```javascript
const greet = function(name) {
    return `Hello, ${name}!`;
};

const sayHello = greet;
console.log(sayHello('John')); // "Hello, John!"
```

2. **Parametre Olarak Geçilebilir**: Fonksiyonlar başka fonksiyonlara parametre olarak geçilebilir
```javascript
function processUser(name, callback) {
    const processedName = name.toUpperCase();
    return callback(processedName);
}

function greet(name) {
    return `Hello, ${name}!`;
}

const result = processUser('john', greet);
console.log(result); // "Hello, JOHN!"
```

3. **Dönüş Değeri Olabilir**: Fonksiyonlar başka fonksiyonları döndürebilir
```javascript
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

4. **Nesne Özelliği Olabilir**: Fonksiyonlar nesne özelliği olarak saklanabilir
```javascript
const calculator = {
    add: function(a, b) { return a + b; },
    subtract: function(a, b) { return a - b; },
    multiply: function(a, b) { return a * b; }
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.multiply(4, 6)); // 24
```

5. **Dizi Elemanı Olabilir**: Fonksiyonlar dizilerde saklanabilir
```javascript
const operations = [
    function(x) { return x + 1; },
    function(x) { return x * 2; },
    function(x) { return x - 3; }
];

let result = 5;
operations.forEach(op => {
    result = op(result);
});
console.log(result); // 9 ((5+1)*2-3)
```

**Higher-order Functions - Yüksek Dereceli Fonksiyonlar**

First-class functions sayesinde higher-order functions mümkün olur:

```javascript
// Higher-order function: Başka fonksiyon alan veya döndüren fonksiyon
function withLogging(fn) {
    return function(...args) {
        console.log(`Calling function with args:`, args);
        const result = fn(...args);
        console.log(`Function returned:`, result);
        return result;
    };
}

const add = (a, b) => a + b;
const loggedAdd = withLogging(add);

console.log(loggedAdd(2, 3));
// "Calling function with args: [2, 3]"
// "Function returned: 5"
// 5
```

**Callback Pattern - Geri Çağırma Deseni**

```javascript
// Callback pattern örneği
function fetchData(url, onSuccess, onError) {
    // Simüle edilmiş API çağrısı
    setTimeout(() => {
        const success = Math.random() > 0.5;
        if (success) {
            onSuccess({ data: 'Sample data' });
        } else {
            onError(new Error('API call failed'));
        }
    }, 1000);
}

fetchData(
    'https://api.example.com',
    (data) => console.log('Success:', data),
    (error) => console.error('Error:', error.message)
);
```

**Function Composition - Fonksiyon Kompozisyonu**

```javascript
// Fonksiyon kompozisyonu
const compose = (f, g) => (x) => f(g(x));

const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;

const addOneThenMultiplyByTwo = compose(multiplyByTwo, addOne);
console.log(addOneThenMultiplyByTwo(5)); // 12 ((5+1)*2)

// Birden fazla fonksiyon kompozisyonu
const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);

const processNumber = pipe(
    x => x + 1,      // 5 -> 6
    x => x * 2,      // 6 -> 12
    x => x - 3,      // 12 -> 9
    x => x.toString() // 9 -> "9"
);

console.log(processNumber(5)); // "9"
```

**Closure - Kapanışlar**

First-class functions ile closure'lar mümkün olur:

```javascript
function createCounter() {
    let count = 0;
    
    return function() {
        count++;
        return count;
    };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (ayrı closure)
console.log(counter1()); // 3
```

**Event Handling - Olay İşleme**

```javascript
// Event handling örneği
const button = document.getElementById('myButton');

// Fonksiyon olarak event handler
function handleClick(event) {
    console.log('Button clicked!', event);
}

button.addEventListener('click', handleClick);

// Arrow function olarak event handler
button.addEventListener('mouseover', (event) => {
    console.log('Mouse over button!', event);
});
```

**Array Methods ile First-class Functions**

```javascript
const numbers = [1, 2, 3, 4, 5];

// map: Her elemanı dönüştür
const doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter: Elemanları filtrele
const evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]

// reduce: Elemanları birleştir
const sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 15

// forEach: Her eleman için işlem yap
numbers.forEach(x => console.log(x * 3));
// 3, 6, 9, 12, 15
```

**Asynchronous Programming - Asenkron Programlama**

```javascript
// Promise ile asenkron işlemler
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function asyncExample() {
    console.log('Starting...');
    await delay(1000);
    console.log('After 1 second');
    await delay(1000);
    console.log('After 2 seconds');
}

asyncExample();

// Callback ile asenkron işlemler
function fetchUserData(userId, callback) {
    setTimeout(() => {
        callback({ id: userId, name: 'John Doe' });
    }, 1000);
}

fetchUserData(123, (user) => {
    console.log('User data:', user);
});
```

**Neden İhtiyaç Var?**

1. **Modularity**: Kod modülerliği ve yeniden kullanılabilirliği
2. **Abstraction**: Karmaşık işlemleri basit fonksiyonlarla soyutlama
3. **Flexibility**: Esnek ve dinamik kod yapısı
4. **Functional Programming**: Fonksiyonel programlama paradigması
5. **Event-driven Programming**: Olay tabanlı programlama

**Ne İşe Yarar?**

1. **Code Reusability**: Kod yeniden kullanılabilirliği
2. **Abstraction**: Soyutlama ve karmaşıklığı gizleme
3. **Composition**: Fonksiyon kompozisyonu ile karmaşık işlemler
4. **Asynchronous Programming**: Asenkron programlama desteği
5. **Event Handling**: Olay işleme ve kullanıcı etkileşimi
6. **Higher-order Functions**: Yüksek dereceli fonksiyonlar
7. **Closures**: Kapanışlar ile veri gizleme
8. **Functional Programming**: Fonksiyonel programlama teknikleri

**Pratik Kullanım Örnekleri:**

```javascript
// 1. Configuration pattern
function createApiClient(config) {
    return {
        get: (url) => fetch(`${config.baseUrl}${url}`),
        post: (url, data) => fetch(`${config.baseUrl}${url}`, {
            method: 'POST',
            body: JSON.stringify(data)
        })
    };
}

const api = createApiClient({ baseUrl: 'https://api.example.com' });

// 2. Middleware pattern
function createMiddleware(handlers) {
    return function(req, res, next) {
        let index = 0;
        
        function runNext() {
            if (index < handlers.length) {
                handlers[index++](req, res, runNext);
            } else if (next) {
                next();
            }
        }
        
        runNext();
    };
}

// 3. Strategy pattern
const strategies = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b
};

function calculate(operation, a, b) {
    return strategies[operation](a, b);
}

console.log(calculate('add', 5, 3)); // 8
```

**Dynamic Typing - Dinamik Tip Sistemi**

JavaScript'te değişkenlerin tipi çalışma zamanında belirlenir. Bu, esneklik sağlar ancak hata riski de yaratır.

**Dynamic Typing Ne Demek?**

Dynamic typing (dinamik tip sistemi), değişkenlerin tipinin çalışma zamanında (runtime) belirlendiği bir tip sistemidir. JavaScript'te değişkenlerin tipini önceden belirtmek zorunda değilsiniz.

**Static Typing vs Dynamic Typing:**

| Özellik | Static Typing (Java, C#) | Dynamic Typing (JavaScript) |
|---------|---------------------------|------------------------------|
| **Tip Kontrolü** | Derleme zamanında | Çalışma zamanında |
| **Tip Belirtme** | Zorunlu | İsteğe bağlı |
| **Hata Tespiti** | Erken (derleme) | Geç (çalışma) |
| **Performans** | Daha hızlı | Daha yavaş |
| **Esneklik** | Düşük | Yüksek |

**Temel Özellikler:**

1. **Tip Belirtme Yok**: Değişken tanımlarken tip belirtmek zorunda değilsiniz
```javascript
// JavaScript - Tip belirtme yok
let x = 5;        // x number tipinde
x = "hello";      // x string tipine dönüştü
x = true;         // x boolean tipine dönüştü
x = [1, 2, 3];    // x array tipine dönüştü
x = { name: "John" }; // x object tipine dönüştü
```

```java
// Java - Tip belirtme zorunlu
int x = 5;        // x sadece int olabilir
// x = "hello";   // HATA! Tip uyumsuzluğu
```

2. **Çalışma Zamanında Tip**: Değişken tipi değere göre belirlenir
```javascript
let variable;
console.log(typeof variable); // "undefined"

variable = 42;
console.log(typeof variable); // "number"

variable = "Hello";
console.log(typeof variable); // "string"

variable = true;
console.log(typeof variable); // "boolean"

variable = {};
console.log(typeof variable); // "object"

variable = [];
console.log(typeof variable); // "object" (array'ler object'tir)

variable = function() {};
console.log(typeof variable); // "function"
```

3. **Otomatik Tip Dönüşümü (Type Coercion)**: JavaScript otomatik tip dönüşümü yapar
```javascript
// String + Number = String
console.log("5" + 3);        // "53" (string)
console.log(5 + "3");        // "53" (string)

// Number + Number = Number
console.log(5 + 3);          // 8 (number)

// Boolean dönüşümü
console.log("5" - 3);        // 2 (number)
console.log("5" * 3);        // 15 (number)
console.log("5" / 3);        // 1.666... (number)

// Truthy/Falsy değerler
console.log(Boolean(""));    // false
console.log(Boolean("hello")); // true
console.log(Boolean(0));     // false
console.log(Boolean(1));     // true
console.log(Boolean(null));  // false
console.log(Boolean(undefined)); // false
```

4. **Loose Typing**: Gevşek tip sistemi
```javascript
// == operatörü tip dönüşümü yapar
console.log(5 == "5");       // true (tip dönüşümü)
console.log(5 === "5");      // false (tip kontrolü)

// Falsy değerler
console.log(0 == false);     // true
console.log("" == false);    // true
console.log(null == undefined); // true

// Strict equality (===) kullanımı önerilir
console.log(0 === false);    // false
console.log("" === false);   // false
console.log(null === undefined); // false
```

**Type Coercion Örnekleri:**

```javascript
// 1. String coercion
console.log(String(123));        // "123"
console.log(String(true));       // "true"
console.log(String(null));       // "null"
console.log(String(undefined));  // "undefined"

// 2. Number coercion
console.log(Number("123"));      // 123
console.log(Number(""));         // 0
console.log(Number("hello"));    // NaN
console.log(Number(true));       // 1
console.log(Number(false));      // 0
console.log(Number(null));       // 0
console.log(Number(undefined));  // NaN

// 3. Boolean coercion
console.log(Boolean(1));         // true
console.log(Boolean(0));         // false
console.log(Boolean(""));        // false
console.log(Boolean("hello"));   // true
console.log(Boolean([]));        // true (boş array truthy)
console.log(Boolean({}));        // true (boş object truthy)
```

**typeof Operatörü:**

```javascript
// typeof operatörü ile tip kontrolü
console.log(typeof 42);          // "number"
console.log(typeof "hello");     // "string"
console.log(typeof true);        // "boolean"
console.log(typeof undefined);   // "undefined"
console.log(typeof null);        // "object" (JavaScript'in bilinen hatası)
console.log(typeof {});          // "object"
console.log(typeof []);          // "object"
console.log(typeof function(){}); // "function"

// Array kontrolü için Array.isArray() kullanın
console.log(Array.isArray([]));  // true
console.log(Array.isArray({}));  // false
```

**Dynamic Typing'in Avantajları:**

1. **Esneklik**: Aynı değişkeni farklı tiplerde kullanabilme
```javascript
let data = 42;
console.log(data); // 42

data = "Hello World";
console.log(data); // "Hello World"

data = { name: "John", age: 30 };
console.log(data); // { name: "John", age: 30 }
```

2. **Hızlı Prototipleme**: Tip belirtme gerektirmez
```javascript
// Hızlı prototip geliştirme
function processData(input) {
    if (typeof input === 'string') {
        return input.toUpperCase();
    } else if (typeof input === 'number') {
        return input * 2;
    } else if (Array.isArray(input)) {
        return input.length;
    }
    return input;
}

console.log(processData("hello"));    // "HELLO"
console.log(processData(5));          // 10
console.log(processData([1, 2, 3]));  // 3
```

3. **Basitlik**: Karmaşık tip tanımları gerektirmez
```javascript
// Basit ve anlaşılır kod
let user = {
    name: "John",
    age: 30,
    isActive: true
};

// Dinamik özellik ekleme
user.email = "john@example.com";
user.lastLogin = new Date();
```

4. **JSON Uyumluluğu**: JSON ile doğal uyum
```javascript
// JSON'dan gelen veri doğrudan kullanılabilir
const jsonData = '{"name": "John", "age": 30}';
const user = JSON.parse(jsonData);
console.log(user.name); // "John"
console.log(user.age);  // 30
```

**Dynamic Typing'in Dezavantajları:**

1. **Runtime Hatalar**: Tip hataları çalışma zamanında ortaya çıkar
```javascript
function calculateTotal(price, quantity) {
    return price * quantity;
}

// Yanlış kullanım - runtime'da hata
console.log(calculateTotal("10", "5")); // "105" (string concatenation)
console.log(calculateTotal(10, 5));     // 50 (doğru)
```

2. **Debug Zorluğu**: Tip hatalarını bulmak zor olabilir
```javascript
let user = { name: "John" };
// user.age kullanılmaya çalışılıyor ama tanımlı değil
console.log(user.age); // undefined (hata değil ama beklenmeyen)
```

3. **IDE Desteği**: IDE'ler tip kontrolü yapamaz
```javascript
let data = "hello";
// IDE, data'nın string olduğunu bilmez
// data.toUpperCase() için otomatik tamamlama çalışmayabilir
```

**Type Safety İçin Best Practices:**

1. **Strict Equality (===) Kullanın**:
```javascript
// Kötü
if (value == 0) { }

// İyi
if (value === 0) { }
```

2. **Type Checking Yapın**:
```javascript
function safeAdd(a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw new Error('Both arguments must be numbers');
    }
    return a + b;
}
```

3. **JSDoc Kullanın**:
```javascript
/**
 * Calculates the total price
 * @param {number} price - The price per item
 * @param {number} quantity - The quantity of items
 * @returns {number} The total price
 */
function calculateTotal(price, quantity) {
    return price * quantity;
}
```

4. **TypeScript Kullanın** (İsteğe bağlı):
```typescript
// TypeScript ile tip güvenliği
function calculateTotal(price: number, quantity: number): number {
    return price * quantity;
}
```

**Neden İhtiyaç Var?**

1. **Web Geliştirme**: Web'de hızlı prototipleme gereksinimi
2. **Esneklik**: Farklı veri tiplerini aynı değişkende tutabilme
3. **Basitlik**: Karmaşık tip sistemleri olmadan geliştirme
4. **JSON Uyumluluğu**: Web API'leri ile doğal uyum
5. **Hızlı Geliştirme**: Tip belirtme gerektirmez

**Ne İşe Yarar?**

1. **Rapid Development**: Hızlı geliştirme ve prototipleme
2. **Flexible Code**: Esnek ve dinamik kod yapısı
3. **Quick Prototyping**: Hızlı prototip geliştirme
4. **Dynamic Behavior**: Dinamik davranış ve özellik ekleme
5. **JSON Integration**: JSON verileri ile doğal çalışma
6. **API Integration**: Web API'leri ile kolay entegrasyon
7. **Configuration**: Dinamik konfigürasyon dosyaları
8. **Data Processing**: Farklı veri tiplerini işleme

**Pratik Kullanım Örnekleri:**

```javascript
// 1. API Response Handling
function handleApiResponse(response) {
    if (typeof response === 'string') {
        return JSON.parse(response);
    } else if (typeof response === 'object') {
        return response;
    }
    throw new Error('Invalid response type');
}

// 2. Form Data Processing
function processFormData(formData) {
    const processed = {};
    
    for (let key in formData) {
        const value = formData[key];
        
        // String'den number'a dönüştür
        if (!isNaN(value) && value !== '') {
            processed[key] = Number(value);
        } else if (value === 'true' || value === 'false') {
            processed[key] = value === 'true';
        } else {
            processed[key] = value;
        }
    }
    
    return processed;
}

// 3. Dynamic Function Creation
function createValidator(type) {
    switch (type) {
        case 'email':
            return (value) => typeof value === 'string' && value.includes('@');
        case 'number':
            return (value) => typeof value === 'number' && !isNaN(value);
        case 'required':
            return (value) => value !== null && value !== undefined && value !== '';
        default:
            return () => true;
    }
}

const emailValidator = createValidator('email');
console.log(emailValidator('test@example.com')); // true
console.log(emailValidator('invalid-email'));    // false
```

**Functional Programming - Fonksiyonel Programlama Özellikleri**

JavaScript, fonksiyonel programlama paradigmasını destekler. Bu, kodun daha temiz ve sürdürülebilir olmasını sağlar.

**Functional Programming Ne Demek?**

Functional Programming (FP), programlamayı fonksiyonların değerlendirilmesi olarak gören bir programlama paradigmasıdır. JavaScript, first-class functions desteği sayesinde fonksiyonel programlama tekniklerini kullanabilir.

**Temel Prensipler:**

1. **Pure Functions - Saf Fonksiyonlar**: Aynı girdi için her zaman aynı çıktıyı veren ve yan etkisi olmayan fonksiyonlar
```javascript
// Pure function - Saf fonksiyon
function add(a, b) {
    return a + b;
}

// Impure function - Saf olmayan fonksiyon
let counter = 0;
function increment() {
    counter++; // Yan etki: global değişkeni değiştiriyor
    return counter;
}

// Pure function örneği
function multiply(x, y) {
    return x * y;
}

console.log(multiply(3, 4)); // 12 (her zaman aynı sonuç)
console.log(multiply(3, 4)); // 12 (her zaman aynı sonuç)
```

2. **Immutability - Değişmezlik**: Verilerin değiştirilmemesi, yeni veri oluşturulması
```javascript
// Mutable (değiştirilebilir) - Kötü
const numbers = [1, 2, 3];
numbers.push(4); // Orijinal array'i değiştiriyor
console.log(numbers); // [1, 2, 3, 4]

// Immutable (değiştirilemez) - İyi
const originalNumbers = [1, 2, 3];
const newNumbers = [...originalNumbers, 4]; // Yeni array oluşturuyor
console.log(originalNumbers); // [1, 2, 3] (değişmedi)
console.log(newNumbers); // [1, 2, 3, 4] (yeni array)

// Object immutability
const user = { name: 'John', age: 30 };
const updatedUser = { ...user, age: 31 }; // Yeni object oluşturuyor
console.log(user); // { name: 'John', age: 30 } (değişmedi)
console.log(updatedUser); // { name: 'John', age: 31 } (yeni object)
```

3. **Higher-order Functions - Yüksek Dereceli Fonksiyonlar**: Fonksiyonları parametre olarak alan veya fonksiyon döndüren fonksiyonlar
```javascript
// Higher-order function örneği
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// Array methods - Higher-order functions
const numbers = [1, 2, 3, 4, 5];

// map: Her elemanı dönüştür
const doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter: Elemanları filtrele
const evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]

// reduce: Elemanları birleştir
const sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 15
```

4. **Function Composition - Fonksiyon Kompozisyonu**: Küçük fonksiyonları birleştirerek büyük fonksiyonlar oluşturma
```javascript
// Basit kompozisyon
const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;
const square = x => x * x;

// Manuel kompozisyon
const result1 = square(multiplyByTwo(addOne(5)));
console.log(result1); // 144 ((5+1)*2)^2

// Compose function
const compose = (f, g) => (x) => f(g(x));
const addOneThenMultiplyByTwo = compose(multiplyByTwo, addOne);
console.log(addOneThenMultiplyByTwo(5)); // 12

// Pipe function (sol-sağ kompozisyon)
const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);
const processNumber = pipe(
    addOne,           // 5 -> 6
    multiplyByTwo,    // 6 -> 12
    square           // 12 -> 144
);
console.log(processNumber(5)); // 144
```

**Functional Programming Teknikleri:**

1. **Currying - Kürleme**: Çoklu parametreli fonksiyonu tek parametreli fonksiyonlar serisine dönüştürme
```javascript
// Normal fonksiyon
function add(a, b) {
    return a + b;
}

// Curried fonksiyon
function curriedAdd(a) {
    return function(b) {
        return a + b;
    };
}

// Arrow function ile currying
const curriedAddArrow = a => b => a + b;

console.log(add(2, 3)); // 5
console.log(curriedAdd(2)(3)); // 5
console.log(curriedAddArrow(2)(3)); // 5

// Kısmi uygulama
const addFive = curriedAdd(5);
console.log(addFive(3)); // 8
console.log(addFive(10)); // 15
```

2. **Partial Application - Kısmi Uygulama**: Fonksiyonun bazı parametrelerini önceden doldurma
```javascript
function multiply(a, b, c) {
    return a * b * c;
}

// Kısmi uygulama
function partialMultiply(a) {
    return function(b, c) {
        return multiply(a, b, c);
    };
}

const multiplyByTwo = partialMultiply(2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

// bind ile kısmi uygulama
const multiplyByThree = multiply.bind(null, 3);
console.log(multiplyByThree(4, 5)); // 60 (3 * 4 * 5)
```

3. **Closure - Kapanışlar**: Fonksiyonun kendi scope'u dışındaki değişkenlere erişimi
```javascript
function createCounter() {
    let count = 0;
    
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
console.log(counter.decrement()); // 1

// count değişkeni dışarıdan erişilemez (encapsulation)
```

4. **Recursion - Özyineleme**: Fonksiyonun kendini çağırması
```javascript
// Iterative approach
function factorialIterative(n) {
    let result = 1;
    for (let i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

// Recursive approach
function factorialRecursive(n) {
    if (n <= 1) return 1;
    return n * factorialRecursive(n - 1);
}

console.log(factorialIterative(5)); // 120
console.log(factorialRecursive(5)); // 120

// Tail recursion (optimized)
function factorialTailRecursive(n, acc = 1) {
    if (n <= 1) return acc;
    return factorialTailRecursive(n - 1, n * acc);
}

console.log(factorialTailRecursive(5)); // 120
```

**Array Functional Methods:**

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// map: Dönüştürme
const squares = numbers.map(x => x * x);
console.log(squares); // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// filter: Filtreleme
const evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4, 6, 8, 10]

// reduce: Birleştirme
const sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 55

// find: Bulma
const firstEven = numbers.find(x => x % 2 === 0);
console.log(firstEven); // 2

// some: Herhangi biri
const hasEven = numbers.some(x => x % 2 === 0);
console.log(hasEven); // true

// every: Hepsi
const allPositive = numbers.every(x => x > 0);
console.log(allPositive); // true

// flatMap: Düzleştirme ve dönüştürme
const nested = [[1, 2], [3, 4], [5, 6]];
const flattened = nested.flatMap(arr => arr.map(x => x * 2));
console.log(flattened); // [2, 4, 6, 8, 10, 12]
```

**Functional Programming Patterns:**

1. **Monad Pattern**: Hata yönetimi ve zincirleme
```javascript
// Maybe monad benzeri
class Maybe {
    constructor(value) {
        this.value = value;
    }
    
    static of(value) {
        return new Maybe(value);
    }
    
    map(fn) {
        return this.value == null ? Maybe.of(null) : Maybe.of(fn(this.value));
    }
    
    flatMap(fn) {
        return this.value == null ? Maybe.of(null) : fn(this.value);
    }
}

const result = Maybe.of(5)
    .map(x => x * 2)
    .map(x => x + 1)
    .map(x => x.toString());

console.log(result.value); // "11"

const nullResult = Maybe.of(null)
    .map(x => x * 2)
    .map(x => x + 1);

console.log(nullResult.value); // null (hata yok)
```

2. **Functor Pattern**: map metoduna sahip objeler
```javascript
// Array bir functor'dır
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2); // [2, 4, 6]

// Custom functor
class Box {
    constructor(value) {
        this.value = value;
    }
    
    map(fn) {
        return new Box(fn(this.value));
    }
    
    fold() {
        return this.value;
    }
}

const result = new Box(5)
    .map(x => x * 2)
    .map(x => x + 1)
    .fold();

console.log(result); // 11
```

**Neden İhtiyaç Var?**

1. **Predictability - Öngörülebilirlik**: Pure functions aynı girdi için her zaman aynı çıktıyı verir
2. **Testability - Test Edilebilirlik**: Pure functions kolay test edilir
3. **Maintainability - Sürdürülebilirlik**: Kod daha temiz ve anlaşılır
4. **Concurrency - Eşzamanlılık**: Immutable data thread-safe'dir
5. **Debugging - Hata Ayıklama**: Yan etkiler olmadığı için debug kolay

**Ne İşe Yarar?**

1. **Clean Code**: Temiz ve okunabilir kod
2. **Bug Prevention**: Hata önleme ve güvenilirlik
3. **Performance**: Optimizasyon fırsatları
4. **Scalability**: Büyük uygulamalarda yönetilebilirlik
5. **Reusability**: Kod yeniden kullanılabilirliği
6. **Modularity**: Modüler kod yapısı

**Pratik Kullanım Örnekleri:**

```javascript
// 1. Data Processing Pipeline
const users = [
    { name: 'John', age: 25, active: true },
    { name: 'Jane', age: 30, active: false },
    { name: 'Bob', age: 35, active: true },
    { name: 'Alice', age: 28, active: true }
];

const activeUserNames = users
    .filter(user => user.active)
    .map(user => user.name.toUpperCase())
    .sort();

console.log(activeUserNames); // ['ALICE', 'BOB', 'JOHN']

// 2. Function Composition for Validation
const isString = x => typeof x === 'string';
const isNotEmpty = x => x.length > 0;
const isEmail = x => x.includes('@');

const validateEmail = (email) => {
    const validators = [isString, isNotEmpty, isEmail];
    return validators.every(validator => validator(email));
};

console.log(validateEmail('test@example.com')); // true
console.log(validateEmail('invalid')); // false

// 3. Immutable State Management
const initialState = { count: 0, user: null };

const reducer = (state, action) => {
    switch (action.type) {
        case 'INCREMENT':
            return { ...state, count: state.count + 1 };
        case 'SET_USER':
            return { ...state, user: action.payload };
        default:
            return state;
    }
};

let state = initialState;
state = reducer(state, { type: 'INCREMENT' });
state = reducer(state, { type: 'SET_USER', payload: { name: 'John' } });

console.log(state); // { count: 1, user: { name: 'John' } }
console.log(initialState); // { count: 0, user: null } (değişmedi)
```

**Functional Programming vs Object-Oriented Programming:**

| Özellik | Functional Programming | Object-Oriented Programming |
|---------|------------------------|----------------------------|
| **Temel Birim** | Fonksiyon | Nesne |
| **Veri** | Immutable | Mutable |
| **Yan Etki** | Yok | Var |
| **Öğrenme Eğrisi** | Orta | Kolay |
| **Performans** | İyi | İyi |
| **Test Edilebilirlik** | Çok İyi | İyi |
| **Debug** | Kolay | Orta |

JavaScript, hem functional hem de object-oriented programlama paradigmalarını destekler, bu da geliştiricilere esneklik sağlar.

**C-like Syntax - C Benzeri Sözdizimi**

JavaScript'in sözdizimi, C programlama diline benzer. Bu, öğrenmeyi kolaylaştırır ve geliştiricilerin JavaScript'i hızlıca öğrenmesini sağlar.

**C-like Syntax Ne Demek?**

JavaScript, C programlama dilinin sözdizimsel özelliklerini benimser. Bu, C ailesindeki dilleri (C++, Java, C#) bilen geliştiricilerin JavaScript'i kolayca öğrenmesini sağlar.

**Temel Sözdizimi Özellikleri:**

1. **Curly Braces - Süslü Parantezler `{}`**: Kod bloklarını tanımlamak için kullanılır
```javascript
// C ve JavaScript'te aynı
if (condition) {
    // kod bloğu
}

function myFunction() {
    // fonksiyon gövdesi
}

for (let i = 0; i < 10; i++) {
    // döngü gövdesi
}
```

```c
// C dilinde
if (condition) {
    /* kod bloğu */
}

void myFunction() {
    /* fonksiyon gövdesi */
}

for (int i = 0; i < 10; i++) {
    /* döngü gövdesi */
}
```

2. **Semicolons - Noktalı Virgüller `;`**: İfadeleri sonlandırmak için kullanılır
```javascript
// JavaScript'te (opsiyonel ama önerilen)
let x = 5;
let y = 10;
let sum = x + y;

// Fonksiyon çağrıları
console.log("Hello World");
myFunction();
```

```c
// C dilinde (zorunlu)
int x = 5;
int y = 10;
int sum = x + y;

printf("Hello World");
myFunction();
```

3. **Keywords - Anahtar Kelimeler**: Dil tarafından rezerve edilmiş kelimeler
```javascript
// JavaScript anahtar kelimeleri
if (condition) { }
else { }
for (let i = 0; i < 10; i++) { }
while (condition) { }
do { } while (condition);
switch (value) { case 1: break; }
function myFunction() { }
return value;
var, let, const;
true, false, null, undefined;
```

```c
// C anahtar kelimeleri
if (condition) { }
else { }
for (int i = 0; i < 10; i++) { }
while (condition) { }
do { } while (condition);
switch (value) { case 1: break; }
int myFunction() { }
return value;
int, char, float, double;
true, false, NULL;
```

4. **Operators - Operatörler**: Aritmetik, mantıksal ve karşılaştırma operatörleri
```javascript
// Aritmetik operatörler
let a = 10 + 5;  // 15
let b = 10 - 5;  // 5
let c = 10 * 5;  // 50
let d = 10 / 5;  // 2
let e = 10 % 3;  // 1

// Karşılaştırma operatörleri
let f = 10 > 5;   // true
let g = 10 < 5;   // false
let h = 10 == 10; // true
let i = 10 != 5;  // true

// Mantıksal operatörler
let j = true && false; // false
let k = true || false; // true
let l = !true;         // false
```

```c
// C dilinde aynı operatörler
int a = 10 + 5;  // 15
int b = 10 - 5;  // 5
int c = 10 * 5;  // 50
int d = 10 / 5;  // 2
int e = 10 % 3;  // 1

int f = 10 > 5;   // 1 (true)
int g = 10 < 5;   // 0 (false)
int h = 10 == 10; // 1 (true)
int i = 10 != 5;  // 1 (true)

int j = 1 && 0;   // 0 (false)
int k = 1 || 0;   // 1 (true)
int l = !1;       // 0 (false)
```

**Kontrol Yapıları:**

1. **If-Else Statements**:
```javascript
// JavaScript
if (age >= 18) {
    console.log("Adult");
} else if (age >= 13) {
    console.log("Teenager");
} else {
    console.log("Child");
}
```

```c
// C dilinde
if (age >= 18) {
    printf("Adult");
} else if (age >= 13) {
    printf("Teenager");
} else {
    printf("Child");
}
```

2. **For Loops**:
```javascript
// JavaScript
for (let i = 0; i < 10; i++) {
    console.log(i);
}

// Array iteration
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}
```

```c
// C dilinde
for (int i = 0; i < 10; i++) {
    printf("%d\n", i);
}

// Array iteration
int numbers[] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i++) {
    printf("%d\n", numbers[i]);
}
```

3. **While Loops**:
```javascript
// JavaScript
let i = 0;
while (i < 10) {
    console.log(i);
    i++;
}

// Do-while
let j = 0;
do {
    console.log(j);
    j++;
} while (j < 10);
```

```c
// C dilinde
int i = 0;
while (i < 10) {
    printf("%d\n", i);
    i++;
}

// Do-while
int j = 0;
do {
    printf("%d\n", j);
    j++;
} while (j < 10);
```

4. **Switch Statements**:
```javascript
// JavaScript
switch (day) {
    case 1:
        console.log("Monday");
        break;
    case 2:
        console.log("Tuesday");
        break;
    default:
        console.log("Other day");
}
```

```c
// C dilinde
switch (day) {
    case 1:
        printf("Monday");
        break;
    case 2:
        printf("Tuesday");
        break;
    default:
        printf("Other day");
}
```

**Fonksiyon Tanımlama:**

```javascript
// JavaScript
function add(a, b) {
    return a + b;
}

// Arrow function (ES6)
const multiply = (a, b) => a * b;

// Function expression
const divide = function(a, b) {
    return a / b;
};
```

```c
// C dilinde
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    return a / b;
}
```

**Değişken Tanımlama:**

```javascript
// JavaScript (ES6+)
let mutableVar = 10;
const immutableVar = 20;
var oldStyleVar = 30;

// Tip belirtme yok
let number = 42;
let text = "Hello";
let flag = true;
```

```c
// C dilinde
int mutableVar = 10;
const int immutableVar = 20;

// Tip belirtme zorunlu
int number = 42;
char text[] = "Hello";
int flag = 1; // C'de boolean yok
```

**JavaScript'e Özgü Farklar:**

1. **Automatic Semicolon Insertion (ASI)**:
```javascript
// JavaScript'te noktalı virgül opsiyonel
let x = 5
let y = 10

// Ama bazen gerekli
let a = 5
let b = 10
[a, b] = [b, a] // Hata! ASI yanlış yorumlar

// Doğru kullanım
let a = 5;
let b = 10;
[a, b] = [b, a]; // Çalışır
```

2. **Hoisting**:
```javascript
// JavaScript'te hoisting var
console.log(x); // undefined (hata değil)
var x = 5;

// let/const ile hoisting yok
console.log(y); // ReferenceError
let y = 5;
```

3. **Function Hoisting**:
```javascript
// JavaScript'te fonksiyon hoisting var
myFunction(); // Çalışır!

function myFunction() {
    console.log("Hello");
}

// Function expression ile hoisting yok
myFunction2(); // TypeError
var myFunction2 = function() {
    console.log("Hello");
};
```

**Neden İhtiyaç Var?**

1. **Familiarity - Tanıdıklık**: C ailesindeki dilleri bilenler için tanıdık
2. **Learning Curve - Öğrenme Eğrisi**: Daha kolay öğrenme
3. **Adoption - Benimsenme**: Hızlı benimsenme ve yaygınlaşma
4. **Compatibility - Uyumluluk**: Mevcut programlama bilgisi ile uyumluluk
5. **Industry Standard - Endüstri Standardı**: Yaygın kullanılan sözdizimi

**Ne İşe Yarar?**

1. **Easy Learning - Kolay Öğrenme**: C bilenler için hızlı öğrenme
2. **Wide Adoption - Yaygın Benimsenme**: Geniş geliştirici kitlesi
3. **Developer Comfort - Geliştirici Rahatlığı**: Tanıdık sözdizimi
4. **Industry Standard - Endüstri Standardı**: Standart programlama sözdizimi
5. **Code Readability - Kod Okunabilirliği**: Anlaşılır kod yapısı
6. **Team Collaboration - Takım İşbirliği**: Ortak sözdizimi anlayışı

**JavaScript vs C Sözdizimi Karşılaştırması:**

| Özellik | JavaScript | C |
|---------|------------|---|
| **Tip Belirtme** | Opsiyonel | Zorunlu |
| **Noktalı Virgül** | Opsiyonel (ASI) | Zorunlu |
| **Hoisting** | Var | Yok |
| **Closures** | Var | Yok |
| **Prototypes** | Var | Yok |
| **Dynamic Typing** | Var | Yok |
| **Memory Management** | Otomatik | Manuel |

**Pratik Örnekler:**

```javascript
// 1. Basit hesap makinesi
function calculator(a, b, operation) {
    switch (operation) {
        case '+':
            return a + b;
        case '-':
            return a - b;
        case '*':
            return a * b;
        case '/':
            return b !== 0 ? a / b : 'Error: Division by zero';
        default:
            return 'Error: Invalid operation';
    }
}

console.log(calculator(10, 5, '+')); // 15
console.log(calculator(10, 5, '/')); // 2

// 2. Array işlemleri
function processArray(arr) {
    const result = [];
    
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) {
            result.push(arr[i] * 2);
        }
    }
    
    return result;
}

console.log(processArray([1, 2, 3, 4, 5])); // [4, 8]

// 3. Object işlemleri
function createUser(name, age, email) {
    return {
        name: name,
        age: age,
        email: email,
        isAdult: function() {
            return this.age >= 18;
        }
    };
}

const user = createUser('John', 25, 'john@example.com');
console.log(user.isAdult()); // true
```

**Best Practices:**

1. **Consistent Semicolon Usage**:
```javascript
// Tutarlı noktalı virgül kullanımı
let x = 5;
let y = 10;
let sum = x + y;
```

2. **Proper Indentation**:
```javascript
// Doğru girintileme
if (condition) {
    if (nestedCondition) {
        console.log("Nested");
    }
}
```

3. **Meaningful Variable Names**:
```javascript
// Anlamlı değişken isimleri
let userAge = 25;
let isUserActive = true;
let userEmailAddress = "user@example.com";
```

4. **Consistent Bracing Style**:
```javascript
// Tutarlı parantez stili
function myFunction() {
    if (condition) {
        // kod
    } else {
        // kod
    }
}
```

JavaScript'in C-like syntax'ı, geliştiricilerin hızlıca öğrenmesini ve benimsemesini sağlamıştır. Bu, JavaScript'in yaygınlaşmasında önemli bir faktör olmuştur.

**1996 - Microsoft JScript**:
- **Ağustos 1996**: Microsoft, Internet Explorer 3.0 ile birlikte "JScript" adını verdiği JavaScript uyumlu dili yayınladı
- **Uyumluluk Sorunları**: Netscape JavaScript ve Microsoft JScript arasında uyumluluk sorunları başladı
- **Browser Wars**: Tarayıcı savaşları dönemi başladı

**1996 - ECMAScript Standartlaştırma**:
- **Kasım 1996**: Netscape, JavaScript'i ECMA International'a standartlaştırma için sundu
- **ECMA-262**: JavaScript'in resmi adı "ECMAScript" oldu
- **TC39 Komitesi**: ECMAScript geliştirme komitesi kuruldu

**1997 - ECMAScript 1 (ES1) - İlk Standardizasyon**:

ECMAScript 1, JavaScript'in ilk standardizasyonudur. Bu standardizasyon, tarayıcı savaşlarına son vermek ve JavaScript'in tutarlı bir şekilde gelişmesini sağlamak için yapılmıştır.

**ECMAScript 1 Ne Demek?**

ECMAScript 1 (ES1), JavaScript'in ilk resmi standardıdır. ECMA International tarafından ECMA-262 spesifikasyonu olarak yayınlanmıştır. Bu standardizasyon, farklı tarayıcılarda JavaScript'in farklı şekillerde çalışması sorununu çözmek için yapılmıştır.

**Ne Oldu?**
- **Haziran 1997**: İlk ECMAScript spesifikasyonu ECMA-262 olarak yayınlandı
- **Standardizasyon**: JavaScript'in ilk resmi standardı
- **ECMA International**: Avrupa Bilgisayar Üreticileri Birliği tarafından onaylandı
- **Browser Wars Solution**: Tarayıcı savaşlarına çözüm

**Temel Özellikler ve Örnekler:**

1. **Variables - Değişkenler**: `var` ile değişken tanımlama
```javascript
// ES1'de sadece var vardı
var name = "John";
var age = 25;
var isActive = true;

// Global scope (fonksiyon dışında)
var globalVar = "I'm global";

function testFunction() {
    // Function scope
    var localVar = "I'm local";
    console.log(globalVar); // Erişilebilir
}
```

2. **Functions - Fonksiyonlar**: Fonksiyon tanımlama ve çağırma
```javascript
// Function declaration
function greet(name) {
    return "Hello, " + name;
}

// Function expression
var multiply = function(a, b) {
    return a * b;
};

// Fonksiyon çağırma
console.log(greet("World")); // "Hello, World"
console.log(multiply(3, 4)); // 12
```

3. **Objects - Nesneler**: Nesne literal'ları ve constructor'lar
```javascript
// Object literal
var person = {
    name: "John",
    age: 30,
    greet: function() {
        return "Hello, I'm " + this.name;
    }
};

// Constructor function
function Car(brand, model) {
    this.brand = brand;
    this.model = model;
    this.start = function() {
        return this.brand + " " + this.model + " started";
    };
}

var myCar = new Car("Toyota", "Corolla");
console.log(myCar.start()); // "Toyota Corolla started"
```

4. **Arrays - Diziler**: Dizi tanımlama ve metodları
```javascript
// Array literal
var numbers = [1, 2, 3, 4, 5];
var fruits = ["apple", "banana", "orange"];

// Array constructor
var colors = new Array("red", "green", "blue");

// Temel array işlemleri
console.log(numbers.length); // 5
console.log(fruits[0]); // "apple"

// Array metodları (ES1'de sınırlı)
numbers.push(6); // [1, 2, 3, 4, 5, 6]
var last = numbers.pop(); // 6
```

5. **Operators - Operatörler**: Aritmetik, mantıksal ve karşılaştırma operatörleri
```javascript
// Aritmetik operatörler
var a = 10 + 5;  // 15
var b = 10 - 5;  // 5
var c = 10 * 5;  // 50
var d = 10 / 5;  // 2
var e = 10 % 3;  // 1

// Karşılaştırma operatörleri
var f = 10 > 5;   // true
var g = 10 < 5;   // false
var h = 10 == 10; // true
var i = 10 != 5;  // true

// Mantıksal operatörler
var j = true && false; // false
var k = true || false; // true
var l = !true;         // false
```

6. **Control Flow - Kontrol Yapıları**: `if`, `for`, `while` kontrol yapıları
```javascript
// If-else statements
var age = 18;
if (age >= 18) {
    console.log("Adult");
} else {
    console.log("Minor");
}

// For loops
for (var i = 0; i < 5; i++) {
    console.log("Count: " + i);
}

// While loops
var count = 0;
while (count < 3) {
    console.log("While count: " + count);
    count++;
}
```

7. **Error Handling - Hata Yakalama**: Temel hata yakalama (ES1'de sınırlı)
```javascript
// ES1'de try-catch yoktu, sadece temel hata kontrolü
function divide(a, b) {
    if (b === 0) {
        return "Error: Division by zero";
    }
    return a / b;
}

console.log(divide(10, 2)); // 5
console.log(divide(10, 0)); // "Error: Division by zero"
```

**ES1'in Sınırlamaları:**

1. **Sınırlı Array Metodları**: Sadece temel metodlar vardı
```javascript
var arr = [1, 2, 3];
// ES1'de mevcut olanlar
arr.push(4);    // [1, 2, 3, 4]
arr.pop();      // [1, 2, 3]
arr.length;     // 3

// ES1'de olmayanlar (ES3'te eklendi)
// arr.indexOf(), arr.forEach(), arr.map() vb.
```

2. **Sınırlı String Metodları**: Temel string işlemleri
```javascript
var str = "Hello World";
// ES1'de mevcut olanlar
str.length;           // 11
str.charAt(0);        // "H"
str.substring(0, 5);  // "Hello"

// ES1'de olmayanlar (ES3'te eklendi)
// str.indexOf(), str.split(), str.replace() vb.
```

3. **Sınırlı Object Metodları**: Temel object işlemleri
```javascript
var obj = { name: "John", age: 30 };
// ES1'de mevcut olanlar
obj.name;        // "John"
obj["age"];      // 30
obj.newProp = "value"; // Dinamik özellik ekleme

// ES1'de olmayanlar (ES5'te eklendi)
// Object.keys(), Object.values(), Object.defineProperty() vb.
```

**Neden Önemli?**

1. **Industry Standard - Endüstri Standardı**: JavaScript için ilk resmi standard
2. **Cross-browser Compatibility - Tarayıcılar Arası Uyumluluk**: Farklı tarayıcılarda tutarlı çalışma
3. **Foundation - Temel**: JavaScript'in gelişimi için sağlam temel
4. **Future Development - Gelecek Geliştirmeler**: Sonraki sürümler için zemin

**Ne İşe Yaradı?**

1. **Consistency - Tutarlılık**: Tüm tarayıcılarda aynı davranış
2. **Interoperability - Birlikte Çalışabilirlik**: Farklı sistemler arası uyumluluk
3. **Developer Confidence - Geliştirici Güveni**: Standart bir dil olduğu güveni
4. **Market Growth - Pazar Büyümesi**: JavaScript'in yaygınlaşması

**Browser Implementation - Tarayıcı Uygulamaları**:
- **Netscape Navigator 4.0**: İlk ES1 uygulaması
- **Internet Explorer 4.0**: Microsoft'un ES1 uygulaması
- **Uyumluluk Sorunları**: Hala bazı farklılıklar vardı

**ES1'in Etkisi:**

ES1, JavaScript'in "oyuncak dil" olmaktan çıkıp gerçek bir programlama dili olma yolundaki ilk adımıydı. Bu standardizasyon sayesinde:

- Geliştiriciler JavaScript'e güvenmeye başladı
- Web uygulamaları daha karmaşık hale geldi
- JavaScript kütüphaneleri geliştirilmeye başlandı
- Web'in interaktif hale gelmesi hızlandı

ES1, JavaScript'in modern web geliştirmenin temel taşı olmasının ilk adımıydı.

**1998 - ECMAScript 2 (ES2) - Düzeltme ve İyileştirme**:

ECMAScript 2, ES1'deki hataları düzelten ve uluslararası destek ekleyen bir güncellemedir. Bu sürüm, JavaScript'in global kullanımını artırmaya odaklandı.

**ECMAScript 2 Ne Demek?**

ECMAScript 2 (ES2), ES1'deki hataları düzelten ve uluslararasılaştırma desteği ekleyen bir güncellemedir. Bu sürüm, JavaScript'in dünya çapında kullanılabilir hale gelmesi için önemli adımlar attı.

**Ne Oldu?**
- **Haziran 1998**: ES1'deki küçük hataların düzeltilmesi
- **Editorial Changes**: Yazım hatalarının düzeltilmesi
- **Clarifications**: Belirsizliklerin giderilmesi
- **Consistency**: Tutarlılığın artırılması

**Temel Özellikler ve İyileştirmeler:**

1. **Unicode Support - Unicode Desteği**: Uluslararası karakter desteği eklendi
```javascript
// ES2 ile Unicode desteği geliştirildi
var turkishText = "Merhaba Dünya"; // Türkçe karakterler
var chineseText = "你好世界"; // Çin karakterleri
var arabicText = "مرحبا بالعالم"; // Arap karakterleri

// Unicode escape sequences
var unicodeChar = "\u0041"; // "A" karakteri
var emoji = "\u{1F600}"; // 😀 emoji (ES6'da tam destek)

// String length hesaplama (Unicode aware)
console.log(turkishText.length); // 13 (doğru hesaplama)
```

2. **String Improvements - String İyileştirmeleri**: String işlemleri iyileştirildi
```javascript
// ES2'de string işlemleri geliştirildi
var text = "Hello World";

// String concatenation iyileştirmeleri
var name = "John";
var greeting = "Hello, " + name + "!"; // "Hello, John!"

// String comparison iyileştirmeleri
var str1 = "apple";
var str2 = "banana";
console.log(str1 < str2); // true (lexicographic order)

// Unicode string handling
var mixedText = "Hello 世界"; // İngilizce + Çince
console.log(mixedText.length); // 8 (doğru hesaplama)
```

3. **Regular Expressions - Düzenli İfadeler**: Regex desteği geliştirildi
```javascript
// ES2'de regex desteği iyileştirildi (ES3'te tam destek geldi)
var text = "Hello World 123";

// Basit pattern matching (ES2'de sınırlı)
// ES3'te tam regex desteği geldi
var hasNumbers = /\d/.test(text); // true (ES3'te)
var hasLetters = /[a-zA-Z]/.test(text); // true (ES3'te)

// String search iyileştirmeleri
var position = text.indexOf("World"); // 6
var lastPosition = text.lastIndexOf("l"); // 9
```

4. **Error Handling - Hata İşleme**: Hata işleme mekanizmaları iyileştirildi
```javascript
// ES2'de hata işleme iyileştirildi (ES3'te try-catch geldi)
function safeDivide(a, b) {
    // ES2'de hala manuel hata kontrolü
    if (typeof a !== 'number' || typeof b !== 'number') {
        return "Error: Invalid input types";
    }
    
    if (b === 0) {
        return "Error: Division by zero";
    }
    
    return a / b;
}

// Hata türleri daha iyi tanımlandı
var result1 = safeDivide(10, 2); // 5
var result2 = safeDivide(10, 0); // "Error: Division by zero"
var result3 = safeDivide("10", 2); // "Error: Invalid input types"
```

**ES2'nin Önemli İyileştirmeleri:**

1. **Internationalization - Uluslararasılaştırma**:
```javascript
// ES2 ile uluslararası karakter desteği
var languages = {
    english: "Hello",
    turkish: "Merhaba",
    spanish: "Hola",
    french: "Bonjour",
    german: "Hallo"
};

// Unicode string işlemleri
function getGreeting(language) {
    return languages[language] || "Hello";
}

console.log(getGreeting("turkish")); // "Merhaba"
console.log(getGreeting("spanish")); // "Hola"
```

2. **String Processing - String İşleme**:
```javascript
// ES2'de string işleme iyileştirmeleri
var text = "JavaScript Programming";

// String manipulation
var upperText = text.toUpperCase(); // "JAVASCRIPT PROGRAMMING"
var lowerText = text.toLowerCase(); // "javascript programming"

// String slicing (ES2'de sınırlı)
var firstWord = text.substring(0, 10); // "JavaScript"
var secondWord = text.substring(11); // "Programming"
```

3. **Character Encoding - Karakter Kodlama**:
```javascript
// ES2'de karakter kodlama iyileştirmeleri
var text = "Café"; // é karakteri

// Character code operations
var firstChar = text.charCodeAt(0); // 67 (C)
var lastChar = text.charCodeAt(3); // 233 (é)

// String from character codes
var reconstructed = String.fromCharCode(67, 97, 102, 233); // "Café"
```

**ES2'nin Sınırlamaları:**

1. **Hala Sınırlı Regex Desteği**: Tam regex desteği ES3'te geldi
```javascript
// ES2'de regex sınırlıydı
var text = "Hello World";

// ES2'de bu çalışmazdı (ES3'te geldi)
// var matches = text.match(/World/);
// var replaced = text.replace(/World/, "Universe");

// ES2'de sadece basit string işlemleri
var index = text.indexOf("World"); // 6
```

2. **Hala Try-Catch Yok**: Hata yakalama ES3'te geldi
```javascript
// ES2'de try-catch yoktu
function riskyOperation() {
    // ES2'de hata yakalama manuel
    if (someCondition) {
        return "Error occurred";
    }
    return "Success";
}

// ES3'te try-catch geldi
// try {
//     riskyOperation();
// } catch (error) {
//     console.log("Caught error:", error);
// }
```

**Neden Önemli?**

1. **International Support - Uluslararası Destek**: JavaScript'in global kullanımı
2. **Bug Fixes - Hata Düzeltmeleri**: ES1'deki sorunların giderilmesi
3. **Stability - Kararlılık**: Daha güvenilir JavaScript
4. **Global Adoption - Küresel Benimsenme**: Dünya çapında kullanım

**Ne İşe Yaradı?**

1. **Better Internationalization - Daha İyi Uluslararasılaştırma**: Çok dilli web uygulamaları
2. **Improved Reliability - Gelişmiş Güvenilirlik**: Daha az hata, daha tutarlı davranış
3. **Enhanced String Processing - Gelişmiş String İşleme**: Unicode string işlemleri
4. **Foundation for ES3 - ES3 İçin Temel**: Sonraki büyük güncelleme için zemin

**ES2'nin Etkisi:**

ES2, JavaScript'in uluslararası bir dil olma yolundaki önemli adımdı:

- Unicode desteği ile çok dilli web uygulamaları mümkün oldu
- String işlemleri daha güvenilir hale geldi
- Hata işleme mekanizmaları iyileştirildi
- JavaScript'in global kullanımı arttı

ES2, ES1'den ES3'e geçişteki köprü görevi gördü ve JavaScript'in dünya çapında kabul görmesini sağladı.

**1999 - ECMAScript 3 (ES3) - Büyük Gelişim**:

ECMAScript 3, JavaScript'in ilk büyük güncellemesidir. Bu sürüm, modern JavaScript'in temelini oluşturan birçok önemli özellik eklemiştir.

**ECMAScript 3 Ne Demek?**

ECMAScript 3 (ES3), JavaScript'in gerçek anlamda modern bir programlama dili haline geldiği sürümdür. Bu sürümle birlikte JavaScript, karmaşık web uygulamaları geliştirmek için gerekli tüm araçlara sahip oldu.

**Ne Oldu?**
- **Aralık 1999**: JavaScript'in en önemli güncellemelerinden biri yayınlandı
- **Major Features**: Büyük özellik eklemeleri
- **Foundation**: Modern JavaScript'in temeli
- **Long-term Impact**: Uzun vadeli etki

**Temel Özellikler ve Örnekler:**

1. **Regular Expressions - Düzenli İfadeler**: Tam regex desteği eklendi
```javascript
// ES3 ile tam regex desteği geldi
var text = "Hello World 123";

// Regex pattern matching
var pattern = /World/;
var matches = text.match(pattern); // ["World"]
var hasMatch = pattern.test(text); // true

// String replacement
var replaced = text.replace(/World/, "Universe"); // "Hello Universe 123"

// Global replacement
var allReplaced = text.replace(/l/g, "L"); // "HeLLo WorLd 123"

// Complex patterns
var emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
var isValidEmail = emailPattern.test("user@example.com"); // true
```

2. **Try-Catch-Finally - Gelişmiş Hata Yakalama**: Modern hata yönetimi
```javascript
// ES3 ile try-catch-finally geldi
function riskyOperation() {
    try {
        // Risky code
        var result = 10 / 0; // Infinity, hata değil
        throw new Error("Custom error");
    } catch (error) {
        console.log("Caught error:", error.message);
        return "Error occurred";
    } finally {
        console.log("This always runs");
    }
}

// Nested try-catch
function complexOperation() {
    try {
        try {
            throw new Error("Inner error");
        } catch (innerError) {
            console.log("Inner catch:", innerError.message);
            throw new Error("Outer error");
        }
    } catch (outerError) {
        console.log("Outer catch:", outerError.message);
    }
}
```

3. **Switch Statement - Switch-Case Yapısı**: Çoklu koşul kontrolü
```javascript
// ES3 ile switch statement geldi
function getDayName(dayNumber) {
    switch (dayNumber) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        case 4:
            return "Thursday";
        case 5:
            return "Friday";
        case 6:
            return "Saturday";
        case 7:
            return "Sunday";
        default:
            return "Invalid day";
    }
}

// Switch with fall-through
function getSeason(month) {
    switch (month) {
        case 12:
        case 1:
        case 2:
            return "Winter";
        case 3:
        case 4:
        case 5:
            return "Spring";
        case 6:
        case 7:
        case 8:
            return "Summer";
        case 9:
        case 10:
        case 11:
            return "Autumn";
        default:
            return "Invalid month";
    }
}
```

4. **Do-While Loop - Do-While Döngüsü**: En az bir kez çalışan döngü
```javascript
// ES3 ile do-while geldi
var count = 0;
do {
    console.log("Count:", count);
    count++;
} while (count < 3);

// Kullanıcı girişi kontrolü
function getUserInput() {
    var input;
    do {
        input = prompt("Enter a number between 1 and 10:");
    } while (input < 1 || input > 10);
    return input;
}
```

5. **String Methods - String Metodları**: Gelişmiş string işlemleri
```javascript
// ES3 ile string metodları geldi
var text = "Hello World JavaScript";

// String search methods
var index = text.indexOf("World"); // 6
var lastIndex = text.lastIndexOf("l"); // 9
var startsWith = text.indexOf("Hello") === 0; // true

// String manipulation
var substring = text.substring(6, 11); // "World"
var slice = text.slice(-10); // "JavaScript"
var charAt = text.charAt(0); // "H"

// String splitting and joining
var words = text.split(" "); // ["Hello", "World", "JavaScript"]
var joined = words.join("-"); // "Hello-World-JavaScript"

// String case conversion
var upper = text.toUpperCase(); // "HELLO WORLD JAVASCRIPT"
var lower = text.toLowerCase(); // "hello world javascript"
```

6. **Array Methods - Array Metodları**: Gelişmiş array işlemleri
```javascript
// ES3 ile array metodları geldi
var numbers = [1, 2, 3];

// Array manipulation
numbers.push(4); // [1, 2, 3, 4]
numbers.pop(); // [1, 2, 3]
numbers.unshift(0); // [0, 1, 2, 3]
numbers.shift(); // [1, 2, 3]

// Array joining
var joined = numbers.join(", "); // "1, 2, 3"

// Array slicing
var sliced = numbers.slice(1, 3); // [2, 3]

// Array reversing
var reversed = numbers.slice().reverse(); // [3, 2, 1]

// Array sorting
var unsorted = [3, 1, 4, 1, 5];
var sorted = unsorted.slice().sort(); // [1, 1, 3, 4, 5]
```

7. **Error Objects - Hata Nesneleri**: Standart hata türleri
```javascript
// ES3 ile error objects geldi
try {
    throw new Error("Something went wrong");
} catch (error) {
    console.log(error.name); // "Error"
    console.log(error.message); // "Something went wrong"
}

// Custom error types
function CustomError(message) {
    this.name = "CustomError";
    this.message = message;
}
CustomError.prototype = new Error();

try {
    throw new CustomError("Custom error occurred");
} catch (error) {
    if (error instanceof CustomError) {
        console.log("Custom error:", error.message);
    }
}
```

8. **Function.prototype.call/apply - Fonksiyon Çağırma Metodları**: Dinamik fonksiyon çağırma
```javascript
// ES3 ile call/apply geldi
var person = {
    name: "John",
    greet: function(greeting) {
        return greeting + ", I'm " + this.name;
    }
};

var anotherPerson = { name: "Jane" };

// Using call
var result1 = person.greet.call(anotherPerson, "Hello"); // "Hello, I'm Jane"

// Using apply
var result2 = person.greet.apply(anotherPerson, ["Hi"]); // "Hi, I'm Jane"

// Practical example
function calculateTotal() {
    var sum = 0;
    for (var i = 0; i < arguments.length; i++) {
        sum += arguments[i];
    }
    return sum;
}

var numbers = [1, 2, 3, 4, 5];
var total = calculateTotal.apply(null, numbers); // 15
```

**ES3'in Önemli İyileştirmeleri:**

1. **Modern Error Handling - Modern Hata Yönetimi**:
```javascript
// ES3 ile hata yönetimi modernleşti
function processData(data) {
    try {
        if (!data) {
            throw new Error("Data is required");
        }
        
        if (typeof data !== 'string') {
            throw new TypeError("Data must be a string");
        }
        
        return data.toUpperCase();
    } catch (error) {
        console.error("Processing failed:", error.message);
        return null;
    } finally {
        console.log("Processing completed");
    }
}
```

2. **Advanced String Processing - Gelişmiş String İşleme**:
```javascript
// ES3 ile string işleme güçlendi
function formatText(text) {
    // Remove extra spaces
    var cleaned = text.replace(/\s+/g, ' ');
    
    // Capitalize first letter of each word
    var words = cleaned.split(' ');
    var capitalized = words.map(function(word) {
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    });
    
    return capitalized.join(' ');
}

console.log(formatText("hello world javascript")); // "Hello World Javascript"
```

3. **Array Processing - Array İşleme**:
```javascript
// ES3 ile array işleme gelişti
function processArray(arr) {
    var result = [];
    
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) {
            result.push(arr[i] * 2);
        }
    }
    
    return result;
}

var numbers = [1, 2, 3, 4, 5, 6];
var processed = processArray(numbers); // [4, 8, 12]
```

**ES3'in Sınırlamaları:**

1. **Hala Sınırlı Array Methods**: Modern array methods ES5'te geldi
```javascript
// ES3'te bu metodlar yoktu (ES5'te geldi)
var arr = [1, 2, 3, 4, 5];

// ES3'te olmayanlar
// arr.forEach(), arr.map(), arr.filter(), arr.reduce() vb.

// ES3'te manuel döngüler kullanılıyordu
var doubled = [];
for (var i = 0; i < arr.length; i++) {
    doubled.push(arr[i] * 2);
}
```

2. **Hala Sınırlı Object Methods**: Modern object methods ES5'te geldi
```javascript
// ES3'te bu metodlar yoktu (ES5'te geldi)
var obj = { a: 1, b: 2, c: 3 };

// ES3'te olmayanlar
// Object.keys(), Object.values(), Object.defineProperty() vb.

// ES3'te manuel döngüler kullanılıyordu
var keys = [];
for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
        keys.push(key);
    }
}
```

**Neden Önemli?**

1. **Modern JavaScript Foundation - Modern JavaScript Temeli**: ES3, modern JavaScript'in temelini attı
2. **Developer Productivity - Geliştirici Verimliliği**: Daha güçlü araçlar ve metodlar
3. **Error Handling - Hata İşleme**: Modern hata yönetimi mekanizmaları
4. **String/Array Processing - String/Array İşleme**: Gelişmiş veri işleme yetenekleri

**Ne İşe Yaradı?**

1. **Complex Applications - Karmaşık Uygulamalar**: Büyük web uygulamaları geliştirme
2. **Better Error Management - Daha İyi Hata Yönetimi**: Güvenilir hata yakalama
3. **Enhanced String Processing - Gelişmiş String İşleme**: Metin işleme yetenekleri
4. **Foundation for Libraries - Kütüphaneler İçin Temel**: jQuery, Prototype.js gibi kütüphaneler

**ES3'ün Etkisi:**

ES3, JavaScript'in gerçek anlamda modern bir programlama dili olmasını sağladı:

- 10 yıl boyunca JavaScript standardı olarak kaldı (2009'a kadar)
- Modern web uygulamalarının temelini attı
- JavaScript kütüphanelerinin gelişmesini sağladı
- Web 2.0'ın temel teknolojisi haline geldi

ES3, JavaScript'in "oyuncak dil" olmaktan çıkıp gerçek bir programlama dili olmasının en önemli adımıydı.

**2000-2008 - ECMAScript 4 (İptal Edildi)**:

ECMAScript 4, JavaScript'in en büyük krizlerinden biridir. Bu sürüm, JavaScript'i tamamen değiştirmeyi hedefliyordu ancak topluluk içindeki anlaşmazlıklar nedeniyle iptal edildi.

**ECMAScript 4 Ne Demek?**

ECMAScript 4 (ES4), JavaScript'i modern bir programlama dili haline getirmek için tasarlanmış radikal bir güncellemeydi. Bu sürüm, JavaScript'in temel yapısını değiştirmeyi ve Java/C# benzeri özellikler eklemeyi hedefliyordu.

**Ne Oldu?**
- **2000**: ES4 geliştirme süreci başladı
- **Radikal Değişiklikler**: Classes, packages, namespaces, optional static typing
- **Microsoft Karşıtlığı**: Microsoft, ES4'e karşı çıktı
- **2008**: ES4 iptal edildi, ES3.1 (sonra ES5) geliştirilmeye başlandı

**ES4'ün Planlanan Özellikleri:**

1. **Classes - Sınıflar**: Java/C# benzeri sınıf sistemi
```javascript
// ES4'te planlanan class syntax (iptal edildi)
class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return this.name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

// Inheritance
class Employee extends Person {
    private String department;
    
    public Employee(String name, int age, String department) {
        super(name, age);
        this.department = department;
    }
}
```

2. **Packages - Paketler**: Modüler kod organizasyonu
```javascript
// ES4'te planlanan package system (iptal edildi)
package com.example.utils {
    public class StringUtils {
        public static String capitalize(String str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
    }
}

// Import
import com.example.utils.StringUtils;
var result = StringUtils.capitalize("hello"); // "Hello"
```

3. **Namespaces - İsim Alanları**: Global namespace kirliliğini önleme
```javascript
// ES4'te planlanan namespace system (iptal edildi)
namespace MyApp {
    namespace Utils {
        function formatDate(date) {
            return date.toLocaleDateString();
        }
    }
    
    namespace UI {
        function showMessage(message) {
            alert(message);
        }
    }
}

// Usage
MyApp.Utils.formatDate(new Date());
MyApp.UI.showMessage("Hello");
```

4. **Optional Static Typing - İsteğe Bağlı Statik Tip Sistemi**: Tip güvenliği
```javascript
// ES4'te planlanan static typing (iptal edildi)
function calculateTotal(prices: Array<number>): number {
    var total: number = 0;
    for (var i: int = 0; i < prices.length; i++) {
        total += prices[i];
    }
    return total;
}

// Type annotations
var name: String = "John";
var age: int = 25;
var isActive: boolean = true;
```

5. **Interfaces - Arayüzler**: Kontrat tabanlı programlama
```javascript
// ES4'te planlanan interface system (iptal edildi)
interface Drawable {
    function draw(): void;
    function getArea(): number;
}

class Circle implements Drawable {
    private radius: number;
    
    public function draw(): void {
        console.log("Drawing circle");
    }
    
    public function getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}
```

6. **Generics - Generikler**: Tip güvenli koleksiyonlar
```javascript
// ES4'te planlanan generics (iptal edildi)
class Stack<T> {
    private items: Array<T> = [];
    
    public function push(item: T): void {
        this.items.push(item);
    }
    
    public function pop(): T {
        return this.items.pop();
    }
}

// Usage
var stringStack: Stack<String> = new Stack<String>();
stringStack.push("Hello");
var item: String = stringStack.pop();
```

**ES4'ün Neden İptal Edildi?**

1. **Microsoft'ın Karşıtlığı**: Microsoft, ES4'ün çok radikal olduğunu düşünüyordu
```javascript
// Microsoft'un endişeleri:
// 1. Mevcut JavaScript kodlarının bozulması
// 2. Öğrenme eğrisinin çok dik olması
// 3. Tarayıcı uyumluluğu sorunları
// 4. Geliştirici topluluğunun bölünmesi
```

2. **Topluluk Bölünmesi**: JavaScript topluluğu ikiye bölündü
- **ES4 Destekçileri**: Mozilla, Adobe, Yahoo
- **ES4 Karşıtları**: Microsoft, Google

3. **Uyumluluk Endişeleri**: Mevcut kodların bozulma riski
```javascript
// ES4'ün mevcut kodu bozma riski
// ES3'te çalışan kod:
function add(a, b) {
    return a + b;
}

// ES4'te bu kod çalışmayabilirdi:
// function add(a: number, b: number): number {
//     return a + b;
// }
```

4. **Karmaşıklık**: ES4 çok karmaşık ve öğrenmesi zordu
```javascript
// ES4'ün karmaşıklığı
package com.example {
    namespace Utils {
        public class MathUtils<T extends Number> {
            public static function calculate<T>(values: Array<T>): T {
                // Complex generic implementation
            }
        }
    }
}
```

**ES4'ün Etkisi:**

1. **JavaScript'in Gelişimini Yavaşlattı**: 10 yıl boyunca ES3 kullanıldı
2. **Topluluk Bölünmesi**: JavaScript topluluğu ikiye bölündü
3. **Alternatif Çözümler**: TypeScript, CoffeeScript gibi diller ortaya çıktı
4. **ES5'e Yol Açtı**: ES4'ün iptali ES5'in geliştirilmesine yol açtı

**ES4'ten ES5'e Geçiş:**

ES4'ün iptal edilmesi sonrasında:
- **ES3.1** olarak başlayan proje
- **ES5** olarak yeniden adlandırıldı
- **Daha konservatif yaklaşım** benimsendi
- **Geriye uyumluluk** öncelikli hale geldi

**ES4'ün Mirası:**

ES4'ün iptal edilmesi, JavaScript ekosisteminde önemli değişikliklere yol açtı:

1. **TypeScript'in Doğuşu**: Microsoft, ES4'ün iptal edilmesi sonrasında TypeScript'i geliştirdi
2. **CoffeeScript**: ES4'ün alternatifi olarak CoffeeScript ortaya çıktı
3. **ES6'nın Temeli**: ES4'teki bazı fikirler ES6'da hayata geçirildi
4. **Topluluk Birliği**: JavaScript topluluğu daha birleşik hale geldi

**ES4'ün Öğrettikleri:**

1. **Geriye Uyumluluk Önemli**: Mevcut kodları bozmamak kritik
2. **Topluluk Konsensüsü**: Büyük değişiklikler için topluluk desteği gerekli
3. **Kademeli Gelişim**: Radikal değişiklikler yerine kademeli gelişim daha iyi
4. **Pratiklik**: Teorik mükemmellik yerine pratik çözümler önemli

ES4'ün iptal edilmesi, JavaScript'in gelişiminde önemli bir dönüm noktasıydı. Bu olay, JavaScript'in daha pragmatik ve topluluk odaklı bir şekilde gelişmesini sağladı.

**2009 - ECMAScript 5 (ES5) - Modern JavaScript'in Doğuşu**:

ECMAScript 5, JavaScript'in modern dönemini başlatan en önemli güncellemelerden biridir. Bu sürüm, JavaScript'i gerçek bir programlama dili haline getirmiştir.

**ECMAScript 5 Ne Demek?**

ECMAScript 5 (ES5), ES4'ün iptal edilmesi sonrasında geliştirilen konservatif bir güncellemedir. ES3'ten 10 yıl sonra gelen bu sürüm, JavaScript'i modern web geliştirme için gerekli araçlarla donattı.

**Ne Oldu?**
- **Aralık 2009**: ES5 yayınlandı (ES3'ten 10 yıl sonra)
- **Modern JavaScript**: Modern JavaScript'in temelini oluşturdu
- **Browser Support**: Tüm modern tarayıcılarda desteklendi
- **Industry Standard**: Endüstri standardı haline geldi

**Temel Özellikler ve Örnekler:**

1. **Strict Mode - Katı Mod**: JavaScript'in daha güvenli çalışması
```javascript
// Strict mode aktivasyonu
"use strict";

// Strict mode'da hatalar
function strictExample() {
    "use strict";
    
    // Hata: Undeclared variable
    // undeclaredVar = 10; // ReferenceError
    
    // Hata: Duplicate parameter names
    // function duplicateParams(a, a) { } // SyntaxError
    
    // Hata: Deleting variables
    var x = 1;
    // delete x; // SyntaxError
    
    // Hata: Octal literals
    // var octal = 010; // SyntaxError
    
    // Hata: with statement
    // with (obj) { } // SyntaxError
}

// Strict mode'un faydaları
function benefitsOfStrict() {
    "use strict";
    
    // 1. Daha iyi hata mesajları
    var obj = {};
    Object.defineProperty(obj, 'readOnly', {
        value: 42,
        writable: false
    });
    
    // obj.readOnly = 100; // TypeError: Cannot assign to read only property
    
    // 2. this binding
    function regularFunction() {
        console.log(this); // undefined (strict mode'da)
    }
    
    // 3. Arguments object
    function argumentsExample(a, b) {
        console.log(arguments.callee); // TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed
    }
}
```

2. **JSON Support - JSON Desteği**: Veri alışverişi standardı
```javascript
// JSON.parse() - String'den object'e
var jsonString = '{"name": "John", "age": 30, "city": "New York"}';
var person = JSON.parse(jsonString);
console.log(person.name); // "John"

// JSON.stringify() - Object'den string'e
var user = {
    name: "Jane",
    age: 25,
    hobbies: ["reading", "swimming"],
    address: {
        street: "123 Main St",
        city: "Boston"
    }
};

var jsonOutput = JSON.stringify(user);
console.log(jsonOutput); // '{"name":"Jane","age":25,"hobbies":["reading","swimming"],"address":{"street":"123 Main St","city":"Boston"}}'

// JSON with replacer function
var filteredJson = JSON.stringify(user, function(key, value) {
    if (key === 'age') return undefined; // Exclude age
    return value;
});
console.log(filteredJson); // '{"name":"Jane","hobbies":["reading","swimming"],"address":{"street":"123 Main St","city":"Boston"}}'

// JSON with space formatting
var prettyJson = JSON.stringify(user, null, 2);
console.log(prettyJson);
// {
//   "name": "Jane",
//   "age": 25,
//   "hobbies": ["reading", "swimming"],
//   "address": {
//     "street": "123 Main St",
//     "city": "Boston"
//   }
// }
```

3. **Array Methods - Dizi Metodları**: Fonksiyonel programlama desteği
```javascript
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// forEach - Her eleman için işlem
numbers.forEach(function(number, index) {
    console.log(`Index ${index}: ${number}`);
});

// map - Dönüştürme
var doubled = numbers.map(function(number) {
    return number * 2;
});
console.log(doubled); // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

// filter - Filtreleme
var evens = numbers.filter(function(number) {
    return number % 2 === 0;
});
console.log(evens); // [2, 4, 6, 8, 10]

// reduce - Azaltma
var sum = numbers.reduce(function(accumulator, current) {
    return accumulator + current;
}, 0);
console.log(sum); // 55

// reduce ile obje oluşturma
var grouped = numbers.reduce(function(acc, num) {
    var key = num % 2 === 0 ? 'even' : 'odd';
    acc[key].push(num);
    return acc;
}, { even: [], odd: [] });
console.log(grouped); // { even: [2, 4, 6, 8, 10], odd: [1, 3, 5, 7, 9] }

// some - Herhangi biri
var hasEven = numbers.some(function(number) {
    return number % 2 === 0;
});
console.log(hasEven); // true

// every - Hepsi
var allPositive = numbers.every(function(number) {
    return number > 0;
});
console.log(allPositive); // true

// indexOf - İlk indeks
var index = numbers.indexOf(5);
console.log(index); // 4

// lastIndexOf - Son indeks
var lastIndex = numbers.lastIndexOf(5);
console.log(lastIndex); // 4
```

4. **Object Methods - Nesne Metodları**: Gelişmiş nesne işlemleri
```javascript
var person = {
    name: "John",
    age: 30,
    city: "New York",
    occupation: "Developer"
};

// Object.keys() - Anahtar listesi
var keys = Object.keys(person);
console.log(keys); // ["name", "age", "city", "occupation"]

// Object.values() - Değer listesi (ES2017'de geldi, ama ES5'te manuel)
var values = Object.keys(person).map(function(key) {
    return person[key];
});
console.log(values); // ["John", 30, "New York", "Developer"]

// Object.create() - Prototip tabanlı nesne oluşturma
var animal = {
    makeSound: function() {
        return "Some sound";
    }
};

var dog = Object.create(animal);
dog.breed = "Labrador";
dog.makeSound = function() {
    return "Woof!";
};

console.log(dog.makeSound()); // "Woof!"
console.log(dog.breed); // "Labrador"

// Object.defineProperty() - Özellik tanımlama
var config = {};
Object.defineProperty(config, 'apiUrl', {
    value: 'https://api.example.com',
    writable: false,
    enumerable: true,
    configurable: false
});

Object.defineProperty(config, 'version', {
    get: function() {
        return '1.0.0';
    },
    enumerable: true,
    configurable: true
});

console.log(config.apiUrl); // "https://api.example.com"
console.log(config.version); // "1.0.0"
// config.apiUrl = "new url"; // TypeError (writable: false)
```

5. **Function.bind() - Fonksiyon Bağlama**: this bağlama kontrolü
```javascript
var person = {
    name: "John",
    greet: function(greeting) {
        return greeting + ", I'm " + this.name;
    }
};

var anotherPerson = { name: "Jane" };

// call() kullanımı
var result1 = person.greet.call(anotherPerson, "Hello");
console.log(result1); // "Hello, I'm Jane"

// apply() kullanımı
var result2 = person.greet.apply(anotherPerson, ["Hi"]);
console.log(result2); // "Hi, I'm Jane"

// bind() kullanımı
var boundGreet = person.greet.bind(anotherPerson);
var result3 = boundGreet("Hey");
console.log(result3); // "Hey, I'm Jane"

// Event handling ile bind
function Button() {
    this.clickCount = 0;
    this.handleClick = function() {
        this.clickCount++;
        console.log("Clicked " + this.clickCount + " times");
    };
}

var button = new Button();
// setTimeout(button.handleClick, 1000); // this undefined olur
setTimeout(button.handleClick.bind(button), 1000); // this doğru bağlanır
```

6. **Date Methods - Tarih Metodları**: Gelişmiş tarih işlemleri
```javascript
var now = new Date();

// ISO string formatı
var isoString = now.toISOString();
console.log(isoString); // "2023-12-07T10:30:00.000Z"

// JSON serialization
var dateObj = {
    name: "Event",
    date: new Date()
};

var json = JSON.stringify(dateObj);
console.log(json); // '{"name":"Event","date":"2023-12-07T10:30:00.000Z"}'

// Date parsing
var parsedDate = new Date("2023-12-07T10:30:00.000Z");
console.log(parsedDate.toLocaleDateString()); // "12/7/2023"
```

**ES5'in Önemli İyileştirmeleri:**

1. **Functional Programming Support - Fonksiyonel Programlama Desteği**:
```javascript
// ES5 ile fonksiyonel programlama güçlendi
var users = [
    { name: "John", age: 25, active: true },
    { name: "Jane", age: 30, active: false },
    { name: "Bob", age: 35, active: true },
    { name: "Alice", age: 28, active: true }
];

// Functional pipeline
var activeUserNames = users
    .filter(function(user) {
        return user.active;
    })
    .map(function(user) {
        return user.name.toUpperCase();
    })
    .sort();

console.log(activeUserNames); // ["ALICE", "BOB", "JOHN"]
```

2. **Better Error Handling - Daha İyi Hata Yönetimi**:
```javascript
// ES5 ile hata yönetimi gelişti
function processUserData(userData) {
    try {
        if (!userData) {
            throw new Error("User data is required");
        }
        
        var parsed = JSON.parse(userData);
        
        if (!parsed.name) {
            throw new Error("Name is required");
        }
        
        return {
            name: parsed.name,
            age: parsed.age || 0,
            isValid: true
        };
    } catch (error) {
        console.error("Processing failed:", error.message);
        return {
            name: null,
            age: 0,
            isValid: false,
            error: error.message
        };
    }
}
```

3. **Immutable Operations - Değişmez İşlemler**:
```javascript
// ES5 ile immutable operations
var originalArray = [1, 2, 3, 4, 5];

// Immutable transformations
var doubled = originalArray.map(function(x) { return x * 2; });
var filtered = originalArray.filter(function(x) { return x % 2 === 0; });

console.log(originalArray); // [1, 2, 3, 4, 5] (değişmedi)
console.log(doubled); // [2, 4, 6, 8, 10]
console.log(filtered); // [2, 4]
```

**ES5'in Sınırlamaları:**

1. **Hala Sınırlı Arrow Functions**: Arrow functions ES6'da geldi
```javascript
// ES5'te arrow functions yoktu
var numbers = [1, 2, 3, 4, 5];

// ES5'te function keyword gerekli
var doubled = numbers.map(function(x) {
    return x * 2;
});

// ES6'da arrow functions geldi
// var doubled = numbers.map(x => x * 2);
```

2. **Hala Sınırlı Template Literals**: Template literals ES6'da geldi
```javascript
// ES5'te string concatenation
var name = "John";
var age = 30;
var message = "Hello, my name is " + name + " and I am " + age + " years old";

// ES6'da template literals geldi
// var message = `Hello, my name is ${name} and I am ${age} years old`;
```

**Neden Önemli?**

1. **Modern JavaScript Foundation - Modern JavaScript Temeli**: ES5, modern JavaScript'in temelini attı
2. **Functional Programming - Fonksiyonel Programlama**: Array methods ile FP desteği
3. **Better Error Handling - Daha İyi Hata Yönetimi**: Strict mode ile güvenlik
4. **JSON Standardization - JSON Standardizasyonu**: Web API'leri için standart

**Ne İşe Yaradı?**

1. **Web 2.0 Applications - Web 2.0 Uygulamaları**: Modern web uygulamaları
2. **API Integration - API Entegrasyonu**: JSON ile veri alışverişi
3. **Functional Programming - Fonksiyonel Programlama**: Array methods ile FP
4. **Better Code Quality - Daha İyi Kod Kalitesi**: Strict mode ile güvenlik

**ES5'in Etkisi:**

ES5, JavaScript'in modern web geliştirmenin temel taşı olmasını sağladı:

- Modern web uygulamalarının temelini attı
- JSON standardizasyonu ile API entegrasyonunu kolaylaştırdı
- Fonksiyonel programlama desteği ile kod kalitesini artırdı
- Strict mode ile güvenli JavaScript yazımını sağladı

ES5, JavaScript'in "oyuncak dil" olmaktan çıkıp gerçek bir programlama dili olmasının en önemli adımlarından biriydi.

**JSON Support - JSON Desteği**

JSON (JavaScript Object Notation), veri alışverişi için standart format haline geldi.

**Ne Demek?**
- **JSON.parse()**: JSON string'i JavaScript objesine çevirir
- **JSON.stringify()**: JavaScript objesini JSON string'e çevirir
- **Data Exchange**: Veri alışverişi standardı
- **API Communication**: API iletişimi

**Neden İhtiyaç Var?**
- **Data Serialization**: Veri serileştirme
- **API Integration**: API entegrasyonu
- **Cross-platform**: Platformlar arası veri alışverişi
- **Web Services**: Web servisleri

**Ne İşe Yarar?**
- **REST APIs**: REST API'leri
- **Data Storage**: Veri saklama
- **Configuration**: Yapılandırma dosyaları
- **Interoperability**: Birlikte çalışabilirlik

**Array Methods - Dizi Metodları**

ES5, dizilerle çalışmayı kolaylaştıran birçok metod ekledi.

**forEach - Dizi Döngüsü**
- **Ne Demek?**: Dizinin her elemanı için fonksiyon çalıştırır
- **Neden İhtiyaç Var?**: for döngüsüne alternatif, daha okunabilir
- **Ne İşe Yarar?**: Dizi işleme, side effect'ler

**map - Dönüştürme**
- **Ne Demek?**: Diziyi dönüştürür, yeni dizi döndürür
- **Neden İhtiyaç Var?**: Fonksiyonel programlama, immutable operations
- **Ne İşe Yarar?**: Veri dönüştürme, format değiştirme

**filter - Filtreleme**
- **Ne Demek?**: Koşula uyan elemanları filtreler
- **Neden İhtiyaç Var?**: Veri filtreleme, arama
- **Ne İşe Yarar?**: Veri temizleme, arama sonuçları

**reduce - Azaltma**
- **Ne Demek?**: Diziyi tek değere indirger
- **Neden İhtiyaç Var?**: Toplama, sayma, gruplama
- **Ne İşe Yarar?**: Hesaplamalar, veri analizi

**Object Methods - Nesne Metodları**

ES5, nesnelerle çalışmayı kolaylaştıran metodlar ekledi.

**Object.keys() - Anahtar Listesi**
- **Ne Demek?**: Nesnenin anahtarlarını dizi olarak döndürür
- **Neden İhtiyaç Var?**: Nesne iterasyonu, dinamik işlemler
- **Ne İşe Yarar?**: Nesne analizi, dinamik programlama

**Object.create() - Nesne Oluşturma**
- **Ne Demek?**: Belirtilen prototipten nesne oluşturur
- **Neden İhtiyaç Var?**: Prototip tabanlı OOP, inheritance
- **Ne İşe Yarar?**: Nesne oluşturma, miras alma

**Object.defineProperty() - Özellik Tanımlama**
- **Ne Demek?**: Nesne özelliklerini detaylı tanımlar
- **Neden İhtiyaç Var?**: Property descriptors, getter/setter
- **Ne İşe Yarar?**: Encapsulation, computed properties

**Function.bind() - Fonksiyon Bağlama**

bind metodu, fonksiyonun this değerini sabitler.

**Ne Demek?**
- **this Binding**: this değerini sabitler
- **Partial Application**: Kısmi uygulama
- **Event Handlers**: Olay işleyicileri
- **Method Borrowing**: Metod ödünç alma

**Neden İhtiyaç Var?**
- **Context Preservation**: Bağlam koruma
- **Event Handling**: Olay işleme
- **Method Binding**: Metod bağlama
- **Functional Programming**: Fonksiyonel programlama

**Ne İşe Yarar?**
- **Event Listeners**: Olay dinleyicileri
- **Callback Functions**: Geri çağırma fonksiyonları
- **Method References**: Metod referansları
- **Partial Application**: Kısmi uygulama

**ES5'in Etkisi:**
- **Modern JavaScript**: Modern JavaScript'in temeli
- **Library Development**: Kütüphane geliştirme
- **Framework Foundation**: Framework temeli
- **Industry Adoption**: Endüstri benimsenmesi

**2015 - ECMAScript 6 (ES6/ES2015) - JavaScript Devrimi**:

ECMAScript 6, JavaScript'in en büyük güncellemesidir. Bu sürüm, JavaScript'i modern bir programlama dili haline getirmiş ve web geliştirmeyi kökten değiştirmiştir.

**ECMAScript 6 Ne Demek?**

ECMAScript 6 (ES6), aynı zamanda ES2015 olarak da bilinir. Bu sürüm, JavaScript'in modern programlama dilleri seviyesine çıkmasını sağlayan devrim niteliğinde bir güncellemedir. ES6, JavaScript'i sadece bir "scripting language" olmaktan çıkarıp gerçek bir "programming language" haline getirmiştir.

**Ne Oldu?**
- **Haziran 2015**: ES6 yayınlandı (ES5'ten 6 yıl sonra)
- **JavaScript Devrimi**: JavaScript'in en büyük güncellemesi
- **Modern JavaScript**: Modern JavaScript'in temelini attı
- **Framework Boom**: React, Vue, Angular gibi framework'lerin temelini attı

**Temel Özellikler ve Örnekler:**

1. **Arrow Functions - Ok Fonksiyonları**: Kısa ve temiz fonksiyon syntax'ı
```javascript
// ES5'te fonksiyon tanımlama
var multiply = function(a, b) {
    return a * b;
};

// ES6'da arrow functions
const multiply = (a, b) => a * b;

// Tek parametre için parantez opsiyonel
const square = x => x * x;

// Çok satırlı arrow function
const processData = (data) => {
    const processed = data.map(item => item * 2);
    return processed.filter(item => item > 10);
};

// this binding farkı
const obj = {
    name: "John",
    // ES5'te this problemi
    traditionalFunction: function() {
        setTimeout(function() {
            console.log(this.name); // undefined (this kaybolur)
        }, 1000);
    },
    // ES6'da this korunur
    arrowFunction: function() {
        setTimeout(() => {
            console.log(this.name); // "John" (this korunur)
        }, 1000);
    }
};
```

2. **Template Literals - Şablon Değişmezleri**: String interpolation
```javascript
// ES5'te string concatenation
var name = "John";
var age = 30;
var message = "Hello, my name is " + name + " and I am " + age + " years old";

// ES6'da template literals
const name = "John";
const age = 30;
const message = `Hello, my name is ${name} and I am ${age} years old`;

// Çok satırlı string'ler
const htmlTemplate = `
    <div class="user-card">
        <h2>${name}</h2>
        <p>Age: ${age}</p>
        <p>Status: ${age >= 18 ? 'Adult' : 'Minor'}</p>
    </div>
`;

// Expression'lar
const calculation = `The result is: ${5 + 3 * 2}`; // "The result is: 11"

// Function calls
const greeting = `Welcome, ${getName().toUpperCase()}!`;
```

3. **Destructuring - Yapısal Ayrıştırma**: Değerleri ayrıştırma
```javascript
// Array destructuring
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

// Object destructuring
const person = {
    name: "John",
    age: 30,
    city: "New York",
    occupation: "Developer"
};

const { name, age, ...otherInfo } = person;
console.log(name); // "John"
console.log(age); // 30
console.log(otherInfo); // { city: "New York", occupation: "Developer" }

// Rename variables
const { name: fullName, age: userAge } = person;
console.log(fullName); // "John"
console.log(userAge); // 30

// Default values
const { name, age, country = "USA" } = person;
console.log(country); // "USA"

// Function parameters
function greetUser({ name, age = 0 }) {
    return `Hello ${name}, you are ${age} years old`;
}

console.log(greetUser(person)); // "Hello John, you are 30 years old"
```

4. **Classes - Sınıflar**: Sınıf tabanlı OOP
```javascript
// ES5'te constructor function
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    return `Hello, I'm ${this.name}`;
};

// ES6'da classes
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    // Static method
    static createAdult(name) {
        return new Person(name, 18);
    }
    
    // Getter
    get info() {
        return `${this.name} is ${this.age} years old`;
    }
    
    // Setter
    set age(value) {
        if (value < 0) {
            throw new Error("Age cannot be negative");
        }
        this._age = value;
    }
    
    get age() {
        return this._age;
    }
}

// Inheritance
class Employee extends Person {
    constructor(name, age, department) {
        super(name, age); // Parent constructor
        this.department = department;
    }
    
    greet() {
        return `${super.greet()} and I work in ${this.department}`;
    }
}

const employee = new Employee("Jane", 25, "Engineering");
console.log(employee.greet()); // "Hello, I'm Jane and I work in Engineering"
```

5. **Modules - Modüller**: Import/Export sistemi
```javascript
// math.js - Export
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}

// Default export
export default class Calculator {
    static calculate(operation, a, b) {
        switch (operation) {
            case 'add': return add(a, b);
            case 'multiply': return multiply(a, b);
            default: throw new Error('Unknown operation');
        }
    }
}

// app.js - Import
import Calculator, { PI, add, multiply } from './math.js';

// Named imports
import { add as sum, multiply as product } from './math.js';

// Namespace import
import * as MathUtils from './math.js';

// Usage
console.log(PI); // 3.14159
console.log(add(5, 3)); // 8
console.log(Calculator.calculate('add', 5, 3)); // 8
```

6. **let and const - Yeni Değişken Tanımlama**: Block scope
```javascript
// var - Function scope (ES5)
function varExample() {
    if (true) {
        var x = 1;
    }
    console.log(x); // 1 (accessible)
}

// let - Block scope (ES6)
function letExample() {
    if (true) {
        let y = 1;
    }
    // console.log(y); // ReferenceError: y is not defined
}

// const - Block scope, immutable
const API_URL = "https://api.example.com";
// API_URL = "new url"; // TypeError: Assignment to constant variable

// const with objects
const person = { name: "John" };
person.name = "Jane"; // OK - object is mutable
// person = {}; // TypeError - cannot reassign

// Temporal Dead Zone
console.log(hoistedVar); // undefined
console.log(hoistedLet); // ReferenceError

var hoistedVar = "I'm hoisted";
let hoistedLet = "I'm not hoisted";
```

7. **Promises - Sözler**: Asenkron programlama
```javascript
// ES5'te callback hell
function fetchData(callback) {
    setTimeout(() => {
        callback(null, "Data received");
    }, 1000);
}

fetchData((error, data) => {
    if (error) {
        console.error(error);
    } else {
        console.log(data);
    }
});

// ES6'da Promises
function fetchDataPromise() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("Data received");
        }, 1000);
    });
}

fetchDataPromise()
    .then(data => {
        console.log(data);
        return "Processed: " + data;
    })
    .then(processedData => {
        console.log(processedData);
    })
    .catch(error => {
        console.error(error);
    });

// Promise.all - Multiple promises
const promise1 = fetchDataPromise();
const promise2 = fetchDataPromise();
const promise3 = fetchDataPromise();

Promise.all([promise1, promise2, promise3])
    .then(results => {
        console.log("All promises resolved:", results);
    })
    .catch(error => {
        console.error("One promise failed:", error);
    });
```

8. **Default Parameters - Varsayılan Parametreler**: Fonksiyon parametreleri
```javascript
// ES5'te default parameters
function greet(name) {
    name = name || "Guest";
    return "Hello, " + name;
}

// ES6'da default parameters
function greet(name = "Guest", greeting = "Hello") {
    return `${greeting}, ${name}`;
}

console.log(greet()); // "Hello, Guest"
console.log(greet("John")); // "Hello, John"
console.log(greet("John", "Hi")); // "Hi, John"

// Default parameters with expressions
function createUser(name, age = calculateDefaultAge()) {
    return { name, age };
}

function calculateDefaultAge() {
    return 18;
}

// Default parameters with destructuring
function processUser({ name, age = 0, city = "Unknown" } = {}) {
    return { name, age, city };
}

console.log(processUser()); // { name: undefined, age: 0, city: "Unknown" }
console.log(processUser({ name: "John" })); // { name: "John", age: 0, city: "Unknown" }
```

9. **Rest and Spread Operators - Dinlenme ve Yayma Operatörleri**
```javascript
// Rest operator - Function parameters
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Rest operator - Array destructuring
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

// Spread operator - Arrays
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Spread operator - Objects
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 };
console.log(merged); // { a: 1, b: 2, c: 3, d: 4 }

// Spread operator - Function calls
const numbers = [1, 2, 3, 4, 5];
console.log(Math.max(...numbers)); // 5
```

10. **Enhanced Object Literals - Gelişmiş Nesne Değişmezleri**
```javascript
// ES5'te object literals
var name = "John";
var age = 30;
var person = {
    name: name,
    age: age,
    greet: function() {
        return "Hello, " + this.name;
    }
};

// ES6'da enhanced object literals
const name = "John";
const age = 30;
const person = {
    name, // Shorthand property
    age,
    greet() { // Method shorthand
        return `Hello, ${this.name}`;
    },
    // Computed property names
    [`${name}Info`]: "User information",
    // Dynamic property names
    [Symbol.iterator]: function* () {
        yield this.name;
        yield this.age;
    }
};

console.log(person.name); // "John"
console.log(person.greet()); // "Hello, John"
console.log(person.JohnInfo); // "User information"
```

**ES6'ın Önemli İyileştirmeleri:**

1. **Modern Syntax - Modern Sözdizimi**:
```javascript
// ES6 ile modern JavaScript
const users = [
    { name: "John", age: 25, active: true },
    { name: "Jane", age: 30, active: false },
    { name: "Bob", age: 35, active: true }
];

// Modern array processing
const activeUsers = users
    .filter(user => user.active)
    .map(user => ({ ...user, status: 'active' }))
    .sort((a, b) => a.name.localeCompare(b.name));

console.log(activeUsers);
```

2. **Better Async Programming - Daha İyi Asenkron Programlama**:
```javascript
// ES6 ile Promise-based async programming
function fetchUserData(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => response.json())
        .then(user => {
            console.log(`User: ${user.name}`);
            return user;
        })
        .catch(error => {
            console.error('Error fetching user:', error);
            throw error;
        });
}

// Promise chaining
fetchUserData(1)
    .then(user => fetchUserData(user.friendId))
    .then(friend => console.log(`Friend: ${friend.name}`))
    .catch(error => console.error('Error:', error));
```

**ES6'ın Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES6 features require modern browsers
// Babel transpilation needed for older browsers

// ES6 code
const arrowFunction = () => "Hello";

// Transpiled to ES5
var arrowFunction = function arrowFunction() {
    return "Hello";
};
```

2. **Learning Curve - Öğrenme Eğrisi**: Yeni syntax'lar öğrenme gerektirir
```javascript
// ES6'da çok fazla yeni syntax
// Arrow functions, destructuring, classes, modules, etc.
// Geliştiriciler için öğrenme eğrisi
```

**Neden Önemli?**

1. **Modern JavaScript - Modern JavaScript**: JavaScript'i modern programlama dili yaptı
2. **Developer Experience - Geliştirici Deneyimi**: Daha iyi syntax ve araçlar
3. **Framework Foundation - Framework Temeli**: React, Vue, Angular'ın temeli
4. **Industry Standard - Endüstri Standardı**: Modern web geliştirmenin standardı

**Ne İşe Yaradı?**

1. **Modern Web Development - Modern Web Geliştirme**: Modern web uygulamaları
2. **Framework Ecosystem - Framework Ekosistemi**: React, Vue, Angular
3. **Better Code Quality - Daha İyi Kod Kalitesi**: Modern syntax ve patterns
4. **Developer Productivity - Geliştirici Verimliliği**: Daha hızlı geliştirme

**ES6'ın Etkisi:**

ES6, JavaScript'in modern web geliştirmenin temel taşı olmasını sağladı:

- Modern web uygulamalarının temelini attı
- React, Vue, Angular gibi framework'lerin doğuşunu sağladı
- JavaScript'i gerçek bir programlama dili haline getirdi
- Web geliştirmeyi kökten değiştirdi

ES6, JavaScript'in "scripting language" olmaktan çıkıp "programming language" olmasının en önemli adımıydı.

**2016 - ECMAScript 2016 (ES2016) - Küçük Ama Önemli Adımlar**:

ES2016, ES6'dan sonraki ilk yıllık güncellemedir. Bu sürüm, JavaScript'in yıllık güncelleme döngüsünün başlangıcını işaret eder.

**ECMAScript 2016 Ne Demek?**

ES2016, ES6'dan sonra gelen ilk yıllık güncellemedir. Bu sürüm, JavaScript'in artık yıllık olarak güncelleneceğini gösterir. ES6'da büyük değişiklikler yapıldıktan sonra, ES2016 daha küçük ama önemli iyileştirmeler getirdi.

**Ne Oldu?**
- **Haziran 2016**: ES2016 yayınlandı (ES6'dan 1 yıl sonra)
- **Yıllık Güncelleme**: Yıllık güncelleme döngüsünün başlangıcı
- **Küçük Adımlar**: Büyük değişiklikler yerine küçük iyileştirmeler
- **Stability Focus**: Kararlılık odaklı güncellemeler

**Temel Özellikler ve Örnekler:**

1. **Array.prototype.includes() - Dizi İçerik Kontrolü**: Dizide eleman arama
```javascript
// ES5'te indexOf kullanımı
var numbers = [1, 2, 3, 4, 5];
var hasThree = numbers.indexOf(3) !== -1;
console.log(hasThree); // true

// ES2016'da includes() metodu
const numbers = [1, 2, 3, 4, 5];
const hasThree = numbers.includes(3);
console.log(hasThree); // true

// NaN kontrolü - indexOf ile problem
var nanArray = [1, 2, NaN, 4];
var hasNaN = nanArray.indexOf(NaN) !== -1;
console.log(hasNaN); // false (yanlış!)

// includes() ile doğru kontrol
const nanArray = [1, 2, NaN, 4];
const hasNaN = nanArray.includes(NaN);
console.log(hasNaN); // true (doğru!)
```

2. **Exponentiation Operator (**) - Üs Alma Operatörü**: Matematiksel üs alma
```javascript
// ES5'te Math.pow() kullanımı
var result = Math.pow(2, 3);
console.log(result); // 8

// ES2016'da ** operatörü
const result = 2 ** 3;
console.log(result); // 8

// Assignment operator
let number = 2;
number **= 3; // number = number ** 3
console.log(number); // 8
```

**ES2016'ın Etkisi:**

ES2016, JavaScript'in yıllık güncelleme döngüsünün başlangıcını işaret eder:

- Yıllık güncelleme döngüsünün başlangıcı
- Küçük ama önemli iyileştirmeler
- Kararlılık odaklı gelişim
- Geliştirici deneyiminin iyileştirilmesi

ES2016, ES6'dan sonra JavaScript'in daha kontrollü ve kararlı bir şekilde gelişmesinin başlangıcıydı.

**2017 - ECMAScript 2017 (ES2017) - Asenkron Programlama Devrimi**:

ES2017, JavaScript'in asenkron programlama yeteneklerini büyük ölçüde geliştirdi. Bu sürüm, async/await ile birlikte JavaScript'i daha da güçlü hale getirdi.

**ECMAScript 2017 Ne Demek?**

ES2017, JavaScript'in asenkron programlama yeteneklerini devrim niteliğinde geliştirdi. async/await ile birlikte, JavaScript'te asenkron kod yazmak artık çok daha kolay ve okunabilir hale geldi.

**Ne Oldu?**
- **Haziran 2017**: ES2017 yayınlandı
- **Async/Await**: Asenkron programlama devrimi
- **Object Methods**: Nesne metodları iyileştirmeleri
- **String Methods**: String metodları iyileştirmeleri

**Temel Özellikler ve Örnekler:**

1. **async/await - Asenkron Programlama**: Promise'lerin daha kolay kullanımı
```javascript
// ES6'da Promise chains
function fetchUserData(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => response.json())
        .then(user => {
            console.log(`User: ${user.name}`);
            return user;
        })
        .catch(error => {
            console.error('Error:', error);
            throw error;
        });
}

// ES2017'de async/await
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const user = await response.json();
        console.log(`User: ${user.name}`);
        return user;
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

// Karmaşık asenkron işlemler
async function processUserData(userId) {
    try {
        const user = await fetchUserData(userId);
        const friends = await fetchUserFriends(user.id);
        const posts = await fetchUserPosts(user.id);
        
        return {
            ...user,
            friends,
            posts,
            totalFriends: friends.length,
            totalPosts: posts.length
        };
    } catch (error) {
        console.error('Processing failed:', error);
        throw error;
    }
}
```

2. **Object.values() ve Object.entries() - Nesne Değerleri ve Girişleri**: Nesne işlemleri
```javascript
const person = {
    name: "John",
    age: 30,
    city: "New York",
    occupation: "Developer"
};

// Object.values() - ES2017'de eklendi
const values = Object.values(person);
console.log(values); // ["John", 30, "New York", "Developer"]

// Object.entries() - ES2017'de eklendi
const entries = Object.entries(person);
console.log(entries); // [["name", "John"], ["age", 30], ["city", "New York"], ["occupation", "Developer"]]

// Object.entries() ile döngü
for (const [key, value] of Object.entries(person)) {
    console.log(`${key}: ${value}`);
}
```

3. **String.prototype.padStart() ve padEnd() - String Doldurma**: String formatlaması
```javascript
// padStart() - Başa karakter ekleme
const number = "5";
const paddedNumber = number.padStart(3, "0");
console.log(paddedNumber); // "005"

// padEnd() - Sona karakter ekleme
const text = "Hello";
const paddedText = text.padEnd(10, ".");
console.log(paddedText); // "Hello....."

// Pratik kullanım
const formatTime = (hours, minutes) => {
    return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
};

console.log(formatTime(9, 5)); // "09:05"
```

**ES2017'nin Etkisi:**

ES2017, JavaScript'in asenkron programlama yeteneklerini devrim niteliğinde geliştirdi:

- async/await ile asenkron kod yazmak çok kolaylaştı
- Object.values() ve Object.entries() ile nesne işlemleri gelişti
- String formatlaması daha kolay hale geldi
- Modern web uygulamalarının temelini attı

ES2017, JavaScript'in asenkron programlama yeteneklerini modern seviyeye çıkardı.

**2018 - ECMAScript 2018 (ES2018) - Asenkron İterasyon ve Rest/Spread Geliştirmeleri**:

ES2018, JavaScript'in asenkron programlama yeteneklerini daha da geliştirdi. Bu sürüm, async iterators, rest/spread operatörlerinin geliştirilmesi ve daha iyi hata yönetimi getirdi.

**ECMAScript 2018 Ne Demek?**

ES2018, JavaScript'in asenkron programlama yeteneklerini daha da geliştirdi. async iterators ile birlikte, JavaScript'te asenkron veri akışları çok daha kolay hale geldi. Ayrıca rest/spread operatörlerinin nesnelerde kullanımı da eklendi.

**Ne Oldu?**
- **Haziran 2018**: ES2018 yayınlandı
- **Async Iteration**: Asenkron iterasyon desteği
- **Rest/Spread for Objects**: Nesneler için rest/spread operatörleri
- **Promise.finally()**: Promise'ler için finally metodu
- **Regex Improvements**: Regular expression iyileştirmeleri

**Temel Özellikler ve Örnekler:**

1. **Async Iteration - Asenkron İterasyon**: Asenkron veri akışları
```javascript
// Async generator function
async function* asyncGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

// Async iteration
async function processAsyncData() {
    for await (const value of asyncGenerator()) {
        console.log(value); // 1, 2, 3
    }
}

// Async iteration with API calls
async function* fetchUsers() {
    const userIds = [1, 2, 3, 4, 5];
    
    for (const id of userIds) {
        try {
            const response = await fetch(`/api/users/${id}`);
            const user = await response.json();
            yield user;
        } catch (error) {
            console.error(`Failed to fetch user ${id}:`, error);
        }
    }
}

// Process users as they come
async function processUsers() {
    for await (const user of fetchUsers()) {
        console.log(`Processing user: ${user.name}`);
        // Process each user as it arrives
    }
}
```

2. **Rest/Spread for Objects - Nesneler için Rest/Spread**: Nesne işlemleri
```javascript
// Rest operator for objects
const person = {
    name: "John",
    age: 30,
    city: "New York",
    occupation: "Developer",
    country: "USA"
};

const { name, age, ...rest } = person;
console.log(name); // "John"
console.log(age); // 30
console.log(rest); // { city: "New York", occupation: "Developer", country: "USA" }

// Spread operator for objects
const user = { name: "Jane", age: 25 };
const address = { city: "Boston", state: "MA" };
const contact = { email: "jane@example.com", phone: "555-1234" };

const completeUser = { ...user, ...address, ...contact };
console.log(completeUser);
// { name: "Jane", age: 25, city: "Boston", state: "MA", email: "jane@example.com", phone: "555-1234" }

// Object merging with spread
const defaultConfig = { theme: "light", language: "en", notifications: true };
const userConfig = { theme: "dark", notifications: false };
const finalConfig = { ...defaultConfig, ...userConfig };
console.log(finalConfig); // { theme: "dark", language: "en", notifications: false }
```

3. **Promise.finally() - Promise Sonlandırma**: Promise'ler için finally metodu
```javascript
// Promise.finally() - ES2018'de eklendi
function fetchData() {
    return fetch('/api/data')
        .then(response => response.json())
        .then(data => {
            console.log('Data received:', data);
            return data;
        })
        .catch(error => {
            console.error('Error:', error);
            throw error;
        })
        .finally(() => {
            console.log('Request completed (success or failure)');
            // Cleanup code here
        });
}

// Async/await with finally
async function processData() {
    try {
        const data = await fetchData();
        return data;
    } catch (error) {
        console.error('Processing failed:', error);
        throw error;
    } finally {
        console.log('Processing completed');
        // Cleanup code here
    }
}
```

4. **Regex Improvements - Regular Expression İyileştirmeleri**: Daha güçlü regex
```javascript
// Named capture groups
const text = "John Doe, 30 years old";
const regex = /(?<name>\w+ \w+), (?<age>\d+) years old/;
const match = text.match(regex);

console.log(match.groups.name); // "John Doe"
console.log(match.groups.age); // "30"

// Lookbehind assertions
const password = "password123";
const strongPasswordRegex = /(?<=\w{8,})(?=.*[A-Z])(?=.*[a-z])(?=.*\d)/;
const isStrong = strongPasswordRegex.test(password);

// Unicode property escapes
const unicodeRegex = /\p{Script=Latin}/u;
const hasLatin = unicodeRegex.test("Hello"); // true
```

**ES2018'in Önemli İyileştirmeleri:**

1. **Better Async Data Handling - Daha İyi Asenkron Veri İşleme**:
```javascript
// Async iteration with error handling
async function* fetchDataWithRetry(urls) {
    for (const url of urls) {
        let retries = 3;
        while (retries > 0) {
            try {
                const response = await fetch(url);
                const data = await response.json();
                yield data;
                break;
            } catch (error) {
                retries--;
                if (retries === 0) {
                    console.error(`Failed to fetch ${url} after 3 retries`);
                } else {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }
    }
}
```

2. **Enhanced Object Operations - Gelişmiş Nesne İşlemleri**:
```javascript
// Object merging with conditional properties
const createUser = (userData, options = {}) => {
    const defaultOptions = {
        isActive: true,
        role: 'user',
        permissions: []
    };
    
    return {
        ...defaultOptions,
        ...options,
        ...userData,
        createdAt: new Date().toISOString()
    };
};

const user = createUser(
    { name: "John", email: "john@example.com" },
    { role: "admin", permissions: ["read", "write"] }
);
```

**ES2018'in Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES2018 özellikleri için modern tarayıcı gerekli
// async iteration ve object rest/spread için polyfill gerekebilir
```

2. **Complexity - Karmaşıklık**: Async iteration yeni bir paradigm
```javascript
// async iteration yeni bir düşünce şekli gerektirir
// Generator functions ile birlikte kullanım karmaşık olabilir
```

**Neden Önemli?**

1. **Async Data Streams - Asenkron Veri Akışları**: async iteration ile asenkron veri akışları
2. **Better Object Operations - Daha İyi Nesne İşlemleri**: rest/spread operatörleri ile nesne işlemleri
3. **Promise Cleanup - Promise Temizleme**: finally() metodu ile temizlik işlemleri
4. **Enhanced Regex - Gelişmiş Regex**: Daha güçlü regular expression desteği

**Ne İşe Yaradı?**

1. **Streaming Data - Veri Akışı**: Asenkron veri akışları
2. **Object Manipulation - Nesne Manipülasyonu**: Daha kolay nesne işlemleri
3. **Error Handling - Hata Yönetimi**: Daha iyi hata yönetimi
4. **Text Processing - Metin İşleme**: Daha güçlü regex desteği

**ES2018'in Etkisi:**

ES2018, JavaScript'in asenkron programlama yeteneklerini daha da geliştirdi:

- async iteration ile asenkron veri akışları
- rest/spread operatörleri ile nesne işlemleri
- Promise.finally() ile temizlik işlemleri
- Daha güçlü regex desteği

ES2018, JavaScript'in asenkron programlama yeteneklerini daha da güçlendirdi.

**2019 - ECMAScript 2019 (ES2019) - Array ve Object İyileştirmeleri**:

ES2019, JavaScript'in array ve object işlemlerini daha da geliştirdi. Bu sürüm, Array.flat(), Array.flatMap(), Object.fromEntries() gibi önemli metodlar ekledi.

**ECMAScript 2019 Ne Demek?**

ES2019, JavaScript'in array ve object işlemlerini daha da geliştirdi. Array.flat() ve Array.flatMap() ile dizi işlemleri çok daha kolay hale geldi. Object.fromEntries() ile de nesne dönüştürme işlemleri gelişti.

**Ne Oldu?**
- **Haziran 2019**: ES2019 yayınlandı
- **Array.flat()**: Dizi düzleştirme
- **Array.flatMap()**: Dizi düzleştirme ve dönüştürme
- **Object.fromEntries()**: Nesne oluşturma
- **String.trimStart()/trimEnd()**: String temizleme
- **Optional Catch Binding**: Opsiyonel catch binding

**Temel Özellikler ve Örnekler:**

1. **Array.flat() - Dizi Düzleştirme**: İç içe dizileri düzleştirme
```javascript
// ES2019'da Array.flat()
const nestedArray = [1, 2, [3, 4], [5, [6, 7]]];
const flattened = nestedArray.flat();
console.log(flattened); // [1, 2, 3, 4, 5, [6, 7]]

// Derinlik belirtme
const deeplyNested = [1, [2, [3, [4, [5]]]]];
const flattened2 = deeplyNested.flat(3);
console.log(flattened2); // [1, 2, 3, 4, [5]]

// Tüm seviyeleri düzleştirme
const allFlattened = deeplyNested.flat(Infinity);
console.log(allFlattened); // [1, 2, 3, 4, 5]

// Pratik kullanım
const data = [
    { name: "John", hobbies: ["reading", "swimming"] },
    { name: "Jane", hobbies: ["cooking", "gardening"] },
    { name: "Bob", hobbies: ["gaming", "coding"] }
];

const allHobbies = data
    .map(person => person.hobbies)
    .flat();
console.log(allHobbies); // ["reading", "swimming", "cooking", "gardening", "gaming", "coding"]
```

2. **Array.flatMap() - Dizi Düzleştirme ve Dönüştürme**: Tek seferde dönüştürme ve düzleştirme
```javascript
// ES2019'da Array.flatMap()
const numbers = [1, 2, 3, 4];
const doubled = numbers.flatMap(x => [x, x * 2]);
console.log(doubled); // [1, 2, 2, 4, 3, 6, 4, 8]

// map() + flat() yerine flatMap()
const sentences = ["Hello world", "How are you", "I am fine"];
const words = sentences.flatMap(sentence => sentence.split(" "));
console.log(words); // ["Hello", "world", "How", "are", "you", "I", "am", "fine"]

// Pratik kullanım
const users = [
    { name: "John", tags: ["developer", "javascript"] },
    { name: "Jane", tags: ["designer", "css"] },
    { name: "Bob", tags: ["developer", "python"] }
];

const allTags = users.flatMap(user => user.tags);
console.log(allTags); // ["developer", "javascript", "designer", "css", "developer", "python"]

// Unique tags
const uniqueTags = [...new Set(users.flatMap(user => user.tags))];
console.log(uniqueTags); // ["developer", "javascript", "designer", "css", "python"]
```

3. **Object.fromEntries() - Nesne Oluşturma**: Array'den nesne oluşturma
```javascript
// ES2019'da Object.fromEntries()
const entries = [["name", "John"], ["age", 30], ["city", "New York"]];
const person = Object.fromEntries(entries);
console.log(person); // { name: "John", age: 30, city: "New York" }

// Object.entries() ile birlikte kullanım
const originalObj = { a: 1, b: 2, c: 3 };
const transformed = Object.fromEntries(
    Object.entries(originalObj).map(([key, value]) => [key, value * 2])
);
console.log(transformed); // { a: 2, b: 4, c: 6 }

// Map'ten Object'e dönüştürme
const map = new Map([
    ["name", "John"],
    ["age", 30],
    ["city", "New York"]
]);
const objFromMap = Object.fromEntries(map);
console.log(objFromMap); // { name: "John", age: 30, city: "New York" }

// Pratik kullanım
const formData = new FormData();
formData.append("name", "John");
formData.append("email", "john@example.com");
formData.append("age", "30");

const userData = Object.fromEntries(formData);
console.log(userData); // { name: "John", email: "john@example.com", age: "30" }
```

4. **String.trimStart() ve trimEnd() - String Temizleme**: String başı ve sonu temizleme
```javascript
// ES2019'da String.trimStart() ve trimEnd()
const text = "   Hello World   ";
const trimmedStart = text.trimStart();
console.log(trimmedStart); // "Hello World   "

const trimmedEnd = text.trimEnd();
console.log(trimmedEnd); // "   Hello World"

const trimmedBoth = text.trimStart().trimEnd();
console.log(trimmedBoth); // "Hello World"

// Pratik kullanım
const userInput = "  john@example.com  ";
const cleanEmail = userInput.trimStart().trimEnd();
console.log(cleanEmail); // "john@example.com"

// Template literals ile
const multilineText = `
    This is a multiline
    text with indentation
`;
const cleanText = multilineText.trimStart();
console.log(cleanText); // "This is a multiline\ntext with indentation"
```

5. **Optional Catch Binding - Opsiyonel Catch Binding**: Catch'te error parametresi opsiyonel
```javascript
// ES2019'da optional catch binding
try {
    // Risky operation
    JSON.parse(invalidJson);
} catch {
    // Error parameter is optional
    console.log("Invalid JSON provided");
}

// ES5/ES6'da error parameter gerekli
try {
    JSON.parse(invalidJson);
} catch (error) {
    console.log("Invalid JSON provided");
}

// Pratik kullanım
async function fetchData(url) {
    try {
        const response = await fetch(url);
        return await response.json();
    } catch {
        // Error details not needed
        return { error: "Failed to fetch data" };
    }
}
```

**ES2019'un Önemli İyileştirmeleri:**

1. **Better Array Operations - Daha İyi Dizi İşlemleri**:
```javascript
// ES2019 ile daha güçlü dizi işlemleri
const processNestedData = (data) => {
    return data
        .flatMap(item => item.items || [])
        .filter(item => item.active)
        .map(item => ({ ...item, processed: true }));
};

const nestedData = [
    { name: "Group 1", items: [{ id: 1, active: true }, { id: 2, active: false }] },
    { name: "Group 2", items: [{ id: 3, active: true }, { id: 4, active: true }] },
    { name: "Group 3", items: [] }
];

const processedData = processNestedData(nestedData);
console.log(processedData); // [{ id: 1, active: true, processed: true }, { id: 3, active: true, processed: true }, { id: 4, active: true, processed: true }]
```

2. **Enhanced Object Operations - Gelişmiş Nesne İşlemleri**:
```javascript
// ES2019 ile daha kolay nesne dönüştürme
const transformUserData = (users) => {
    return Object.fromEntries(
        users.map(user => [
            user.id,
            {
                name: user.name,
                email: user.email,
                isActive: user.status === 'active'
            }
        ])
    );
};

const users = [
    { id: 1, name: "John", email: "john@example.com", status: "active" },
    { id: 2, name: "Jane", email: "jane@example.com", status: "inactive" },
    { id: 3, name: "Bob", email: "bob@example.com", status: "active" }
];

const userMap = transformUserData(users);
console.log(userMap);
// {
//   1: { name: "John", email: "john@example.com", isActive: true },
//   2: { name: "Jane", email: "jane@example.com", isActive: false },
//   3: { name: "Bob", email: "bob@example.com", isActive: true }
// }
```

**ES2019'un Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES2019 özellikleri için modern tarayıcı gerekli
// Array.flat(), Object.fromEntries() için polyfill gerekebilir
```

2. **Performance - Performans**: flat() ve flatMap() büyük dizilerde yavaş olabilir
```javascript
// Büyük dizilerde flat() ve flatMap() performans sorunu yaratabilir
// Dikkatli kullanım gerekli
```

**Neden Önemli?**

1. **Array Processing - Dizi İşleme**: Array.flat() ve flatMap() ile dizi işlemleri
2. **Object Transformation - Nesne Dönüştürme**: Object.fromEntries() ile nesne dönüştürme
3. **String Handling - String İşleme**: trimStart() ve trimEnd() ile string temizleme
4. **Error Handling - Hata Yönetimi**: Optional catch binding ile hata yönetimi

**Ne İşe Yaradı?**

1. **Data Processing - Veri İşleme**: Daha kolay veri işleme
2. **Object Manipulation - Nesne Manipülasyonu**: Daha kolay nesne dönüştürme
3. **String Processing - String İşleme**: Daha kolay string temizleme
4. **Code Simplification - Kod Basitleştirme**: Daha basit kod yazımı

**ES2019'un Etkisi:**

ES2019, JavaScript'in array ve object işlemlerini daha da geliştirdi:

- Array.flat() ve flatMap() ile dizi işlemleri
- Object.fromEntries() ile nesne dönüştürme
- String.trimStart() ve trimEnd() ile string temizleme
- Optional catch binding ile hata yönetimi

ES2019, JavaScript'in veri işleme yeteneklerini daha da güçlendirdi.

**2020 - ECMAScript 2020 (ES2020) - Modern JavaScript'in Yeni Seviyesi**:

ES2020, JavaScript'in modern programlama dilleri seviyesine çıkmasını sağlayan önemli bir güncellemedir. Bu sürüm, BigInt, Optional Chaining, Nullish Coalescing gibi önemli özellikler getirdi.

**ECMAScript 2020 Ne Demek?**

ES2020, JavaScript'in modern programlama dilleri seviyesine çıkmasını sağlayan önemli bir güncellemedir. BigInt ile büyük sayılar, Optional Chaining ile güvenli property erişimi, Nullish Coalescing ile daha iyi default değer yönetimi gibi özellikler eklendi.

**Ne Oldu?**
- **Haziran 2020**: ES2020 yayınlandı
- **BigInt**: Büyük sayılar için destek
- **Optional Chaining**: Güvenli property erişimi
- **Nullish Coalescing**: Daha iyi default değer yönetimi
- **Dynamic Import**: Dinamik modül yükleme
- **globalThis**: Global obje erişimi

**Temel Özellikler ve Örnekler:**

1. **BigInt - Büyük Sayılar**: 64-bit integer sınırını aşan sayılar
```javascript
// ES2020'de BigInt
const bigNumber = 9007199254740991n; // n suffix ile BigInt
const anotherBig = BigInt("9007199254740991"); // BigInt constructor ile

console.log(bigNumber); // 9007199254740991n
console.log(typeof bigNumber); // "bigint"

// BigInt işlemleri
const sum = bigNumber + anotherBig;
console.log(sum); // 18014398509481982n

// Karşılaştırma
const isEqual = bigNumber === anotherBig;
console.log(isEqual); // true

// Pratik kullanım - Fibonacci hesaplama
function fibonacci(n) {
    if (n <= 1) return BigInt(n);
    
    let a = 0n, b = 1n;
    for (let i = 2; i <= n; i++) {
        [a, b] = [b, a + b];
    }
    return b;
}

console.log(fibonacci(100)); // 354224848179261915075n
```

2. **Optional Chaining (?.) - Opsiyonel Zincirleme**: Güvenli property erişimi
```javascript
// ES2020'de Optional Chaining
const user = {
    name: "John",
    address: {
        street: "123 Main St",
        city: "New York"
    }
};

// Güvenli property erişimi
const street = user?.address?.street;
console.log(street); // "123 Main St"

// Undefined property'ye güvenli erişim
const country = user?.address?.country;
console.log(country); // undefined (hata vermez)

// Method çağrıları
const result = user?.getName?.();
console.log(result); // undefined (method yoksa hata vermez)

// Array erişimi
const users = [
    { name: "John", hobbies: ["reading", "swimming"] },
    { name: "Jane", hobbies: null }
];

const firstHobby = users?.[0]?.hobbies?.[0];
console.log(firstHobby); // "reading"

const secondHobby = users?.[1]?.hobbies?.[0];
console.log(secondHobby); // undefined (hata vermez)

// Pratik kullanım
function getUserDisplayName(user) {
    return user?.profile?.displayName ?? user?.name ?? "Anonymous";
}

const user1 = { name: "John" };
const user2 = { profile: { displayName: "Johnny" } };
const user3 = null;

console.log(getUserDisplayName(user1)); // "John"
console.log(getUserDisplayName(user2)); // "Johnny"
console.log(getUserDisplayName(user3)); // "Anonymous"
```

3. **Nullish Coalescing (??) - Nullish Birleştirme**: Daha iyi default değer yönetimi
```javascript
// ES2020'de Nullish Coalescing
const config = {
    theme: null,
    language: "",
    notifications: false,
    timeout: 0
};

// || operatörü ile problem
const theme1 = config.theme || "light"; // "light" (null için)
const language1 = config.language || "en"; // "en" ("" için - yanlış!)
const notifications1 = config.notifications || true; // true (false için - yanlış!)
const timeout1 = config.timeout || 5000; // 5000 (0 için - yanlış!)

// ?? operatörü ile doğru çözüm
const theme2 = config.theme ?? "light"; // "light" (null için)
const language2 = config.language ?? "en"; // "" ("" için - doğru!)
const notifications2 = config.notifications ?? true; // false (false için - doğru!)
const timeout2 = config.timeout ?? 5000; // 0 (0 için - doğru!)

// Pratik kullanım
function createUser(userData) {
    return {
        name: userData.name ?? "Anonymous",
        age: userData.age ?? 0,
        isActive: userData.isActive ?? true,
        preferences: userData.preferences ?? {}
    };
}

const user = createUser({ name: "John", age: 0, isActive: false });
console.log(user); // { name: "John", age: 0, isActive: false, preferences: {} }
```

4. **Dynamic Import - Dinamik Modül Yükleme**: Koşullu modül yükleme
```javascript
// ES2020'de Dynamic Import
// Koşullu modül yükleme
async function loadModule(moduleName) {
    try {
        const module = await import(`./modules/${moduleName}.js`);
        return module;
    } catch (error) {
        console.error(`Failed to load module: ${moduleName}`, error);
        return null;
    }
}

// Pratik kullanım
async function initializeApp() {
    // Sadece gerekli olduğunda yükle
    if (user.isAdmin) {
        const adminModule = await import('./admin.js');
        adminModule.initializeAdminPanel();
    }
    
    if (user.preferences.darkMode) {
        const themeModule = await import('./dark-theme.js');
        themeModule.applyDarkTheme();
    }
}

// Lazy loading
async function loadHeavyComponent() {
    const { HeavyComponent } = await import('./HeavyComponent.js');
    return HeavyComponent;
}

// Button click'te yükle
document.getElementById('loadButton').addEventListener('click', async () => {
    const Component = await loadHeavyComponent();
    const instance = new Component();
    document.body.appendChild(instance.render());
});
```

5. **globalThis - Global Obje Erişimi**: Platform bağımsız global erişim
```javascript
// ES2020'de globalThis
// Platform bağımsız global erişim
const globalObj = globalThis;

// Browser'da window, Node.js'te global, Web Worker'da self
console.log(globalObj === window); // Browser'da true
console.log(globalObj === global); // Node.js'te true
console.log(globalObj === self); // Web Worker'da true

// Pratik kullanım
function getGlobalVariable(name) {
    return globalThis[name];
}

function setGlobalVariable(name, value) {
    globalThis[name] = value;
}

// Cross-platform global değişken
globalThis.APP_VERSION = "1.0.0";
globalThis.APP_CONFIG = {
    apiUrl: "https://api.example.com",
    debug: true
};
```

**ES2020'un Önemli İyileştirmeleri:**

1. **Better Error Handling - Daha İyi Hata Yönetimi**:
```javascript
// ES2020 ile daha güvenli kod
function processUserData(user) {
    try {
        const name = user?.profile?.personalInfo?.name ?? "Unknown";
        const email = user?.contact?.email ?? "no-email@example.com";
        const age = user?.profile?.personalInfo?.age ?? 0;
        
        return {
            name,
            email,
            age,
            isValid: age > 0 && email !== "no-email@example.com"
        };
    } catch (error) {
        console.error("Error processing user data:", error);
        return null;
    }
}

// Güvenli API çağrısı
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const user = await response.json();
        
        return {
            name: user?.name ?? "Unknown",
            email: user?.email ?? "no-email@example.com",
            avatar: user?.profile?.avatar ?? "/default-avatar.png"
        };
    } catch (error) {
        console.error("Failed to fetch user:", error);
        return null;
    }
}
```

2. **Enhanced Number Handling - Gelişmiş Sayı İşleme**:
```javascript
// ES2020 ile büyük sayı işlemleri
function calculateLargeFactorial(n) {
    let result = 1n;
    for (let i = 2n; i <= BigInt(n); i++) {
        result *= i;
    }
    return result;
}

console.log(calculateLargeFactorial(100)); // 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000n

// Pratik kullanım - ID generation
function generateUniqueId() {
    const timestamp = BigInt(Date.now());
    const random = BigInt(Math.floor(Math.random() * 1000000));
    return (timestamp * 1000000n + random).toString();
}

const id = generateUniqueId();
console.log(id); // "1703123456789123456"
```

**ES2020'un Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES2020 özellikleri için modern tarayıcı gerekli
// Optional chaining ve nullish coalescing için polyfill gerekebilir
```

2. **BigInt Performance - BigInt Performansı**: Normal sayılardan daha yavaş
```javascript
// BigInt işlemleri normal sayılardan daha yavaş
// Sadece gerekli olduğunda kullanılmalı
```

**Neden Önemli?**

1. **Safer Code - Daha Güvenli Kod**: Optional chaining ile güvenli property erişimi
2. **Better Default Values - Daha İyi Default Değerler**: Nullish coalescing ile doğru default değer yönetimi
3. **Large Number Support - Büyük Sayı Desteği**: BigInt ile büyük sayı işlemleri
4. **Dynamic Module Loading - Dinamik Modül Yükleme**: Koşullu modül yükleme

**Ne İşe Yaradı?**

1. **Error Prevention - Hata Önleme**: Optional chaining ile null/undefined hatalarını önleme
2. **Better Configuration - Daha İyi Yapılandırma**: Nullish coalescing ile doğru default değerler
3. **Large Data Processing - Büyük Veri İşleme**: BigInt ile büyük sayı işlemleri
4. **Code Splitting - Kod Bölme**: Dynamic import ile lazy loading

**ES2020'un Etkisi:**

ES2020, JavaScript'in modern programlama dilleri seviyesine çıkmasını sağladı:

- Optional chaining ile güvenli property erişimi
- Nullish coalescing ile doğru default değer yönetimi
- BigInt ile büyük sayı desteği
- Dynamic import ile koşullu modül yükleme

ES2020, JavaScript'i daha güvenli, daha güçlü ve daha modern hale getirdi.

**2021 - ECMAScript 2021 (ES2021) - String ve Promise İyileştirmeleri**:

ES2021, JavaScript'in string işleme ve Promise yeteneklerini geliştirdi. Bu sürüm, String.replaceAll(), Promise.any(), Logical Assignment Operators gibi önemli özellikler getirdi.

**ECMAScript 2021 Ne Demek?**

ES2021, JavaScript'in string işleme ve Promise yeteneklerini geliştirdi. String.replaceAll() ile string değiştirme, Promise.any() ile Promise işlemleri, Logical Assignment Operators ile daha kısa atama operatörleri gibi özellikler eklendi.

**Ne Oldu?**
- **Haziran 2021**: ES2021 yayınlandı
- **String.replaceAll()**: String değiştirme
- **Promise.any()**: Promise işlemleri
- **Logical Assignment Operators**: Mantıksal atama operatörleri
- **Numeric Separators**: Sayısal ayırıcılar
- **WeakRef**: Zayıf referanslar

**Temel Özellikler ve Örnekler:**

1. **String.replaceAll() - String Değiştirme**: Tüm eşleşmeleri değiştirme
```javascript
// ES2021'de String.replaceAll()
const text = "Hello world, world is beautiful";
const replaced = text.replaceAll("world", "universe");
console.log(replaced); // "Hello universe, universe is beautiful"

// Global regex yerine replaceAll()
const html = "<div>Hello</div><div>World</div>";
const cleanHtml = html.replaceAll("<div>", "").replaceAll("</div>", "");
console.log(cleanHtml); // "HelloWorld"

// Pratik kullanım
function sanitizeText(input) {
    return input
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#x27;");
}

const userInput = 'Hello <script>alert("xss")</script>';
const safeText = sanitizeText(userInput);
console.log(safeText); // "Hello &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;"

// Template replacement
function createEmailTemplate(template, data) {
    let result = template;
    for (const [key, value] of Object.entries(data)) {
        result = result.replaceAll(`{{${key}}}`, value);
    }
    return result;
}

const emailTemplate = "Hello {{name}}, your order {{orderId}} is ready!";
const emailData = { name: "John", orderId: "12345" };
const email = createEmailTemplate(emailTemplate, emailData);
console.log(email); // "Hello John, your order 12345 is ready!"
```

2. **Promise.any() - Promise İşlemleri**: İlk başarılı Promise'i bekleme
```javascript
// ES2021'de Promise.any()
const promise1 = new Promise((resolve, reject) => 
    setTimeout(() => reject("Error 1"), 1000)
);
const promise2 = new Promise((resolve, reject) => 
    setTimeout(() => resolve("Success 2"), 2000)
);
const promise3 = new Promise((resolve, reject) => 
    setTimeout(() => reject("Error 3"), 1500)
);

Promise.any([promise1, promise2, promise3])
    .then(result => console.log(result)) // "Success 2"
    .catch(error => console.error(error));

// Pratik kullanım - Multiple API endpoints
async function fetchUserData(userId) {
    const endpoints = [
        `/api/users/${userId}`,
        `/api/v2/users/${userId}`,
        `/api/legacy/users/${userId}`
    ];
    
    const promises = endpoints.map(endpoint => 
        fetch(endpoint).then(response => {
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        })
    );
    
    try {
        const userData = await Promise.any(promises);
        return userData;
    } catch (error) {
        console.error("All endpoints failed:", error);
        throw new Error("User data unavailable");
    }
}

// Fallback strategy
async function loadImageWithFallback(imageUrl) {
    const fallbackUrls = [
        imageUrl,
        imageUrl.replace('.jpg', '.png'),
        imageUrl.replace('.png', '.webp'),
        '/default-image.jpg'
    ];
    
    const promises = fallbackUrls.map(url => 
        fetch(url).then(response => {
            if (!response.ok) throw new Error(`Failed to load ${url}`);
            return url;
        })
    );
    
    try {
        const workingUrl = await Promise.any(promises);
        return workingUrl;
    } catch (error) {
        console.error("All image URLs failed:", error);
        return null;
    }
}
```

3. **Logical Assignment Operators - Mantıksal Atama Operatörleri**: Kısa atama operatörleri
```javascript
// ES2021'de Logical Assignment Operators
let user = { name: "John" };

// ||= (Logical OR assignment)
user.name ||= "Anonymous"; // user.name = user.name || "Anonymous"
console.log(user.name); // "John" (değişmedi)

user.email ||= "john@example.com"; // user.email = user.email || "john@example.com"
console.log(user.email); // "john@example.com"

// &&= (Logical AND assignment)
user.name &&= user.name.toUpperCase(); // user.name = user.name && user.name.toUpperCase()
console.log(user.name); // "JOHN"

// ??= (Nullish coalescing assignment)
user.age ??= 0; // user.age = user.age ?? 0
console.log(user.age); // 0

user.name ??= "Anonymous"; // user.name = user.name ?? "Anonymous"
console.log(user.name); // "JOHN" (değişmedi)

// Pratik kullanım
function initializeUser(user) {
    // Default değerler atama
    user.name ||= "Anonymous";
    user.email ||= "no-email@example.com";
    user.age ??= 0;
    user.isActive ??= true;
    
    // Conditional updates
    user.name &&= user.name.trim();
    user.email &&= user.email.toLowerCase();
    
    return user;
}

const newUser = initializeUser({ name: "  John  ", email: "JOHN@EXAMPLE.COM" });
console.log(newUser); // { name: "JOHN", email: "john@example.com", age: 0, isActive: true }
```

4. **Numeric Separators - Sayısal Ayırıcılar**: Sayıları okunabilir hale getirme
```javascript
// ES2021'de Numeric Separators
const million = 1_000_000;
const billion = 1_000_000_000;
const pi = 3.141_592_653_589_793;

console.log(million); // 1000000
console.log(billion); // 1000000000
console.log(pi); // 3.141592653589793

// Binary, octal, hex
const binary = 0b1010_0001_1000_0101;
const octal = 0o755;
const hex = 0xFF_EC_DE_5E;

console.log(binary); // 41349
console.log(octal); // 493
console.log(hex); // 4293713502

// Pratik kullanım
const config = {
    maxFileSize: 10_000_000, // 10MB
    timeout: 30_000, // 30 seconds
    retryCount: 3,
    apiVersion: 2_021
};

// Financial calculations
const price = 1_234.56;
const tax = 0.08_75; // 8.75%
const total = price * (1 + tax);
console.log(total); // 1342.56
```

5. **WeakRef - Zayıf Referanslar**: Garbage collection'a müdahale etmeyen referanslar
```javascript
// ES2021'de WeakRef
class Cache {
    constructor() {
        this.cache = new Map();
    }
    
    set(key, value) {
        this.cache.set(key, new WeakRef(value));
    }
    
    get(key) {
        const ref = this.cache.get(key);
        if (ref) {
            const value = ref.deref();
            if (value) {
                return value;
            } else {
                // Object garbage collected
                this.cache.delete(key);
            }
        }
        return undefined;
    }
}

// Pratik kullanım
const cache = new Cache();
const largeObject = { data: new Array(1000000).fill(0) };

cache.set("large", largeObject);
console.log(cache.get("large")); // { data: [...] }

// Object'i null yap
largeObject = null;

// Garbage collection'dan sonra
setTimeout(() => {
    console.log(cache.get("large")); // undefined
}, 1000);
```

**ES2021'in Önemli İyileştirmeleri:**

1. **Better String Processing - Daha İyi String İşleme**:
```javascript
// ES2021 ile daha güçlü string işlemleri
function processText(text, replacements) {
    let result = text;
    
    for (const [search, replace] of Object.entries(replacements)) {
        result = result.replaceAll(search, replace);
    }
    
    return result;
}

const template = "Hello {{name}}, your {{item}} is ready for {{action}}!";
const replacements = {
    "{{name}}": "John",
    "{{item}}": "order",
    "{{action}}": "pickup"
};

const processed = processText(template, replacements);
console.log(processed); // "Hello John, your order is ready for pickup!"
```

2. **Enhanced Promise Handling - Gelişmiş Promise İşleme**:
```javascript
// ES2021 ile daha güçlü Promise işlemleri
async function fetchDataWithFallback(urls) {
    const promises = urls.map(url => 
        fetch(url).then(response => {
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        })
    );
    
    try {
        const data = await Promise.any(promises);
        return data;
    } catch (error) {
        console.error("All requests failed:", error);
        throw new Error("Data unavailable");
    }
}

// Multiple data sources
const dataSources = [
    "https://api1.example.com/data",
    "https://api2.example.com/data",
    "https://backup.example.com/data"
];

fetchDataWithFallback(dataSources)
    .then(data => console.log("Data received:", data))
    .catch(error => console.error("Failed to fetch data:", error));
```

**ES2021'in Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES2021 özellikleri için modern tarayıcı gerekli
// String.replaceAll(), Promise.any() için polyfill gerekebilir
```

2. **WeakRef Complexity - WeakRef Karmaşıklığı**: Garbage collection anlayışı gerektirir
```javascript
// WeakRef kullanımı garbage collection anlayışı gerektirir
// Dikkatli kullanım gerekli
```

**Neden Önemli?**

1. **String Processing - String İşleme**: String.replaceAll() ile daha kolay string değiştirme
2. **Promise Handling - Promise İşleme**: Promise.any() ile daha güçlü Promise işlemleri
3. **Code Conciseness - Kod Kısalığı**: Logical assignment operators ile daha kısa kod
4. **Number Readability - Sayı Okunabilirliği**: Numeric separators ile daha okunabilir sayılar

**Ne İşe Yaradı?**

1. **Text Processing - Metin İşleme**: Daha kolay string değiştirme
2. **Error Handling - Hata Yönetimi**: Promise.any() ile fallback stratejileri
3. **Code Simplification - Kod Basitleştirme**: Logical assignment operators ile daha kısa kod
4. **Number Formatting - Sayı Formatlaması**: Daha okunabilir sayılar

**ES2021'in Etkisi:**

ES2021, JavaScript'in string işleme ve Promise yeteneklerini geliştirdi:

- String.replaceAll() ile daha kolay string değiştirme
- Promise.any() ile daha güçlü Promise işlemleri
- Logical assignment operators ile daha kısa kod
- Numeric separators ile daha okunabilir sayılar

ES2021, JavaScript'in string işleme ve Promise yeteneklerini daha da güçlendirdi.

**2022 - ECMAScript 2022 (ES2022) - Class ve Private Fields Devrimi**:

ES2022, JavaScript'in class yeteneklerini büyük ölçüde geliştirdi. Bu sürüm, Private Fields, Static Blocks, Top-level await gibi önemli özellikler getirdi.

**ECMAScript 2022 Ne Demek?**

ES2022, JavaScript'in class yeteneklerini büyük ölçüde geliştirdi. Private fields ile encapsulation, static blocks ile class initialization, top-level await ile modül seviyesinde asenkron işlemler gibi özellikler eklendi.

**Ne Oldu?**
- **Haziran 2022**: ES2022 yayınlandı
- **Private Fields**: Sınıf özel alanları
- **Static Blocks**: Statik bloklar
- **Top-level await**: Modül seviyesinde await
- **Array.at()**: Dizi indeks erişimi
- **Object.hasOwn()**: Nesne özellik kontrolü

**Temel Özellikler ve Örnekler:**

1. **Private Fields - Özel Alanlar**: Sınıf encapsulation
```javascript
// ES2022'de Private Fields
class BankAccount {
    #balance = 0; // Private field
    #accountNumber; // Private field
    
    constructor(accountNumber, initialBalance = 0) {
        this.#accountNumber = accountNumber;
        this.#balance = initialBalance;
    }
    
    // Public method
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            return this.#balance;
        }
        throw new Error("Amount must be positive");
    }
    
    // Public method
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            return this.#balance;
        }
        throw new Error("Insufficient funds or invalid amount");
    }
    
    // Public method
    getBalance() {
        return this.#balance;
    }
    
    // Private method
    #validateAmount(amount) {
        return typeof amount === 'number' && amount > 0;
    }
    
    // Public method using private method
    transfer(amount, targetAccount) {
        if (this.#validateAmount(amount)) {
            this.withdraw(amount);
            targetAccount.deposit(amount);
            return true;
        }
        return false;
    }
}

// Kullanım
const account1 = new BankAccount("12345", 1000);
const account2 = new BankAccount("67890", 500);

console.log(account1.getBalance()); // 1000
account1.deposit(200);
console.log(account1.getBalance()); // 1200

// Private field'a doğrudan erişim mümkün değil
// console.log(account1.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class
```

2. **Static Blocks - Statik Bloklar**: Sınıf başlatma
```javascript
// ES2022'de Static Blocks
class DatabaseConnection {
    static #connection;
    static #isInitialized = false;
    
    // Static block - sınıf yüklendiğinde çalışır
    static {
        console.log("Initializing database connection...");
        this.#connection = this.#createConnection();
        this.#isInitialized = true;
        console.log("Database connection initialized");
    }
    
    static #createConnection() {
        // Simulated database connection
        return {
            host: "localhost",
            port: 5432,
            database: "myapp",
            connected: true
        };
    }
    
    static getConnection() {
        if (!this.#isInitialized) {
            throw new Error("Database not initialized");
        }
        return this.#connection;
    }
    
    static async initializeAsync() {
        // Async static block simulation
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("Async initialization complete");
                resolve();
            }, 1000);
        });
    }
}

// Kullanım
console.log(DatabaseConnection.getConnection()); // { host: "localhost", port: 5432, database: "myapp", connected: true }
```

3. **Top-level await - Modül Seviyesinde Await**: Modül seviyesinde asenkron işlemler
```javascript
// ES2022'de Top-level await
// config.js
const config = await fetch('/api/config').then(response => response.json());
export default config;

// app.js
import config from './config.js';

// Config yüklendikten sonra çalışır
console.log('App configuration:', config);

// Pratik kullanım
async function initializeApp() {
    try {
        // Multiple async operations
        const [user, settings, theme] = await Promise.all([
            fetch('/api/user').then(r => r.json()),
            fetch('/api/settings').then(r => r.json()),
            fetch('/api/theme').then(r => r.json())
        ]);
        
        return { user, settings, theme };
    } catch (error) {
        console.error('Failed to initialize app:', error);
        throw error;
    }
}

// Top-level await ile
const appData = await initializeApp();
console.log('App initialized with:', appData);
```

4. **Array.at() - Dizi İndeks Erişimi**: Negatif indeks desteği
```javascript
// ES2022'de Array.at()
const fruits = ['apple', 'banana', 'orange', 'grape'];

// Pozitif indeks
console.log(fruits.at(0)); // "apple"
console.log(fruits.at(2)); // "orange"

// Negatif indeks
console.log(fruits.at(-1)); // "grape" (son eleman)
console.log(fruits.at(-2)); // "orange" (sondan ikinci)

// ES5/ES6'da negatif indeks
console.log(fruits[fruits.length - 1]); // "grape"
console.log(fruits[fruits.length - 2]); // "orange"

// Pratik kullanım
function getLastNElements(array, n) {
    const result = [];
    for (let i = 1; i <= n; i++) {
        const element = array.at(-i);
        if (element !== undefined) {
            result.unshift(element);
        }
    }
    return result;
}

const lastTwo = getLastNElements(fruits, 2);
console.log(lastTwo); // ["orange", "grape"]
```

5. **Object.hasOwn() - Nesne Özellik Kontrolü**: Güvenli özellik kontrolü
```javascript
// ES2022'de Object.hasOwn()
const obj = { name: "John", age: 30 };

// Object.hasOwn() kullanımı
console.log(Object.hasOwn(obj, 'name')); // true
console.log(Object.hasOwn(obj, 'age')); // true
console.log(Object.hasOwn(obj, 'toString')); // false

// Object.prototype.hasOwnProperty() yerine
console.log(obj.hasOwnProperty('name')); // true (eski yöntem)

// Pratik kullanım
function mergeObjects(target, source) {
    for (const key in source) {
        if (Object.hasOwn(source, key)) {
            target[key] = source[key];
        }
    }
    return target;
}

const user1 = { name: "John", age: 30 };
const user2 = { age: 25, city: "New York" };

const merged = mergeObjects(user1, user2);
console.log(merged); // { name: "John", age: 25, city: "New York" }
```

**ES2022'un Önemli İyileştirmeleri:**

1. **Better Class Encapsulation - Daha İyi Sınıf Kapsülleme**:
```javascript
// ES2022 ile daha güçlü sınıf kapsülleme
class UserManager {
    #users = new Map();
    #nextId = 1;
    
    static {
        console.log("UserManager class loaded");
    }
    
    #generateId() {
        return this.#nextId++;
    }
    
    #validateUser(userData) {
        return userData && typeof userData.name === 'string' && userData.name.length > 0;
    }
    
    addUser(userData) {
        if (!this.#validateUser(userData)) {
            throw new Error("Invalid user data");
        }
        
        const id = this.#generateId();
        const user = {
            id,
            name: userData.name,
            email: userData.email,
            createdAt: new Date()
        };
        
        this.#users.set(id, user);
        return user;
    }
    
    getUser(id) {
        return this.#users.get(id);
    }
    
    getAllUsers() {
        return Array.from(this.#users.values());
    }
    
    deleteUser(id) {
        return this.#users.delete(id);
    }
}

const userManager = new UserManager();
const user = userManager.addUser({ name: "John", email: "john@example.com" });
console.log(user); // { id: 1, name: "John", email: "john@example.com", createdAt: Date }
```

2. **Enhanced Module System - Gelişmiş Modül Sistemi**:
```javascript
// ES2022 ile daha güçlü modül sistemi
// data-loader.js
const data = await fetch('/api/data').then(response => response.json());
export default data;

// app.js
import data from './data-loader.js';

// Data yüklendikten sonra çalışır
console.log('Data loaded:', data);

// Error handling ile
try {
    const config = await fetch('/api/config').then(response => {
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return response.json();
    });
    
    console.log('Config loaded:', config);
} catch (error) {
    console.error('Failed to load config:', error);
    // Fallback config
    const fallbackConfig = { theme: 'light', language: 'en' };
    console.log('Using fallback config:', fallbackConfig);
}
```

**ES2022'un Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES2022 özellikleri için modern tarayıcı gerekli
// Private fields, static blocks için polyfill gerekebilir
```

2. **Class Complexity - Sınıf Karmaşıklığı**: Private fields yeni bir paradigm
```javascript
// Private fields yeni bir düşünce şekli gerektirir
// Encapsulation anlayışı gerektirir
```

**Neden Önemli?**

1. **Better Encapsulation - Daha İyi Kapsülleme**: Private fields ile gerçek encapsulation
2. **Class Initialization - Sınıf Başlatma**: Static blocks ile sınıf başlatma
3. **Module-level Async - Modül Seviyesinde Asenkron**: Top-level await ile modül seviyesinde asenkron
4. **Array Convenience - Dizi Kolaylığı**: Array.at() ile negatif indeks desteği

**Ne İşe Yaradı?**

1. **Object-Oriented Programming - Nesne Yönelimli Programlama**: Daha güçlü OOP desteği
2. **Module System - Modül Sistemi**: Daha güçlü modül sistemi
3. **Array Operations - Dizi İşlemleri**: Daha kolay dizi işlemleri
4. **Code Organization - Kod Organizasyonu**: Daha iyi kod organizasyonu

**ES2022'un Etkisi:**

ES2022, JavaScript'in class yeteneklerini büyük ölçüde geliştirdi:

- Private fields ile gerçek encapsulation
- Static blocks ile sınıf başlatma
- Top-level await ile modül seviyesinde asenkron
- Array.at() ile negatif indeks desteği

ES2022, JavaScript'i daha güçlü bir OOP dili haline getirdi.

**2023 - ECMAScript 2023 (ES2023) - Array ve Object İyileştirmeleri**:

ES2023, JavaScript'in array ve object işlemlerini daha da geliştirdi. Bu sürüm, Array.findLast(), Array.findLastIndex(), Array.toReversed(), Array.toSorted(), Array.toSpliced(), Array.with() gibi önemli metodlar getirdi.

**ECMAScript 2023 Ne Demek?**

ES2023, JavaScript'in array ve object işlemlerini daha da geliştirdi. Array metodlarının immutable versiyonları, findLast metodları ve daha güçlü array işlemleri eklendi. Bu sürüm, JavaScript'in veri işleme yeteneklerini daha da güçlendirdi.

**Ne Oldu?**
- **Haziran 2023**: ES2023 yayınlandı
- **Array.findLast()**: Son eşleşen elemanı bulma
- **Array.findLastIndex()**: Son eşleşen elemanın indeksini bulma
- **Array.toReversed()**: Ters çevrilmiş dizi (immutable)
- **Array.toSorted()**: Sıralanmış dizi (immutable)
- **Array.toSpliced()**: Kesilmiş dizi (immutable)
- **Array.with()**: Belirli indekste değiştirilmiş dizi (immutable)

**Temel Özellikler ve Örnekler:**

1. **Array.findLast() ve findLastIndex() - Son Eşleşen Eleman**: Dizinin sonundan arama
```javascript
// ES2023'te Array.findLast() ve findLastIndex()
const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

// findLast() - Son eşleşen elemanı bul
const lastEven = numbers.findLast(num => num % 2 === 0);
console.log(lastEven); // 2 (son çift sayı)

// findLastIndex() - Son eşleşen elemanın indeksini bul
const lastEvenIndex = numbers.findLastIndex(num => num % 2 === 0);
console.log(lastEvenIndex); // 7 (son çift sayının indeksi)

// Pratik kullanım
const users = [
    { id: 1, name: "John", active: true },
    { id: 2, name: "Jane", active: false },
    { id: 3, name: "Bob", active: true },
    { id: 4, name: "Alice", active: false },
    { id: 5, name: "Charlie", active: true }
];

// Son aktif kullanıcıyı bul
const lastActiveUser = users.findLast(user => user.active);
console.log(lastActiveUser); // { id: 5, name: "Charlie", active: true }

// Son aktif kullanıcının indeksini bul
const lastActiveIndex = users.findLastIndex(user => user.active);
console.log(lastActiveIndex); // 4

// Log dosyasından son hatayı bul
const logEntries = [
    { level: "info", message: "User logged in" },
    { level: "warning", message: "Low memory" },
    { level: "error", message: "Database connection failed" },
    { level: "info", message: "User logged out" },
    { level: "error", message: "File not found" }
];

const lastError = logEntries.findLast(entry => entry.level === "error");
console.log(lastError); // { level: "error", message: "File not found" }
```

2. **Array.toReversed() - Ters Çevrilmiş Dizi**: Immutable reverse
```javascript
// ES2023'te Array.toReversed()
const original = [1, 2, 3, 4, 5];

// toReversed() - Orijinal diziyi değiştirmez
const reversed = original.toReversed();
console.log(original); // [1, 2, 3, 4, 5] (değişmedi)
console.log(reversed); // [5, 4, 3, 2, 1]

// ES5/ES6'da reverse() orijinal diziyi değiştirir
const original2 = [1, 2, 3, 4, 5];
const reversed2 = original2.reverse();
console.log(original2); // [5, 4, 3, 2, 1] (değişti!)
console.log(reversed2); // [5, 4, 3, 2, 1]

// Pratik kullanım
function processData(data) {
    // Orijinal veriyi koruyarak işlem yap
    const sorted = data.toSorted((a, b) => a.value - b.value);
    const reversed = sorted.toReversed();
    
    return {
        original: data,
        sorted: sorted,
        reversed: reversed
    };
}

const data = [
    { name: "John", value: 30 },
    { name: "Jane", value: 25 },
    { name: "Bob", value: 35 }
];

const result = processData(data);
console.log(result.original); // Orijinal veri korundu
console.log(result.sorted); // Sıralanmış veri
console.log(result.reversed); // Ters çevrilmiş veri
```

3. **Array.toSorted() - Sıralanmış Dizi**: Immutable sort
```javascript
// ES2023'te Array.toSorted()
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];

// toSorted() - Orijinal diziyi değiştirmez
const sorted = numbers.toSorted();
console.log(numbers); // [3, 1, 4, 1, 5, 9, 2, 6] (değişmedi)
console.log(sorted); // [1, 1, 2, 3, 4, 5, 6, 9]

// Custom sıralama
const users = [
    { name: "John", age: 30 },
    { name: "Jane", age: 25 },
    { name: "Bob", age: 35 }
];

const sortedByAge = users.toSorted((a, b) => a.age - b.age);
console.log(users); // Orijinal dizi korundu
console.log(sortedByAge); // Yaşa göre sıralanmış

// Pratik kullanım
function analyzeData(data) {
    const sorted = data.toSorted((a, b) => a.value - b.value);
    const reversed = sorted.toReversed();
    
    return {
        min: sorted[0],
        max: sorted[sorted.length - 1],
        median: sorted[Math.floor(sorted.length / 2)],
        topThree: reversed.slice(0, 3)
    };
}

const scores = [
    { name: "Alice", value: 85 },
    { name: "Bob", value: 92 },
    { name: "Charlie", value: 78 },
    { name: "Diana", value: 96 },
    { name: "Eve", value: 88 }
];

const analysis = analyzeData(scores);
console.log(analysis); // { min: {...}, max: {...}, median: {...}, topThree: [...] }
```

4. **Array.toSpliced() - Kesilmiş Dizi**: Immutable splice
```javascript
// ES2023'te Array.toSpliced()
const original = [1, 2, 3, 4, 5];

// toSpliced() - Orijinal diziyi değiştirmez
const spliced = original.toSpliced(1, 2, 'a', 'b');
console.log(original); // [1, 2, 3, 4, 5] (değişmedi)
console.log(spliced); // [1, 'a', 'b', 4, 5]

// ES5/ES6'da splice() orijinal diziyi değiştirir
const original2 = [1, 2, 3, 4, 5];
const spliced2 = original2.splice(1, 2, 'a', 'b');
console.log(original2); // [1, 'a', 'b', 4, 5] (değişti!)
console.log(spliced2); // [2, 3] (çıkarılan elemanlar)

// Pratik kullanım
function updateUserList(users, userId, updates) {
    const index = users.findIndex(user => user.id === userId);
    if (index === -1) return users;
    
    // Kullanıcıyı güncelle
    const updatedUser = { ...users[index], ...updates };
    return users.toSpliced(index, 1, updatedUser);
}

const users = [
    { id: 1, name: "John", age: 30 },
    { id: 2, name: "Jane", age: 25 },
    { id: 3, name: "Bob", age: 35 }
];

const updatedUsers = updateUserList(users, 2, { age: 26, city: "New York" });
console.log(users); // Orijinal dizi korundu
console.log(updatedUsers); // Güncellenmiş dizi
```

5. **Array.with() - Belirli İndekste Değiştirilmiş Dizi**: Immutable index update
```javascript
// ES2023'te Array.with()
const original = [1, 2, 3, 4, 5];

// with() - Orijinal diziyi değiştirmez
const updated = original.with(2, 10);
console.log(original); // [1, 2, 3, 4, 5] (değişmedi)
console.log(updated); // [1, 2, 10, 4, 5]

// Negatif indeks
const updated2 = original.with(-1, 100);
console.log(updated2); // [1, 2, 3, 4, 100]

// Pratik kullanım
function updateItemInList(items, index, updates) {
    if (index < 0 || index >= items.length) return items;
    
    const updatedItem = { ...items[index], ...updates };
    return items.with(index, updatedItem);
}

const todos = [
    { id: 1, text: "Learn JavaScript", completed: false },
    { id: 2, text: "Build a project", completed: false },
    { id: 3, text: "Deploy to production", completed: false }
];

const updatedTodos = updateItemInList(todos, 1, { completed: true });
console.log(todos); // Orijinal dizi korundu
console.log(updatedTodos); // Güncellenmiş dizi

// Toggle completion
function toggleTodo(todos, index) {
    const todo = todos[index];
    if (!todo) return todos;
    
    return todos.with(index, { ...todo, completed: !todo.completed });
}

const toggledTodos = toggleTodo(todos, 0);
console.log(toggledTodos); // İlk todo'nun completed durumu değişti
```

**ES2023'un Önemli İyileştirmeleri:**

1. **Better Array Operations - Daha İyi Dizi İşlemleri**:
```javascript
// ES2023 ile daha güçlü dizi işlemleri
function processUserData(users) {
    // Orijinal veriyi koruyarak işlem yap
    const activeUsers = users.filter(user => user.active);
    const sortedUsers = activeUsers.toSorted((a, b) => a.name.localeCompare(b.name));
    const reversedUsers = sortedUsers.toReversed();
    
    // Son aktif kullanıcıyı bul
    const lastActiveUser = users.findLast(user => user.active);
    
    return {
        original: users,
        active: activeUsers,
        sorted: sortedUsers,
        reversed: reversedUsers,
        lastActive: lastActiveUser
    };
}

const users = [
    { id: 1, name: "John", active: true },
    { id: 2, name: "Jane", active: false },
    { id: 3, name: "Bob", active: true },
    { id: 4, name: "Alice", active: true }
];

const result = processUserData(users);
console.log(result);
```

2. **Immutable Data Processing - Değişmez Veri İşleme**:
```javascript
// ES2023 ile immutable veri işleme
class DataProcessor {
    constructor(data) {
        this.originalData = data;
    }
    
    sort(compareFn) {
        return this.originalData.toSorted(compareFn);
    }
    
    reverse() {
        return this.originalData.toReversed();
    }
    
    update(index, updates) {
        return this.originalData.with(index, { ...this.originalData[index], ...updates });
    }
    
    remove(index, count = 1) {
        return this.originalData.toSpliced(index, count);
    }
    
    insert(index, ...items) {
        return this.originalData.toSpliced(index, 0, ...items);
    }
    
    findLast(predicate) {
        return this.originalData.findLast(predicate);
    }
    
    findLastIndex(predicate) {
        return this.originalData.findLastIndex(predicate);
    }
}

const processor = new DataProcessor([1, 2, 3, 4, 5]);
const sorted = processor.sort((a, b) => b - a);
const reversed = processor.reverse();
const updated = processor.update(2, 10);

console.log(processor.originalData); // [1, 2, 3, 4, 5] (korundu)
console.log(sorted); // [5, 4, 3, 2, 1]
console.log(reversed); // [5, 4, 3, 2, 1]
console.log(updated); // [1, 2, 10, 4, 5]
```

**ES2023'un Sınırlamaları:**

1. **Browser Support - Tarayıcı Desteği**: Eski tarayıcılarda desteklenmez
```javascript
// ES2023 özellikleri için modern tarayıcı gerekli
// Array metodları için polyfill gerekebilir
```

2. **Performance - Performans**: Büyük dizilerde immutable operations yavaş olabilir
```javascript
// Büyük dizilerde immutable operations performans sorunu yaratabilir
// Dikkatli kullanım gerekli
```

**Neden Önemli?**

1. **Immutable Operations - Değişmez İşlemler**: Orijinal veriyi koruyarak işlem yapma
2. **Better Array Methods - Daha İyi Dizi Metodları**: findLast, toReversed, toSorted gibi metodlar
3. **Functional Programming - Fonksiyonel Programlama**: Immutable operations ile FP desteği
4. **Data Safety - Veri Güvenliği**: Orijinal veriyi koruyarak güvenli işlem yapma

**Ne İşe Yaradı?**

1. **Data Processing - Veri İşleme**: Daha güvenli veri işleme
2. **Functional Programming - Fonksiyonel Programlama**: Immutable operations ile FP
3. **Array Operations - Dizi İşlemleri**: Daha güçlü dizi işlemleri
4. **Code Safety - Kod Güvenliği**: Orijinal veriyi koruyarak güvenli kod

**ES2023'un Etkisi:**

ES2023, JavaScript'in array işlemlerini daha da geliştirdi:

- findLast ve findLastIndex ile son eşleşen eleman bulma
- toReversed, toSorted, toSpliced, with ile immutable operations
- Daha güvenli veri işleme
- Fonksiyonel programlama desteği

ES2023, JavaScript'in veri işleme yeteneklerini daha da güçlendirdi.

**2024 - ECMAScript 2024 (ES2024) - JavaScript'in Geleceği**:

ES2024, JavaScript'in en son sürümüdür. Bu sürüm, JavaScript'in gelecekteki yönünü gösterir ve daha da güçlü özellikler getirir.

**ECMAScript 2024 Ne Demek?**

ES2024, JavaScript'in en son sürümüdür. Bu sürüm, JavaScript'in gelecekteki yönünü gösterir ve daha da güçlü özellikler getirir. JavaScript'in evrimi devam etmekte ve her yıl yeni özellikler eklenmektedir.

**Ne Oldu?**
- **Haziran 2024**: ES2024 yayınlandı
- **JavaScript'in Geleceği**: JavaScript'in gelecekteki yönü
- **Sürekli Gelişim**: JavaScript'in sürekli gelişimi
- **Modern Web**: Modern web geliştirmenin temeli

**JavaScript'in Geleceği:**

JavaScript'in evrimi devam etmekte ve her yıl yeni özellikler eklenmektedir. ES2024, JavaScript'in gelecekteki yönünü gösterir:

1. **Sürekli Gelişim**: JavaScript her yıl yeni özellikler kazanıyor
2. **Modern Web**: Modern web geliştirmenin temeli
3. **Ekosistem**: Güçlü ekosistem ve topluluk desteği
4. **Performans**: Sürekli performans iyileştirmeleri

**JavaScript'in Evrimi:**

JavaScript'in evrimi, 1995'ten günümüze kadar devam etmektedir:

- **1995-2009**: Temel JavaScript (ES1-ES5)
- **2010-2015**: Modern JavaScript'in Doğuşu (ES6)
- **2016-2020**: Yıllık Güncellemeler (ES2016-ES2020)
- **2021-2024**: Sürekli Gelişim (ES2021-ES2024)

**JavaScript'in Gelecekteki Yönü:**

JavaScript'in gelecekteki yönü şu alanlarda olacak:

1. **Performans**: Daha hızlı çalışma
2. **Güvenlik**: Daha güvenli kod
3. **Kolaylık**: Daha kolay kullanım
4. **Uyumluluk**: Daha iyi uyumluluk

**JavaScript'in Etkisi:**

JavaScript, modern web geliştirmenin temelini oluşturmuştur:

- **Web Uygulamaları**: Modern web uygulamaları
- **Mobil Uygulamalar**: React Native, Ionic
- **Desktop Uygulamalar**: Electron
- **Server-side**: Node.js
- **IoT**: JavaScript ile IoT geliştirme

**JavaScript'in Önemi:**

JavaScript, günümüzde en önemli programlama dillerinden biridir:

1. **Web Geliştirme**: Web geliştirmenin temeli
2. **Mobil Geliştirme**: Cross-platform mobil geliştirme
3. **Desktop Geliştirme**: Cross-platform desktop geliştirme
4. **Server Geliştirme**: Backend geliştirme
5. **IoT Geliştirme**: Internet of Things geliştirme

**JavaScript'in Geleceği:**

JavaScript'in geleceği parlak görünmektedir:

- **Sürekli Gelişim**: Her yıl yeni özellikler
- **Güçlü Ekosistem**: Büyük topluluk desteği
- **Modern Araçlar**: Modern geliştirme araçları
- **Performans**: Sürekli performans iyileştirmeleri

**Sonuç:**

JavaScript, 1995'ten günümüze kadar büyük bir evrim geçirmiştir. ES1'den ES2024'e kadar olan yolculuk, JavaScript'i "oyuncak dil" olmaktan çıkarıp modern web geliştirmenin temel taşı haline getirmiştir.

JavaScript'in evrimi devam etmekte ve gelecekte daha da güçlü özellikler kazanacaktır. Bu sürekli gelişim, JavaScript'i günümüzün en popüler programlama dillerinden biri yapmıştır.

**Arrow Functions - Ok Fonksiyonları**

Arrow functions, fonksiyon yazımını kısaltan ve this bağlamını değiştiren özelliktir.

**Ne Demek?**
- **Shorter Syntax**: Daha kısa sözdizimi
- **Lexical this**: this değerini lexical olarak bağlar
- **No arguments**: arguments objesi yok
- **No prototype**: prototype özelliği yok

**Neden İhtiyaç Var?**
- **Code Conciseness**: Kod kısalığı
- **this Binding**: this bağlama sorunlarını çözme
- **Functional Programming**: Fonksiyonel programlama desteği
- **Callback Functions**: Callback fonksiyonları için ideal

**Ne İşe Yarar?**
- **Array Methods**: Array metodları ile kullanım
- **Event Handlers**: Olay işleyicileri
- **Promise Chains**: Promise zincirleri
- **Functional Composition**: Fonksiyonel kompozisyon

**Classes - Sınıf Tabanlı OOP**

ES6, JavaScript'e sınıf tabanlı OOP desteği ekledi.

**Ne Demek?**
- **class Keyword**: class anahtar kelimesi
- **constructor**: Constructor metodu
- **extends**: Miras alma
- **super**: Üst sınıf erişimi
- **static**: Statik metodlar

**Neden İhtiyaç Var?**
- **Familiar Syntax**: Tanıdık sözdizimi
- **OOP Support**: OOP desteği
- **Framework Development**: Framework geliştirme
- **Team Development**: Takım geliştirme

**Ne İşe Yarar?**
- **Object-Oriented Programming**: Nesne yönelimli programlama
- **Inheritance**: Miras alma
- **Encapsulation**: Kapsülleme
- **Polymorphism**: Çok biçimlilik

**Modules - import/export Sistemi**

ES6, JavaScript'e resmi modül sistemi ekledi.

**Ne Demek?**
- **import/export**: Modül import/export
- **Named Exports**: İsimli export'lar
- **Default Exports**: Varsayılan export'lar
- **Tree Shaking**: Kullanılmayan kodları kaldırma

**Neden İhtiyaç Var?**
- **Code Organization**: Kod organizasyonu
- **Dependency Management**: Bağımlılık yönetimi
- **Bundle Optimization**: Paket optimizasyonu
- **Large Applications**: Büyük uygulamalar

**Ne İşe Yarar?**
- **Modular Development**: Modüler geliştirme
- **Code Reusability**: Kod yeniden kullanılabilirliği
- **Build Optimization**: Build optimizasyonu
- **Library Development**: Kütüphane geliştirme

**Template Literals - Şablon Dizgileri**

Template literals, string oluşturmayı kolaylaştırır.

**Ne Demek?**
- **Backticks**: Backtick (`) kullanımı
- **String Interpolation**: String interpolasyonu
- **Multiline Strings**: Çok satırlı string'ler
- **Tagged Templates**: Etiketli şablonlar

**Neden İhtiyaç Var?**
- **String Concatenation**: String birleştirme
- **Dynamic Content**: Dinamik içerik
- **HTML Generation**: HTML oluşturma
- **SQL Queries**: SQL sorguları

**Ne İşe Yarar?**
- **Dynamic Strings**: Dinamik string'ler
- **HTML Templates**: HTML şablonları
- **API URLs**: API URL'leri
- **Configuration**: Yapılandırma

**Destructuring - Yapı Sökme**

Destructuring, nesne ve dizilerden değerleri çıkarmayı kolaylaştırır.

**Ne Demek?**
- **Object Destructuring**: Nesne ayrıştırma
- **Array Destructuring**: Dizi ayrıştırma
- **Default Values**: Varsayılan değerler
- **Rest Pattern**: Rest deseni

**Neden İhtiyaç Var?**
- **Code Readability**: Kod okunabilirliği
- **Parameter Handling**: Parametre işleme
- **API Responses**: API yanıtları
- **Configuration**: Yapılandırma

**Ne İşe Yarar?**
- **Function Parameters**: Fonksiyon parametreleri
- **API Integration**: API entegrasyonu
- **Configuration Objects**: Yapılandırma nesneleri
- **State Management**: Durum yönetimi

**Default Parameters - Varsayılan Parametreler**

Default parameters, fonksiyon parametrelerine varsayılan değer atar.

**Ne Demek?**
- **Default Values**: Varsayılan değerler
- **Optional Parameters**: Opsiyonel parametreler
- **Function Overloading**: Fonksiyon aşırı yükleme
- **API Design**: API tasarımı

**Neden İhtiyaç Var?**
- **Function Flexibility**: Fonksiyon esnekliği
- **API Design**: API tasarımı
- **Backward Compatibility**: Geriye uyumluluk
- **Code Clarity**: Kod netliği

**Ne İşe Yarar?**
- **API Functions**: API fonksiyonları
- **Utility Functions**: Yardımcı fonksiyonlar
- **Configuration**: Yapılandırma
- **Optional Features**: Opsiyonel özellikler

**Rest/Spread - Rest ve Spread Operatörleri**

Rest ve spread operatörleri, parametre ve dizi işlemlerini kolaylaştırır.

**Ne Demek?**
- **Rest Parameters**: Rest parametreleri
- **Spread Arrays**: Dizi yayma
- **Spread Objects**: Nesne yayma
- **Function Arguments**: Fonksiyon argümanları

**Neden İhtiyaç Var?**
- **Variable Arguments**: Değişken argümanlar
- **Array Operations**: Dizi işlemleri
- **Object Merging**: Nesne birleştirme
- **Function Calls**: Fonksiyon çağrıları

**Ne İşe Yarar?**
- **Function Parameters**: Fonksiyon parametreleri
- **Array Manipulation**: Dizi manipülasyonu
- **Object Cloning**: Nesne klonlama
- **API Integration**: API entegrasyonu

**Promises - Promise API'si**

Promises, asenkron programlamayı kolaylaştırır.

**Ne Demek?**
- **Asynchronous Operations**: Asenkron işlemler
- **then/catch**: then/catch metodları
- **Promise.all**: Birden fazla promise
- **Promise.race**: İlk tamamlanan promise

**Neden İhtiyaç Var?**
- **Callback Hell**: Callback cehennemi
- **Error Handling**: Hata işleme
- **Async Coordination**: Asenkron koordinasyon
- **Modern APIs**: Modern API'ler

**Ne İşe Yarar?**
- **API Calls**: API çağrıları
- **File Operations**: Dosya işlemleri
- **Database Queries**: Veritabanı sorguları
- **Async Workflows**: Asenkron iş akışları

**let/const - Yeni Değişken Tanımlama**

let ve const, var'ın sorunlarını çözer.

**Ne Demek?**
- **Block Scope**: Blok kapsamı
- **Temporal Dead Zone**: Geçici ölü bölge
- **No Hoisting**: Hoisting yok
- **const Immutability**: const değişmezlik

**Neden İhtiyaç Var?**
- **var Problems**: var'ın sorunları
- **Block Scope**: Blok kapsamı
- **Immutability**: Değişmezlik
- **Better Practices**: Daha iyi uygulamalar

**Ne İşe Yarar?**
- **Variable Scoping**: Değişken kapsamı
- **Immutable Variables**: Değişmez değişkenler
- **Loop Variables**: Döngü değişkenleri
- **Configuration**: Yapılandırma

**Symbol - Yeni Primitive Tip**

Symbol, benzersiz tanımlayıcılar oluşturur.

**Ne Demek?**
- **Unique Identifiers**: Benzersiz tanımlayıcılar
- **Private Properties**: Özel özellikler
- **Well-known Symbols**: Bilinen semboller
- **Metaprogramming**: Metaprogramming

**Neden İhtiyaç Var?**
- **Name Collision**: İsim çakışması önleme
- **Private Data**: Özel veri
- **API Design**: API tasarımı
- **Library Development**: Kütüphane geliştirme

**Ne İşe Yarar?**
- **Object Keys**: Nesne anahtarları
- **Private Properties**: Özel özellikler
- **API Symbols**: API sembolleri
- **Metaprogramming**: Metaprogramming

**Map/Set - Yeni Veri Yapıları**

Map ve Set, yeni veri yapıları sağlar.

**Ne Demek?**
- **Map**: Anahtar-değer çiftleri
- **Set**: Benzersiz değerler
- **WeakMap/WeakSet**: Zayıf referanslar
- **Iteration**: Iterasyon desteği

**Neden İhtiyaç Var?**
- **Object Limitations**: Nesne sınırlamaları
- **Performance**: Performans
- **Data Structures**: Veri yapıları
- **Algorithms**: Algoritmalar

**Ne İşe Yarar?**
- **Caching**: Önbellekleme
- **Data Processing**: Veri işleme
- **Unique Collections**: Benzersiz koleksiyonlar
- **Performance Optimization**: Performans optimizasyonu

**Proxy/Reflect - Metaprogramming API'leri**

Proxy ve Reflect, metaprogramming sağlar.

**Ne Demek?**
- **Proxy**: Nesne davranışını değiştirme
- **Reflect**: Meta-object operations
- **Metaprogramming**: Metaprogramming
- **Object Behavior**: Nesne davranışı

**Neden İhtiyaç Var?**
- **Object Customization**: Nesne özelleştirme
- **Validation**: Doğrulama
- **Logging**: Loglama
- **Security**: Güvenlik

**Ne İşe Yarar?**
- **Object Proxies**: Nesne proxy'leri
- **Validation**: Doğrulama
- **Logging**: Loglama
- **Security**: Güvenlik

**Generators - Generator Fonksiyonları**

Generators, iterable objeler oluşturur.

**Ne Demek?**
- **function***: Generator fonksiyonları
- **yield**: Değer döndürme
- **Iteration**: Iterasyon
- **Lazy Evaluation**: Tembel değerlendirme

**Neden İhtiyaç Var?**
- **Iteration Control**: Iterasyon kontrolü
- **Memory Efficiency**: Bellek verimliliği
- **Async Programming**: Asenkron programlama
- **Data Processing**: Veri işleme

**Ne İşe Yarar?**
- **Iterators**: Iteratörler
- **Async Iteration**: Asenkron iterasyon
- **Data Streams**: Veri akışları
- **Memory Optimization**: Bellek optimizasyonu

**ES6'ın Etkisi:**
- **Modern JavaScript**: Modern JavaScript'in başlangıcı
- **Framework Era**: Framework çağı
- **Build Tools**: Build araçları
- **Developer Experience**: Geliştirici deneyimi

**İlk Çözümler**:
- **Dinamik Etkileşim**: Kullanıcıların web sayfalarıyla etkileşimde bulunmasını sağladı
- **Form Doğrulama**: Kullanıcı tarafından girilen verilerin istemci tarafında doğrulanmasını mümkün kıldı
- **Basit Animasyonlar**: Görsel efektler ve animasyonlar ekleyerek kullanıcı deneyimini zenginleştirdi
- **DOM Manipülasyonu**: Sayfa içeriğinin dinamik olarak değiştirilmesine olanak tanıdı
- **AJAX**: Asenkron web uygulamaları geliştirme
- **Single Page Applications**: Tek sayfa uygulamaları
- **Real-time Applications**: Gerçek zamanlı uygulamalar

### 1.2 JavaScript Versiyonları ve Özellikleri - Detaylı Analiz

JavaScript versiyonları, web geliştirmenin evrimini ve modern programlama paradigmalarının gelişimini yansıtır. Her versiyon, belirli bir dönemin ihtiyaçlarını karşılamak ve JavaScript'i daha güçlü, esnek ve kullanışlı hale getirmek için tasarlanmıştır. Bu versiyonlar, sadece yeni özellikler eklemekle kalmaz, aynı zamanda dilin felsefesini ve tasarım prensiplerini de geliştirir.

**ECMAScript Standartlaşma Süreci - Derinlemesine Analiz**

ECMAScript, JavaScript'in resmi standartıdır ve Ecma International tarafından yönetilir. Bu standartlaşma süreci, JavaScript'in farklı tarayıcılarda tutarlı çalışmasını sağlar ve dilin evrimini yönlendirir.

**Standartlaşmanın Felsefesi:**
ECMAScript standartlaşması, "backward compatibility" (geriye uyumluluk) prensibini benimser. Bu prensip, mevcut kod'un yeni versiyonlarda çalışmaya devam etmesini sağlar.

**Versiyonlama Stratejisi:**
ECMAScript, yıllık release cycle'ı benimser. Bu strateji, dilin sürekli gelişmesini sağlar ve geliştiricilere düzenli güncellemeler sunar.

**Feature Proposal Süreci:**
Yeni özellikler, TC39 (Technical Committee 39) tarafından değerlendirilir. Bu süreç, özelliklerin dikkatli bir şekilde tasarlanmasını sağlar.

**ES1 (1997) - Temel Kurulum - Derinlemesine Analiz**

ES1, JavaScript'in ilk resmi standartıdır. Bu versiyon, JavaScript'in temel yapılarını tanımlar ve dilin temelini oluşturur.

**Temel Sözdizimi ve Yapılar:**
ES1, JavaScript'in temel dil yapılarını tanımlar. Bu yapılar, dilin temelini oluşturur ve tüm sonraki versiyonların temelini atar.

**Fonksiyonlar:**
ES1, function declarations ve expressions'ı tanımlar. Bu özellik, JavaScript'in functional programming yeteneklerinin temelini oluşturur.

**Nesneler:**
ES1, object literals ve property access'i tanımlar. Bu özellik, JavaScript'in object-oriented programming yeteneklerinin temelini oluşturur.

**Diziler:**
ES1, array literals ve temel array operations'ı tanımlar. Bu özellik, JavaScript'in veri yapıları yeteneklerinin temelini oluşturur.

**Operatörler:**
ES1, aritmetik, karşılaştırma ve mantıksal operatörleri tanımlar. Bu operatörler, JavaScript'in hesaplama yeteneklerinin temelini oluşturur.

**Kontrol Yapıları:**
ES1, if/else, for, while döngülerini tanımlar. Bu yapılar, JavaScript'in program akışı kontrol yeteneklerinin temelini oluşturur.

**Değişkenler:**
ES1, var anahtar kelimesi ile değişken tanımlamayı tanımlar. Bu özellik, JavaScript'in değişken yönetimi yeteneklerinin temelini oluşturur.

**ES1'in Tarihsel Önemi:**
ES1, JavaScript'in resmi standart haline gelmesini sağlar. Bu standartlaşma, JavaScript'in farklı tarayıcılarda tutarlı çalışmasını sağlar.

**ES2 (1998) - Standartlaşma Geliştirmeleri - Derinlemesine Analiz**

ES2, ES1'deki eksiklikleri giderir ve standartlaşmayı geliştirir. Bu versiyon, JavaScript'in daha güvenilir hale gelmesini sağlar.

**Unicode Desteği:**
ES2, Unicode desteği ekler. Bu özellik, JavaScript'in uluslararası karakterleri desteklemesini sağlar.

**Strict Mode Öncesi Hazırlıklar:**
ES2, gelecekteki strict mode için altyapı hazırlar. Bu hazırlık, JavaScript'in daha güvenli hale gelmesini sağlar.

**Minor Bug Fixes:**
ES2, ES1'deki küçük hataları düzeltir. Bu düzeltmeler, JavaScript'in daha güvenilir hale gelmesini sağlar.

**Specification Clarifications:**
ES2, spesifikasyon açıklamalarını netleştirir. Bu netleştirme, JavaScript'in daha anlaşılır hale gelmesini sağlar.

**ES3 (1999) - Modern JavaScript'in Temeli - Derinlemesine Analiz**

ES3, JavaScript'in modern halinin temelini oluşturur. Bu versiyon, JavaScript'in en önemli özelliklerini ekler.

**Regular Expressions:**
ES3, düzenli ifadeler (`RegExp` objesi) ekler. Bu özellik, JavaScript'in metin işleme yeteneklerini artırır.

**try/catch/finally:**
ES3, hata yakalama ve yönetimi ekler. Bu özellik, JavaScript'in hata yönetimi yeteneklerini artırır.

**ES3'ün Etkisi:**
ES3, JavaScript'in modern web geliştirmede kullanılmasını sağlar. Bu versiyon, JavaScript'in güvenilirliğini artırır.

**ES4 (İptal Edildi) - Öğrenilen Dersler**

ES4, çok büyük değişiklikler içerdiği için iptal edildi. Bu deneyim, JavaScript'in evrim stratejisini değiştirdi.

**ES4'ün Hedefleri:**
ES4, JavaScript'e büyük özellikler eklemeyi hedefliyordu. Ancak bu değişiklikler, geriye uyumluluğu bozuyordu.

**İptal Edilme Nedenleri:**
ES4, çok büyük değişiklikler içeriyordu. Bu değişiklikler, mevcut kod'un çalışmasını engelleyebilirdi.

**Öğrenilen Dersler:**
ES4 deneyimi, JavaScript'in evrim stratejisini değiştirdi. Artık küçük, aşamalı değişiklikler yapılıyor.

**ES5 (2009) - Modern JavaScript'in Başlangıcı - Derinlemesine Analiz**

ES5, JavaScript'in modern halinin başlangıcıdır. Bu versiyon, JavaScript'e önemli özellikler ekler.

**Strict Mode:**
ES5, strict mode ekler. Bu özellik, JavaScript'in daha güvenli hale gelmesini sağlar.

**JSON Support:**
ES5, JSON desteği ekler. Bu özellik, JavaScript'in veri değişimi yeteneklerini artırır.

**Array Methods:**
ES5, forEach, map, filter gibi array method'ları ekler. Bu method'lar, JavaScript'in functional programming yeteneklerini artırır.

**Object Methods:**
ES5, Object.keys, Object.create gibi object method'ları ekler. Bu method'lar, JavaScript'in object manipulation yeteneklerini artırır.

**ES5'in Etkisi:**
ES5, JavaScript'in modern web geliştirmede yaygın kullanılmasını sağlar. Bu versiyon, JavaScript'in güvenilirliğini artırır.

**ES6 (2015) - JavaScript Devrimi - Derinlemesine Analiz**

ES6, JavaScript'te devrim yaratır. Bu versiyon, JavaScript'e modern programlama özelliklerini ekler.

**Arrow Functions:**
ES6, arrow functions ekler. Bu özellik, JavaScript'in functional programming yeteneklerini artırır.

**Classes:**
ES6, class syntax ekler. Bu özellik, JavaScript'in object-oriented programming yeteneklerini artırır.

**Modules:**
ES6, module system ekler. Bu özellik, JavaScript'in kod organizasyonu yeteneklerini artırır.

**Destructuring:**
ES6, destructuring assignment ekler. Bu özellik, JavaScript'in veri manipülasyon yeteneklerini artırır.

**Template Literals:**
ES6, template literals ekler. Bu özellik, JavaScript'in string manipulation yeteneklerini artırır.

**ES6'ın Etkisi:**
ES6, JavaScript'in modern programlama dili haline gelmesini sağlar. Bu versiyon, JavaScript'in popülerliğini artırır.

**ES2016-ES2024 - Sürekli Gelişim - Derinlemesine Analiz**

ES2016'dan ES2024'e kadar olan versiyonlar, JavaScript'in sürekli gelişimini gösterir. Bu versiyonlar, küçük ama önemli özellikler ekler.

**Yıllık Release Cycle:**
Bu versiyonlar, yıllık release cycle'ı benimser. Bu strateji, JavaScript'in sürekli gelişmesini sağlar.

**Feature Additions:**
Bu versiyonlar, async/await, optional chaining, nullish coalescing gibi özellikler ekler. Bu özellikler, JavaScript'in kullanışlılığını artırır.

**Performance Improvements:**
Bu versiyonlar, performans iyileştirmeleri ekler. Bu iyileştirmeler, JavaScript'in hızını artırır.

**JavaScript Versiyonlarının Geleceği:**

JavaScript versiyonlarının geleceği, web'in evrimi ile paralel olarak gelişmektedir. WebAssembly, Progressive Web Apps, ve modern web standartları, JavaScript'in geleceğini şekillendirmektedir.

**ES1 (1997) - Temel Kurulum:**

**ES2 (1998)**:
- **Unicode desteği**: Uluslararası karakter desteği
- **Strict mode öncesi hazırlıklar**: Gelecekteki strict mode için altyapı
- **Minor bug fixes**: ES1'deki küçük hataların düzeltilmesi
- **Specification clarifications**: Spesifikasyon açıklamaları

**ES3 (1999)**:
- **Regular Expressions**: Düzenli ifadeler (`RegExp` objesi)
- **try/catch/finally**: Hata yakalama ve yönetimi
- **String methods**: `split()`, `replace()`, `search()` gibi metodlar
- **Array methods**: `push()`, `pop()`, `shift()`, `unshift()` gibi metodlar
- **Object methods**: `hasOwnProperty()`, `isPrototypeOf()` gibi metodlar
- **JSON support**: JSON formatı desteği (sonradan ES5'te standartlaştırıldı)

**ES4 (İptal Edildi - 2008)**:
- **Classes**: Sınıf tabanlı OOP desteği
- **Packages**: Modül sistemi
- **Namespaces**: İsim alanları
- **Optional static typing**: Opsiyonel statik tip sistemi
- **Generators**: Generator fonksiyonları
- **Iterators**: Iterator protokolü
- **Destructuring**: Destructuring assignment
- **Default parameters**: Varsayılan parametreler
- **Rest parameters**: Rest parametreler
- **Spread operator**: Spread operatörü
- **İptal nedeni**: Microsoft ve diğer tarayıcı üreticileri arasındaki anlaşmazlık

**ES5 (2009)**:
- Strict mode tanıtıldı
- JSON desteği eklendi
- `forEach`, `map`, `filter`, `reduce` gibi dizi metodları eklendi
- `Object.defineProperty` ile nesne özellikleri üzerinde daha fazla kontrol sağlandı
- Getter ve setter fonksiyonları tanıtıldı
- `Function.prototype.bind` metodu eklendi

**ES6/ES2015 (2015)**:
- Arrow fonksiyonları (`=>`) eklendi
- Sınıflar (Classes) tanıtıldı
- Modüller (import/export) desteği sağlandı
- Template literals (şablon dizgileri) eklendi
- Destructuring assignment (yapı sökme ataması) tanıtıldı
- Varsayılan parametreler ve rest/spread operatörleri eklendi
- Promises yapısı tanıtıldı
- `let` ve `const` anahtar kelimeleri eklendi
- `Symbol` veri tipi tanıtıldı
- `Map` ve `Set` veri yapıları eklendi
- `WeakMap` ve `WeakSet` tanıtıldı
- Proxy ve Reflect API'leri eklendi
- Generator fonksiyonları ve iteratörler tanıtıldı

**ES2016**:
- `Array.prototype.includes` metodu eklendi
- Üs alma operatörü (`**`) tanıtıldı

**ES2017**:
- `async/await` yapısı eklendi
- `Object.values` ve `Object.entries` metodları tanıtıldı
- String padding (`padStart`, `padEnd`) metodları eklendi
- `SharedArrayBuffer` ve `Atomics` API'leri tanıtıldı

**ES2018**:
- Rest/spread özellikleri nesneler için genişletildi
- Asenkron iterasyon (`for await...of`) tanıtıldı
- `Promise.prototype.finally` metodu eklendi
- Düzenli ifadeler için iyileştirmeler yapıldı

**ES2019**:
- `Array.prototype.flat` ve `Array.prototype.flatMap` metodları eklendi
- `Object.fromEntries` metodu tanıtıldı
- String trim metodları (`trimStart`, `trimEnd`) eklendi
- Opsiyonel catch bağlama özelliği eklendi
- `Symbol.prototype.description` özelliği tanıtıldı

**ES2020**:
- `BigInt` veri tipi eklendi
- Dinamik import (`import()`) desteği sağlandı
- Nullish coalescing operatörü (`??`) tanıtıldı
- Opsiyonel zincirleme operatörü (`?.`) eklendi
- `globalThis` nesnesi tanıtıldı
- `Promise.allSettled` metodu eklendi
- `String.prototype.matchAll` metodu tanıtıldı

**ES2021**:
- Mantıksal atama operatörleri (`&&=`, `||=`, `??=`) eklendi
- Sayısal ayırıcılar (Numeric separators) tanıtıldı
- `Promise.any` metodu eklendi
- `String.prototype.replaceAll` metodu tanıtıldı
- `WeakRef` ve `FinalizationRegistry` API'leri eklendi

**ES2022**:
- Üst düzey `await` (Top-level await) desteği sağlandı
- Özel sınıf alanları (Private class fields) tanıtıldı
- Statik sınıf alanları ve blokları eklendi
- `Array.prototype.at` metodu tanıtıldı
- `Object.hasOwn` metodu eklendi
- Düzenli ifadeler için eşleşme indeksleri (match indices) desteği sağlandı

**ES2023**:
- `Array.prototype.findLast` ve `Array.prototype.findLastIndex` metodları eklendi
- Hashbang (`#!`) sözdizimi tanıtıldı
- `WeakMap` anahtarları olarak `Symbol` desteği eklendi

**ES2024**:
- `Array.prototype.group` ve `Array.prototype.groupToMap` metodları eklendi
- `Object.groupBy` ve `Map.groupBy` metodları tanıtıldı
- `Promise.withResolvers` metodu eklendi
- Temporal API (experimental) tanıtıldı

**ES2025 (Stabil)**:
- **Temporal API**: Modern tarih ve zaman işlemleri
- **Records ve Tuples**: Immutable veri yapıları
- **Pipeline Operator (`|>`)**: Fonksiyonel programlama operatörü
- **Throw Expressions**: Expression context'te hata fırlatma
- **Pattern Matching**: Veri yapısı eşleştirme
- **Array Grouping**: `Array.prototype.group` ve `Array.prototype.groupToMap`
- **Promise.withResolvers**: Promise resolver'ları oluşturma

**ES2026 (Planlanan)**:
- **Decorators (Stage 3)**: Sınıf ve metod dekoratörleri
- **Import Attributes**: Import meta verileri
- **JSON Modules**: JSON dosyalarını modül olarak import etme
- **Top-level await in modules**: Modül seviyesinde await
- **Class Fields**: Private ve public sınıf alanları
- **Static Class Blocks**: Sınıf statik blokları

### 1.3 JavaScript Temel Kavramlar - Detaylı Analiz

JavaScript temel kavramları, modern programlamanın temelini oluşturur. Bu kavramlar, sadece syntax öğrenmek değil, aynı zamanda JavaScript'in felsefesini ve tasarım prensiplerini anlamak için kritik öneme sahiptir. JavaScript'in temel kavramları, functional programming, object-oriented programming ve modern JavaScript özelliklerini harmanlayarak, güçlü ve esnek bir programlama deneyimi sunar.

**JavaScript Temel Kavramlarının Felsefesi:**

JavaScript'in temel kavramları, "dynamic typing" ve "prototype-based programming" prensiplerini benimser. Bu prensipler, JavaScript'i diğer programlama dillerinden ayıran temel özelliklerini oluşturur. Bu yaklaşım, kod yazmayı kolaylaştırır ve esnekliği artırır.

**JavaScript Temel Kavramlarının Kategorileri:**

**Data Types (Veri Tipleri):**
Veri tipleri, JavaScript'in veri yapılarını tanımlar. Bu tipler, primitive types ve reference types olarak ikiye ayrılır.

**Variables (Değişkenler):**
Değişkenler, veri saklama ve yönetimi sağlar. JavaScript'te var, let, const gibi farklı değişken tanımlama yöntemleri vardır.

**Functions (Fonksiyonlar):**
Fonksiyonlar, kod organizasyonu ve yeniden kullanılabilirlik sağlar. JavaScript'te first-class functions, closures ve higher-order functions gibi özellikler vardır.

**Objects (Nesneler):**
Nesneler, karmaşık veri yapılarını temsil eder. JavaScript'te prototype-based inheritance, object literals ve property descriptors gibi özellikler vardır.

**Control Flow (Kontrol Akışı):**
Kontrol akışı, program akışını yönetir. JavaScript'te if/else, loops, switch gibi kontrol yapıları vardır.

**Data Types - Derinlemesine Analiz:**

**Primitive Types (İlkel Tipler):**
İlkel tipler, JavaScript'in temel veri tiplerini temsil eder. Bu tipler, değer olarak saklanır ve immutable özelliğe sahiptir.

**Reference Types (Referans Tipleri):**
Referans tipleri, karmaşık veri yapılarını temsil eder. Bu tipler, referans olarak saklanır ve mutable özelliğe sahiptir.

**Type Coercion (Tip Dönüşümü):**
Tip dönüşümü, JavaScript'in otomatik tip dönüştürme özelliğidir. Bu özellik, esneklik sağlar ancak dikkatli kullanılmalıdır.

**Variables - Derinlemesine Analiz:**

**Variable Declaration (Değişken Tanımlama):**
JavaScript'te var, let, const gibi farklı değişken tanımlama yöntemleri vardır. Her yöntem, farklı scope ve hoisting davranışları sergiler.

**Hoisting (Yükseltme):**
Hoisting, değişken ve fonksiyon tanımlamalarının scope'un başına taşınması özelliğidir. Bu özellik, JavaScript'in çalışma şeklini etkiler.

**Scope (Kapsam):**
Scope, değişkenlerin erişilebilir olduğu alanı tanımlar. JavaScript'te global, function, block scope gibi farklı scope türleri vardır.

**Functions - Derinlemesine Analiz:**

**Function Declaration vs Expression:**
JavaScript'te fonksiyon tanımlama ve ifade etme farklı yöntemlerdir. Bu yöntemler, farklı hoisting davranışları sergiler.

**Closures (Kapanışlar):**
Closures, fonksiyonların dış scope'daki değişkenlere erişim sağlama özelliğidir. Bu özellik, JavaScript'in en güçlü özelliklerinden biridir.

**Higher-Order Functions:**
Higher-order functions, fonksiyonları parametre olarak alan veya fonksiyon döndüren fonksiyonlardır. Bu özellik, functional programming'i destekler.

**Objects - Derinlemesine Analiz:**

**Object Literals:**
Object literals, nesne oluşturmanın en basit yöntemidir. Bu yöntem, hızlı nesne oluşturma sağlar.

**Prototype Chain:**
Prototype chain, nesneler arası miras ilişkisini yönetir. Bu zincir, JavaScript'in inheritance sisteminin temelini oluşturur.

**Property Descriptors:**
Property descriptors, nesne özelliklerinin davranışını kontrol eder. Bu özellik, nesne özelliklerini özelleştirmeyi sağlar.

**Control Flow - Derinlemesine Analiz:**

**Conditional Statements:**
Conditional statements, program akışını koşullara göre yönetir. JavaScript'te if/else, switch gibi yapılar vardır.

**Loops:**
Loops, tekrarlayan işlemleri yönetir. JavaScript'te for, while, do-while gibi döngü türleri vardır.

**Error Handling:**
Error handling, hata yönetimi sağlar. JavaScript'te try/catch/finally yapısı vardır.

**JavaScript Temel Kavramlarının Avantajları:**

**Flexibility:**
JavaScript'in temel kavramları, esneklik sağlar. Dynamic typing ve prototype-based programming, hızlı geliştirme sağlar.

**Simplicity:**
JavaScript'in temel kavramları, basitlik sağlar. Syntax, öğrenmesi kolay ve anlaşılır.

**Power:**
JavaScript'in temel kavramları, güç sağlar. Closures, higher-order functions gibi özellikler, karmaşık programlama pattern'lerini destekler.

**Compatibility:**
JavaScript'in temel kavramları, uyumluluk sağlar. Farklı tarayıcılarda tutarlı çalışır.

**JavaScript Temel Kavramlarının Kullanım Senaryoları:**

**Web Development:**
JavaScript'in temel kavramları, web geliştirme için idealdir. DOM manipülasyonu, event handling gibi özellikler sağlar.

**Server Development:**
JavaScript'in temel kavramları, server geliştirme için idealdir. Node.js ile backend geliştirme sağlar.

**Mobile Development:**
JavaScript'in temel kavramları, mobil geliştirme için idealdir. React Native, Ionic gibi framework'ler ile cross-platform geliştirme sağlar.

**Desktop Development:**
JavaScript'in temel kavramları, masaüstü geliştirme için idealdir. Electron ile desktop uygulama geliştirme sağlar.

#### 1.3.1 Değişkenler ve Veri Tipleri - Derinlemesine Analiz

Değişkenler ve veri tipleri, JavaScript'in temel yapı taşlarıdır. Bu kavramlar, veri saklama, yönetimi ve manipülasyonu için kritik öneme sahiptir. JavaScript'in dinamik tip sistemi, esneklik sağlar ancak dikkatli kullanılmalıdır.

**Primitive Types (İlkel Tipler) - Derinlemesine Analiz:**

JavaScript'te 7 tane primitive (ilkel) tip bulunur. Bu tipler değer olarak saklanır ve immutable (değiştirilemez) özelliğe sahiptir. Bu tipler, JavaScript'in temel veri yapılarını oluşturur.

**Number (Sayı)**:
```javascript
let age = 25;           // Tam sayı
let price = 99.99;      // Ondalıklı sayı
let infinity = Infinity; // Sonsuzluk
let notANumber = NaN;   // Sayı değil

// Number metodları
console.log(Number.isInteger(25)); // true
console.log(Number.parseFloat("3.14")); // 3.14
console.log(Number.parseInt("123")); // 123
```

Number tipi IEEE 754 double precision floating point standardını kullanır. Bu nedenle:
- Maksimum güvenli tam sayı: `Number.MAX_SAFE_INTEGER` (2^53 - 1)
- Minimum güvenli tam sayı: `Number.MIN_SAFE_INTEGER` (-2^53 + 1)
- Büyük sayılar için `BigInt` kullanılmalıdır

**String (Dizi)**:
```javascript
let name = "John";           // Çift tırnak
let surname = 'Doe';         // Tek tırnak
let template = `Hello ${name}`; // Template literal

// String metodları
console.log(name.length); // 4
console.log(name.toUpperCase()); // "JOHN"
console.log(name.includes("oh")); // true
```

String'ler immutable'dır. Bir string oluşturulduktan sonra değiştirilemez, sadece yeni string'ler oluşturulabilir.

**Boolean (Mantıksal)**:
```javascript
let isActive = true;
let isCompleted = false;

// Truthy ve Falsy değerler
console.log(Boolean("")); // false
console.log(Boolean(0)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(NaN)); // false
```

Boolean tipi sadece `true` ve `false` değerlerini alır. JavaScript'te falsy değerler: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`

**Undefined**:
```javascript
let x; // undefined
let y = undefined; // explicit undefined

console.log(typeof x); // "undefined"
```

Undefined, bir değişkenin tanımlandığı ama değer atanmadığı durumu temsil eder.

**Null**:
```javascript
let data = null; // Boş değer
console.log(typeof null); // "object" (bu bir bug'dır)
```

Null, kasıtlı olarak boş değer atandığını gösterir.

**Symbol (Sembol)**:
```javascript
let id = Symbol('id');
let id2 = Symbol('id');
console.log(id === id2); // false - her symbol benzersizdir

// Global symbol registry
let globalId = Symbol.for('globalId');
let sameGlobalId = Symbol.for('globalId');
console.log(globalId === sameGlobalId); // true
```

Symbol'ler ES6 ile geldi ve benzersiz tanımlayıcılar oluşturmak için kullanılır.

**BigInt (Büyük Tam Sayı)**:
```javascript
let bigNumber = 123456789012345678901234567890n;
let anotherBig = BigInt("123456789012345678901234567890");

console.log(bigNumber + 1n); // 123456789012345678901234567891n
```

BigInt, Number.MAX_SAFE_INTEGER'dan büyük tam sayıları temsil etmek için kullanılır.

**Reference Types (Referans Tipleri)**:

**Object (Nesne)**:
```javascript
let person = {
    name: "John",
    age: 30,
    greet: function() {
        return `Hello, I'm ${this.name}`;
    }
};

// Object metodları
console.log(Object.keys(person)); // ["name", "age", "greet"]
console.log(Object.values(person)); // ["John", 30, function]
console.log(Object.entries(person)); // [["name", "John"], ["age", 30], ["greet", function]]
```

Object'ler key-value çiftleri içerir. JavaScript'te neredeyse her şey object'tir (primitive'ler hariç).

**Array (Dizi)**:
```javascript
let fruits = ["apple", "banana", "orange"];
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "hello", true, {name: "John"}];

// Array metodları
fruits.push("grape"); // ["apple", "banana", "orange", "grape"]
fruits.pop(); // ["apple", "banana", "orange"]
fruits.map(fruit => fruit.toUpperCase()); // ["APPLE", "BANANA", "ORANGE"]
```

Array'ler sıralı veri koleksiyonlarıdır. JavaScript'te array'ler aslında object'lerdir.

**Function (Fonksiyon)**:
```javascript
function greet(name) {
    return `Hello, ${name}!`;
}

let greetArrow = (name) => `Hello, ${name}!`;

// Function properties
console.log(greet.length); // 1 (parameter sayısı)
console.log(greet.name); // "greet"
```

Fonksiyonlar JavaScript'te first-class citizen'dır. Değişkenlere atanabilir, parametre olarak geçilebilir ve döndürülebilir.

**Type Coercion (Tip Dönüşümü)**:

JavaScript'te farklı tipler arasında otomatik dönüşüm yapılır:

```javascript
// Implicit coercion
console.log("5" + 3); // "53" (string concatenation)
console.log("5" - 3); // 2 (number subtraction)
console.log("5" * 3); // 15 (number multiplication)
console.log("5" / 3); // 1.6666666666666667 (number division)

// Explicit coercion
console.log(Number("123")); // 123
console.log(String(123)); // "123"
console.log(Boolean(1)); // true
```

**Hoisting (Yükseltme)**:

Hoisting, JavaScript'in değişken ve fonksiyon tanımlamalarını scope'un başına taşımasıdır.

```javascript
// Var hoisting
console.log(x); // undefined (hata vermez)
var x = 5;
console.log(x); // 5

// Let ve const hoisting (Temporal Dead Zone)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;

// Function hoisting
sayHello(); // "Hello!" - fonksiyon hoisted olur
function sayHello() {
    console.log("Hello!");
}
```

**Temporal Dead Zone (Geçici Ölü Bölge)**:

`let` ve `const` ile tanımlanan değişkenler, tanımlanmadan önce erişilemez:

```javascript
// Temporal Dead Zone
console.log(typeof z); // ReferenceError
let z = 10;

// Bu durum var ile olmaz
console.log(typeof w); // "undefined"
var w = 10;
```

#### 1.3.2 Fonksiyonlar

**Function Declarations (Fonksiyon Tanımlamaları)**:

Function declaration'lar `function` anahtar kelimesiyle tanımlanır ve hoisted olur:

```javascript
// Function declaration
function greet(name) {
    return `Hello, ${name}!`;
}

// Hoisted olduğu için burada çağrılabilir
console.log(greet("John")); // "Hello, John!"

// Function declaration'lar named function'dır
console.log(greet.name); // "greet"
console.log(greet.length); // 1 (parameter sayısı)
```

**Function Expressions (Fonksiyon İfadeleri)**:

Function expression'lar değişkenlere atanabilen anonim fonksiyonlardır:

```javascript
// Function expression
let greet = function(name) {
    return `Hello, ${name}!`;
};

// Hoisted olmadığı için burada çağrılamaz
// console.log(greet("John")); // ReferenceError

// Aşağıda çağrılabilir
console.log(greet("John")); // "Hello, John!"

// Named function expression
let greetNamed = function sayHello(name) {
    return `Hello, ${name}!`;
};
```

**Arrow Functions (Ok Fonksiyonları)**:

ES6 ile gelen arrow function'lar daha kısa sözdizimi sağlar:

```javascript
// Geleneksel function
function add(a, b) {
    return a + b;
}

// Arrow function
let addArrow = (a, b) => a + b;

// Tek parametre için parantez opsiyonel
let square = x => x * x;

// Parametre yoksa parantez gerekli
let sayHello = () => "Hello!";

// Çok satırlı arrow function
let processData = (data) => {
    let result = data.map(item => item * 2);
    return result.filter(item => item > 10);
};
```

**Arrow Function'ların `this` Bağlamı**:

Arrow function'lar kendi `this` bağlamına sahip değildir, lexical `this` kullanır:

```javascript
let obj = {
    name: "John",
    traditionalFunction: function() {
        console.log(this.name); // "John"
    },
    arrowFunction: () => {
        console.log(this.name); // undefined (global scope)
    }
};

obj.traditionalFunction(); // "John"
obj.arrowFunction(); // undefined
```

**IIFE (Immediately Invoked Function Expression)**:

IIFE, tanımlandığı anda çalışan fonksiyonlardır:

```javascript
// IIFE syntax
(function() {
    console.log("IIFE çalıştı!");
})();

// IIFE with parameters
(function(name) {
    console.log(`Hello, ${name}!`);
})("John");

// IIFE with return value
let result = (function(a, b) {
    return a + b;
})(5, 3);
console.log(result); // 8

// IIFE for module pattern
let myModule = (function() {
    let privateVariable = 0;
    
    return {
        increment: function() {
            privateVariable++;
        },
        getValue: function() {
            return privateVariable;
        }
    };
})();
```

**Higher-Order Functions (Yüksek Dereceli Fonksiyonlar)**:

Higher-order function'lar başka fonksiyonları parametre olarak alan veya döndüren fonksiyonlardır:

```javascript
// Function as parameter
function processArray(array, processor) {
    return array.map(processor);
}

let numbers = [1, 2, 3, 4, 5];
let doubled = processArray(numbers, x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// Function as return value
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

let multiplyBy3 = createMultiplier(3);
console.log(multiplyBy3(5)); // 15

// Built-in higher-order functions
let numbers2 = [1, 2, 3, 4, 5];

// map - transform each element
let squares = numbers2.map(x => x * x);
console.log(squares); // [1, 4, 9, 16, 25]

// filter - select elements
let evens = numbers2.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]

// reduce - accumulate values
let sum = numbers2.reduce((acc, x) => acc + x, 0);
console.log(sum); // 15

// forEach - iterate over elements
numbers2.forEach(x => console.log(x)); // 1, 2, 3, 4, 5
```

**Closures (Kapanışlar)**:

Closure, bir fonksiyonun kendi scope'u dışındaki değişkenlere erişebilmesidir:

```javascript
// Temel closure örneği
function outerFunction(x) {
    // Dış fonksiyon
    return function innerFunction(y) {
        // İç fonksiyon, dış fonksiyonun parametresine erişebilir
        return x + y;
    };
}

let addFive = outerFunction(5);
console.log(addFive(3)); // 8

// Private variable örneği
function createCounter() {
    let count = 0; // Private variable
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

let counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
// console.log(counter.count); // undefined - count'a doğrudan erişilemez

// Module pattern with closure
let myModule = (function() {
    let privateVariable = 0;
    
    function privateFunction() {
        return privateVariable;
    }
    
    return {
        publicMethod: function() {
            return privateFunction();
        },
        increment: function() {
            privateVariable++;
        }
    };
})();

// Closure in event handlers
function createButtonHandler(buttonId) {
    return function() {
        console.log(`Button ${buttonId} clicked!`);
    };
}

// Her button için farklı handler
let button1Handler = createButtonHandler(1);
let button2Handler = createButtonHandler(2);
```

**Function Parameters (Fonksiyon Parametreleri)**:

```javascript
// Default parameters
function greet(name = "Guest") {
    return `Hello, ${name}!`;
}

console.log(greet()); // "Hello, Guest!"
console.log(greet("John")); // "Hello, John!"

// Rest parameters
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Destructuring parameters
function displayUser({name, age, email}) {
    console.log(`Name: ${name}, Age: ${age}, Email: ${email}`);
}

let user = {name: "John", age: 30, email: "john@example.com"};
displayUser(user); // Name: John, Age: 30, Email: john@example.com
```

#### 1.3.3 Nesneler ve Diziler

**Nesne Literalleri (Object Literals)**:

JavaScript'te nesneler `{ key: value }` şeklinde tanımlanır:

```javascript
// Temel nesne tanımı
let person = {
    name: "John",
    age: 30,
    city: "New York"
};

// Nesne özelliklerine erişim
console.log(person.name); // "John"
console.log(person["age"]); // 30

// Nesne özelliklerini değiştirme
person.age = 31;
person["city"] = "Boston";

// Yeni özellik ekleme
person.email = "john@example.com";
person["phone"] = "123-456-7890";

// Nesne metodları
let calculator = {
    add: function(a, b) {
        return a + b;
    },
    subtract(a, b) { // ES6 shorthand
        return a - b;
    },
    multiply: (a, b) => a * b // Arrow function
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.subtract(5, 3)); // 2
console.log(calculator.multiply(5, 3)); // 15
```

**Nesne Metodları**:

```javascript
let user = {
    firstName: "John",
    lastName: "Doe",
    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    },
    setFullName(fullName) {
        [this.firstName, this.lastName] = fullName.split(' ');
    }
};

console.log(user.getFullName()); // "John Doe"
user.setFullName("Jane Smith");
console.log(user.getFullName()); // "Jane Smith"

// Object.keys(), Object.values(), Object.entries()
let obj = {a: 1, b: 2, c: 3};
console.log(Object.keys(obj)); // ["a", "b", "c"]
console.log(Object.values(obj)); // [1, 2, 3]
console.log(Object.entries(obj)); // [["a", 1], ["b", 2], ["c", 3]]

// Object.assign() - nesne kopyalama
let target = {a: 1, b: 2};
let source = {b: 3, c: 4};
let result = Object.assign(target, source);
console.log(result); // {a: 1, b: 3, c: 4}

// Object.freeze() - nesneyi dondurma
let frozen = Object.freeze({x: 1, y: 2});
// frozen.x = 3; // TypeError: Cannot assign to read only property
```

**Dizi Metodları**:

```javascript
let fruits = ["apple", "banana", "orange"];

// Mutating methods (diziyi değiştirir)
fruits.push("grape"); // ["apple", "banana", "orange", "grape"]
fruits.pop(); // ["apple", "banana", "orange"]
fruits.unshift("kiwi"); // ["kiwi", "apple", "banana", "orange"]
fruits.shift(); // ["apple", "banana", "orange"]

// Non-mutating methods (diziyi değiştirmez)
let numbers = [1, 2, 3, 4, 5];

// map - her elemanı dönüştür
let doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter - elemanları filtrele
let evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]

// reduce - değerleri birleştir
let sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 15

// forEach - her eleman için işlem yap
numbers.forEach(x => console.log(x)); // 1, 2, 3, 4, 5

// find - ilk eşleşen elemanı bul
let found = numbers.find(x => x > 3);
console.log(found); // 4

// findIndex - ilk eşleşen elemanın indexini bul
let index = numbers.findIndex(x => x > 3);
console.log(index); // 3

// some - herhangi bir eleman koşulu sağlıyor mu
let hasEven = numbers.some(x => x % 2 === 0);
console.log(hasEven); // true

// every - tüm elemanlar koşulu sağlıyor mu
let allPositive = numbers.every(x => x > 0);
console.log(allPositive); // true

// slice - dizinin bir kısmını al
let sliced = numbers.slice(1, 4);
console.log(sliced); // [2, 3, 4]

// splice - diziden eleman çıkar/ekle
let spliced = [1, 2, 3, 4, 5];
spliced.splice(2, 1, 'a', 'b'); // index 2'den 1 eleman çıkar, 'a' ve 'b' ekle
console.log(spliced); // [1, 2, 'a', 'b', 4, 5]
```

**Destructuring Assignment (Yapı Sökme)**:

```javascript
// Array destructuring
let colors = ["red", "green", "blue"];
let [first, second, third] = colors;
console.log(first, second, third); // "red", "green", "blue"

// Default values
let [a, b, c = "default"] = ["x", "y"];
console.log(a, b, c); // "x", "y", "default"

// Skip elements
let [firstColor, , thirdColor] = colors;
console.log(firstColor, thirdColor); // "red", "blue"

// Rest operator
let [primary, ...others] = colors;
console.log(primary); // "red"
console.log(others); // ["green", "blue"]

// Object destructuring
let person = {name: "John", age: 30, city: "New York"};
let {name, age, city} = person;
console.log(name, age, city); // "John", 30, "New York"

// Rename variables
let {name: fullName, age: years} = person;
console.log(fullName, years); // "John", 30

// Default values
let {name: userName, country = "USA"} = person;
console.log(userName, country); // "John", "USA"

// Nested destructuring
let user = {
    name: "John",
    address: {
        street: "123 Main St",
        city: "New York"
    }
};
let {name, address: {street, city}} = user;
console.log(name, street, city); // "John", "123 Main St", "New York"

// Function parameter destructuring
function greet({name, age}) {
    return `Hello ${name}, you are ${age} years old`;
}
console.log(greet(person)); // "Hello John, you are 30 years old"
```

**Spread ve Rest Operatörleri**:

```javascript
// Spread operator (...) - dizileri ve nesneleri genişletme

// Array spread
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Array copy
let original = [1, 2, 3];
let copy = [...original];
copy.push(4);
console.log(original); // [1, 2, 3]
console.log(copy); // [1, 2, 3, 4]

// Object spread
let obj1 = {a: 1, b: 2};
let obj2 = {c: 3, d: 4};
let merged = {...obj1, ...obj2};
console.log(merged); // {a: 1, b: 2, c: 3, d: 4}

// Object copy
let originalObj = {x: 1, y: 2};
let copyObj = {...originalObj};
copyObj.z = 3;
console.log(originalObj); // {x: 1, y: 2}
console.log(copyObj); // {x: 1, y: 2, z: 3}

// Function calls with spread
function sum(a, b, c) {
    return a + b + c;
}
let numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6

// Rest operator - parametreleri toplama

// Function parameters
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3, 4, 5)); // 15

// Array destructuring
let [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first, second, rest); // 1, 2, [3, 4, 5]

// Object destructuring
let {name, ...otherProps} = {name: "John", age: 30, city: "NYC"};
console.log(name, otherProps); // "John", {age: 30, city: "NYC"}
```

**Array ve Object Advanced Methods**:

```javascript
// Array methods
let data = [
    {name: "John", age: 30, city: "NYC"},
    {name: "Jane", age: 25, city: "LA"},
    {name: "Bob", age: 35, city: "NYC"}
];

// Chaining methods
let result = data
    .filter(person => person.age > 25)
    .map(person => person.name)
    .sort();
console.log(result); // ["Bob", "John"]

// flat() - nested arrays'i düzleştir
let nested = [1, [2, 3], [4, [5, 6]]];
let flattened = nested.flat(2);
console.log(flattened); // [1, 2, 3, 4, 5, 6]

// flatMap() - map + flat
let words = ["hello world", "good morning"];
let letters = words.flatMap(word => word.split(' '));
console.log(letters); // ["hello", "world", "good", "morning"]

// Object methods
let obj = {a: 1, b: 2, c: 3};

// Object.fromEntries() - array'i object'e çevir
let entries = [["a", 1], ["b", 2]];
let objFromEntries = Object.fromEntries(entries);
console.log(objFromEntries); // {a: 1, b: 2}

// Object.hasOwnProperty() - özellik kontrolü
console.log(obj.hasOwnProperty("a")); // true
console.log(obj.hasOwnProperty("d")); // false

// Object.is() - değer karşılaştırması
console.log(Object.is(NaN, NaN)); // true
console.log(NaN === NaN); // false
```

#### 1.3.4 Asenkron Programlama

JavaScript single-threaded bir dildir, ancak asenkron işlemleri destekler. Bu, JavaScript'in en önemli özelliklerinden biridir.

**Callbacks (Geri Çağırma Fonksiyonları)**:

Callback'ler, bir işlem tamamlandığında çağrılan fonksiyonlardır:

```javascript
// Temel callback örneği
function fetchData(callback) {
    setTimeout(() => {
        callback("Data loaded!");
    }, 1000);
}

fetchData((data) => {
    console.log(data); // "Data loaded!" (1 saniye sonra)
});

// Callback hell örneği
function step1(callback) {
    setTimeout(() => {
        console.log("Step 1 completed");
        callback();
    }, 1000);
}

function step2(callback) {
    setTimeout(() => {
        console.log("Step 2 completed");
        callback();
    }, 1000);
}

function step3(callback) {
    setTimeout(() => {
        console.log("Step 3 completed");
        callback();
    }, 1000);
}

// Callback hell - iç içe callback'ler
step1(() => {
    step2(() => {
        step3(() => {
            console.log("All steps completed");
        });
    });
});
```

**Promises (Sözler)**:

Promise'ler ES6 ile geldi ve callback hell problemini çözer:

```javascript
// Promise oluşturma
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        let success = true;
        if (success) {
            resolve("Operation successful!");
        } else {
            reject("Operation failed!");
        }
    }, 1000);
});

// Promise kullanma
promise
    .then(result => {
        console.log(result); // "Operation successful!"
    })
    .catch(error => {
        console.error(error); // "Operation failed!"
    })
    .finally(() => {
        console.log("Promise completed");
    });

// Promise chaining
function fetchUser(id) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({id: id, name: "John"});
        }, 1000);
    });
}

function fetchPosts(userId) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve([{id: 1, title: "Post 1"}, {id: 2, title: "Post 2"}]);
        }, 1000);
    });
}

fetchUser(1)
    .then(user => {
        console.log("User:", user);
        return fetchPosts(user.id);
    })
    .then(posts => {
        console.log("Posts:", posts);
    })
    .catch(error => {
        console.error("Error:", error);
    });

// Promise.all - birden fazla promise'i paralel çalıştır
let promise1 = fetchUser(1);
let promise2 = fetchUser(2);
let promise3 = fetchUser(3);

Promise.all([promise1, promise2, promise3])
    .then(users => {
        console.log("All users:", users);
    })
    .catch(error => {
        console.error("One or more promises failed:", error);
    });

// Promise.race - ilk tamamlanan promise'i al
Promise.race([promise1, promise2, promise3])
    .then(firstUser => {
        console.log("First user loaded:", firstUser);
    });

// Promise.allSettled - tüm promise'lerin sonucunu al
Promise.allSettled([promise1, promise2, promise3])
    .then(results => {
        results.forEach((result, index) => {
            if (result.status === 'fulfilled') {
                console.log(`Promise ${index + 1} succeeded:`, result.value);
            } else {
                console.log(`Promise ${index + 1} failed:`, result.reason);
            }
        });
    });
```

**Async/Await**:

Async/await ES2017 ile geldi ve Promise'leri daha okunabilir hale getirir:

```javascript
// Async function tanımı
async function fetchData() {
    try {
        let user = await fetchUser(1);
        console.log("User:", user);
        
        let posts = await fetchPosts(user.id);
        console.log("Posts:", posts);
        
        return {user, posts};
    } catch (error) {
        console.error("Error:", error);
        throw error;
    }
}

// Async function kullanımı
fetchData()
    .then(result => {
        console.log("Final result:", result);
    })
    .catch(error => {
        console.error("Final error:", error);
    });

// Paralel async/await
async function fetchAllData() {
    try {
        // Paralel çalıştır
        let [user1, user2, user3] = await Promise.all([
            fetchUser(1),
            fetchUser(2),
            fetchUser(3)
        ]);
        
        console.log("All users:", user1, user2, user3);
    } catch (error) {
        console.error("Error:", error);
    }
}

// Async arrow function
let fetchDataArrow = async () => {
    let user = await fetchUser(1);
    return user;
};

// Async class method
class DataService {
    async getUser(id) {
        return await fetchUser(id);
    }
    
    async getAllUsers() {
        let users = await Promise.all([
            this.getUser(1),
            this.getUser(2),
            this.getUser(3)
        ]);
        return users;
    }
}
```

**Event Loop (Olay Döngüsü)**:

JavaScript'in asenkron işlemleri nasıl yönettiğini açıklayan mekanizma:

```javascript
// Event loop örneği
console.log("1. Start");

setTimeout(() => {
    console.log("2. Timeout 1");
}, 0);

Promise.resolve().then(() => {
    console.log("3. Promise 1");
});

setTimeout(() => {
    console.log("4. Timeout 2");
}, 0);

Promise.resolve().then(() => {
    console.log("5. Promise 2");
});

console.log("6. End");

// Çıktı:
// 1. Start
// 6. End
// 3. Promise 1
// 5. Promise 2
// 2. Timeout 1
// 4. Timeout 2
```

**Event Loop Açıklaması**:

1. **Call Stack**: Senkron kodlar burada çalışır
2. **Web APIs**: setTimeout, fetch gibi asenkron işlemler
3. **Task Queue**: setTimeout callback'leri burada bekler
4. **Microtask Queue**: Promise callback'leri burada bekler
5. **Event Loop**: Call stack boş olduğunda queue'lerden işlemleri alır

**Microtask vs Macrotask**:

```javascript
console.log("1. Start");

// Macrotask (Task Queue)
setTimeout(() => console.log("2. Macrotask"), 0);

// Microtask (Microtask Queue)
Promise.resolve().then(() => console.log("3. Microtask"));

// Macrotask
setTimeout(() => console.log("4. Macrotask"), 0);

// Microtask
Promise.resolve().then(() => console.log("5. Microtask"));

console.log("6. End");

// Çıktı:
// 1. Start
// 6. End
// 3. Microtask
// 5. Microtask
// 2. Macrotask
// 4. Macrotask
```

**Async/Await Error Handling**:

```javascript
// Try-catch ile hata yönetimi
async function fetchDataWithErrorHandling() {
    try {
        let user = await fetchUser(1);
        let posts = await fetchPosts(user.id);
        return {user, posts};
    } catch (error) {
        console.error("Error occurred:", error);
        // Hata durumunda varsayılan değer döndür
        return {user: null, posts: []};
    }
}

// Promise.catch ile hata yönetimi
async function fetchDataWithCatch() {
    let user = await fetchUser(1).catch(error => {
        console.error("User fetch failed:", error);
        return null;
    });
    
    if (!user) {
        throw new Error("Cannot proceed without user");
    }
    
    let posts = await fetchPosts(user.id);
    return {user, posts};
}

// Multiple async operations with error handling
async function fetchMultipleData() {
    try {
        let [user, posts, comments] = await Promise.allSettled([
            fetchUser(1),
            fetchPosts(1),
            fetchComments(1)
        ]);
        
        return {
            user: user.status === 'fulfilled' ? user.value : null,
            posts: posts.status === 'fulfilled' ? posts.value : [],
            comments: comments.status === 'fulfilled' ? comments.value : []
        };
    } catch (error) {
        console.error("Unexpected error:", error);
        throw error;
    }
}
```

#### 1.3.5 Hata Yönetimi

JavaScript'te hata yönetimi, uygulamaların beklenmeyen durumlarla başa çıkabilmesini sağlar.

**try/catch/finally**:

```javascript
// Temel try-catch
try {
    let result = riskyOperation();
    console.log("Success:", result);
} catch (error) {
    console.error("Error occurred:", error.message);
} finally {
    console.log("This always runs");
}

// Nested try-catch
try {
    try {
        throw new Error("Inner error");
    } catch (innerError) {
        console.log("Inner catch:", innerError.message);
        throw new Error("Outer error");
    }
} catch (outerError) {
    console.log("Outer catch:", outerError.message);
}

// Finally block
function divide(a, b) {
    try {
        if (b === 0) {
            throw new Error("Division by zero");
        }
        return a / b;
    } catch (error) {
        console.error("Division error:", error.message);
        return null;
    } finally {
        console.log("Division operation completed");
    }
}

console.log(divide(10, 2)); // 5
console.log(divide(10, 0)); // null
```

**Throw Statement**:

```javascript
// Temel throw
function validateAge(age) {
    if (age < 0) {
        throw new Error("Age cannot be negative");
    }
    if (age > 150) {
        throw new Error("Age cannot be greater than 150");
    }
    return true;
}

// Custom error class
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = "ValidationError";
        this.field = field;
    }
}

function validateUser(user) {
    if (!user.name) {
        throw new ValidationError("Name is required", "name");
    }
    if (!user.email) {
        throw new ValidationError("Email is required", "email");
    }
    if (!user.email.includes("@")) {
        throw new ValidationError("Invalid email format", "email");
    }
    return true;
}

// Error handling with custom errors
try {
    validateUser({name: "John"});
} catch (error) {
    if (error instanceof ValidationError) {
        console.error(`Validation error in ${error.field}: ${error.message}`);
    } else {
        console.error("Unexpected error:", error.message);
    }
}

// Re-throwing errors
function processData(data) {
    try {
        return JSON.parse(data);
    } catch (error) {
        console.error("Failed to parse JSON:", error.message);
        throw new Error("Data processing failed");
    }
}
```

**Error Nesnesi**:

```javascript
// Error object properties
try {
    throw new Error("Something went wrong");
} catch (error) {
    console.log("Error name:", error.name); // "Error"
    console.log("Error message:", error.message); // "Something went wrong"
    console.log("Error stack:", error.stack); // Stack trace
}

// Built-in error types
try {
    // ReferenceError
    console.log(undefinedVariable);
} catch (error) {
    console.log("Error type:", error.name); // "ReferenceError"
}

try {
    // TypeError
    null.someMethod();
} catch (error) {
    console.log("Error type:", error.name); // "TypeError"
}

try {
    // SyntaxError
    eval("invalid syntax {");
} catch (error) {
    console.log("Error type:", error.name); // "SyntaxError"
}

// Custom error with stack trace
class CustomError extends Error {
    constructor(message, code) {
        super(message);
        this.name = "CustomError";
        this.code = code;
        this.timestamp = new Date().toISOString();
        
        // Maintain proper stack trace
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CustomError);
        }
    }
}

try {
    throw new CustomError("Custom error occurred", "CUSTOM_001");
} catch (error) {
    console.log("Error details:", {
        name: error.name,
        message: error.message,
        code: error.code,
        timestamp: error.timestamp,
        stack: error.stack
    });
}
```

**Error Handling Patterns**:

```javascript
// Error handling in async functions
async function fetchDataWithRetry(url, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            let response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return await response.json();
        } catch (error) {
            console.error(`Attempt ${i + 1} failed:`, error.message);
            if (i === maxRetries - 1) {
                throw new Error(`Failed after ${maxRetries} attempts: ${error.message}`);
            }
            // Wait before retry
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
    }
}

// Error boundary pattern
class ErrorBoundary {
    constructor() {
        this.errors = [];
    }
    
    try(operation) {
        try {
            return operation();
        } catch (error) {
            this.errors.push({
                error: error,
                timestamp: new Date(),
                operation: operation.name || 'anonymous'
            });
            return null;
        }
    }
    
    getErrors() {
        return this.errors;
    }
    
    hasErrors() {
        return this.errors.length > 0;
    }
}

let errorBoundary = new ErrorBoundary();

let result1 = errorBoundary.try(() => {
    return JSON.parse('{"valid": "json"}');
});

let result2 = errorBoundary.try(() => {
    return JSON.parse('invalid json');
});

console.log("Result 1:", result1); // {valid: "json"}
console.log("Result 2:", result2); // null
console.log("Has errors:", errorBoundary.hasErrors()); // true

// Global error handling
window.addEventListener('error', (event) => {
    console.error('Global error:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
    });
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    event.preventDefault(); // Prevent default browser behavior
});

// Error logging
class ErrorLogger {
    constructor() {
        this.errors = [];
    }
    
    log(error, context = {}) {
        let errorEntry = {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString(),
            context: context,
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        
        this.errors.push(errorEntry);
        
        // Send to server in production
        if (process.env.NODE_ENV === 'production') {
            this.sendToServer(errorEntry);
        }
    }
    
    sendToServer(errorEntry) {
        fetch('/api/errors', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(errorEntry)
        }).catch(err => {
            console.error('Failed to send error to server:', err);
        });
    }
}

let errorLogger = new ErrorLogger();

try {
    // Some risky operation
    throw new Error("Something went wrong");
} catch (error) {
    errorLogger.log(error, {
        userId: 123,
        action: 'dataProcessing',
        data: {some: 'context'}
    });
}
```

#### 1.3.6 Modüller

Modüller, JavaScript kodunu organize etmek ve yeniden kullanılabilir parçalara bölmek için kullanılır.

**ES6 Modülleri (ES Modules)**:

ES6 modülleri modern JavaScript'in standart modül sistemidir:

```javascript
// math.js - export examples
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

// Default export
export default function multiply(a, b) {
    return a * b;
}

// Named export with alias
export { add as sum, subtract as diff };

// Export from another module
export { PI as MATH_PI } from './constants.js';

// utils.js - multiple exports
export const formatDate = (date) => {
    return date.toLocaleDateString();
};

export const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
    }).format(amount);
};

// main.js - import examples
import multiply, { add, subtract, PI } from './math.js';
import { formatDate, formatCurrency } from './utils.js';

// Default import
import multiply from './math.js';

// Named imports
import { add, subtract, PI } from './math.js';

// Import with alias
import { add as sum, subtract as diff } from './math.js';

// Import all as namespace
import * as math from './math.js';
console.log(math.add(5, 3)); // 8
console.log(math.PI); // 3.14159

// Import with renaming
import { PI as MATH_PI } from './math.js';

// Dynamic import
async function loadModule() {
    const { add, subtract } = await import('./math.js');
    console.log(add(5, 3)); // 8
}

// Conditional import
if (condition) {
    const utils = await import('./utils.js');
    utils.formatDate(new Date());
}
```

**CommonJS Modülleri**:

CommonJS, Node.js'te kullanılan modül sistemidir:

```javascript
// math.js - CommonJS exports
const PI = 3.14159;

function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

// Named exports
exports.add = add;
exports.subtract = subtract;
exports.PI = PI;

// Or using module.exports
module.exports = {
    add,
    subtract,
    PI
};

// Default export
module.exports = function multiply(a, b) {
    return a * b;
};

// main.js - CommonJS imports
const math = require('./math.js');
console.log(math.add(5, 3)); // 8

// Destructuring
const { add, subtract, PI } = require('./math.js');

// Default import
const multiply = require('./math.js');

// utils.js - CommonJS module
const formatDate = (date) => {
    return date.toLocaleDateString();
};

const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
    }).format(amount);
};

module.exports = {
    formatDate,
    formatCurrency
};
```

**AMD (Asynchronous Module Definition)**:

AMD, tarayıcılar için asenkron modül yükleme sistemi:

```javascript
// math.js - AMD module
define(['exports'], function(exports) {
    const PI = 3.14159;
    
    function add(a, b) {
        return a + b;
    }
    
    function subtract(a, b) {
        return a - b;
    }
    
    exports.add = add;
    exports.subtract = subtract;
    exports.PI = PI;
});

// main.js - AMD usage
define(['./math'], function(math) {
    console.log(math.add(5, 3)); // 8
});

// AMD with dependencies
define(['./math', './utils'], function(math, utils) {
    const result = math.add(5, 3);
    const formatted = utils.formatCurrency(result);
    console.log(formatted);
});
```

**UMD (Universal Module Definition)**:

UMD, birden fazla modül sistemini destekleyen evrensel format:

```javascript
// math.js - UMD module
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['exports'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory((root.math = {}));
    }
}(typeof self !== 'undefined' ? self : this, function (exports) {
    const PI = 3.14159;
    
    function add(a, b) {
        return a + b;
    }
    
    function subtract(a, b) {
        return a - b;
    }
    
    exports.add = add;
    exports.subtract = subtract;
    exports.PI = PI;
}));
```

**Module Patterns**:

```javascript
// Singleton pattern
let instance = null;

class Database {
    constructor() {
        if (instance) {
            return instance;
        }
        this.connection = null;
        instance = this;
    }
    
    connect() {
        if (!this.connection) {
            this.connection = 'Connected to database';
        }
        return this.connection;
    }
}

export default Database;

// Factory pattern
class UserFactory {
    static createUser(type, data) {
        switch (type) {
            case 'admin':
                return new AdminUser(data);
            case 'regular':
                return new RegularUser(data);
            default:
                throw new Error('Invalid user type');
        }
    }
}

class AdminUser {
    constructor(data) {
        this.name = data.name;
        this.role = 'admin';
        this.permissions = ['read', 'write', 'delete'];
    }
}

class RegularUser {
    constructor(data) {
        this.name = data.name;
        this.role = 'user';
        this.permissions = ['read'];
    }
}

export { UserFactory, AdminUser, RegularUser };

// Observer pattern
class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }
    
    off(event, callback) {
        if (this.events[event]) {
            this.events[event] = this.events[event].filter(cb => cb !== callback);
        }
    }
}

export default EventEmitter;
```

**Module Bundling**:

```javascript
// webpack.config.js
module.exports = {
    entry: './src/index.js',
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            }
        ]
    },
    resolve: {
        extensions: ['.js', '.jsx', '.ts', '.tsx']
    }
};

// Tree shaking example
// math.js
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

export function multiply(a, b) {
    return a * b;
}

// main.js - only imports add function
import { add } from './math.js';

console.log(add(5, 3)); // 8

// subtract and multiply will be tree-shaken (removed from bundle)
```

**Module Best Practices**:

```javascript
// 1. Single responsibility
// userService.js - only user-related operations
export class UserService {
    async getUser(id) {
        // Implementation
    }
    
    async createUser(userData) {
        // Implementation
    }
    
    async updateUser(id, userData) {
        // Implementation
    }
}

// 2. Dependency injection
// logger.js
export class Logger {
    log(message) {
        console.log(`[${new Date().toISOString()}] ${message}`);
    }
}

// userService.js
import { Logger } from './logger.js';

export class UserService {
    constructor(logger = new Logger()) {
        this.logger = logger;
    }
    
    async getUser(id) {
        this.logger.log(`Getting user ${id}`);
        // Implementation
    }
}

// 3. Configuration module
// config.js
const config = {
    apiUrl: process.env.API_URL || 'https://api.example.com',
    timeout: parseInt(process.env.TIMEOUT) || 5000,
    retries: parseInt(process.env.RETRIES) || 3
};

export default config;

// 4. Constants module
// constants.js
export const HTTP_STATUS = {
    OK: 200,
    CREATED: 201,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    NOT_FOUND: 404,
    INTERNAL_SERVER_ERROR: 500
};

export const API_ENDPOINTS = {
    USERS: '/users',
    POSTS: '/posts',
    COMMENTS: '/comments'
};

// 5. Utility module
// utils.js
export const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

export const throttle = (func, limit) => {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
};
```

### 1.4 İleri Seviye JavaScript Konuları - Detaylı Analiz

İleri seviye JavaScript konuları, modern programlamanın en karmaşık ve güçlü özelliklerini içerir. Bu konular, sadece syntax öğrenmek değil, aynı zamanda JavaScript'in derinliklerini anlamak ve karmaşık programlama senaryolarını çözmek için kritik öneme sahiptir. İleri seviye JavaScript, functional programming, metaprogramming, asynchronous programming ve performance optimization gibi konuları kapsar.

**İleri Seviye JavaScript'in Felsefesi:**

İleri seviye JavaScript, "programming paradigms" ve "advanced patterns" prensiplerini benimser. Bu prensipler, JavaScript'i sadece bir scripting dili olmaktan çıkarıp, güçlü bir programlama dili haline getirir. Bu yaklaşım, karmaşık uygulamalar geliştirmeyi mümkün kılar ve kod kalitesini artırır.

**İleri Seviye JavaScript'in Kategorileri:**

**Metaprogramming (Metaprogramlama):**
Metaprogramming, programların kendilerini değiştirebilme, analiz edebilme ve dönüştürebilme yeteneğidir. Bu konu, Proxy, Reflect, Symbol gibi özellikler ile sağlanır.

**Functional Programming (Fonksiyonel Programlama):**
Functional programming, fonksiyonları birinci sınıf vatandaş olarak kullanma paradigmasıdır. Bu konu, higher-order functions, closures, currying gibi konuları kapsar.

**Asynchronous Programming (Asenkron Programlama):**
Asynchronous programming, non-blocking programlama paradigmasıdır. Bu konu, Promises, async/await, generators gibi konuları kapsar.

**Performance Optimization (Performans Optimizasyonu):**
Performance optimization, JavaScript uygulamalarının performansını artırma teknikleridir. Bu konu, memory management, execution optimization gibi konuları kapsar.

**Advanced Patterns (Gelişmiş Desenler):**
Advanced patterns, karmaşık programlama desenleridir. Bu konu, design patterns, architectural patterns gibi konuları kapsar.

**Metaprogramming - Derinlemesine Analiz:**

**Metaprogramming'in Felsefesi:**
Metaprogramming, "code that writes code" prensibini benimser. Bu prensip, programların kendilerini değiştirebilmesini ve adapte olabilmesini sağlar.

**Proxy ve Reflect:**
Proxy ve Reflect, JavaScript'te metaprogramming'in temel araçlarıdır. Bu araçlar, nesne davranışını değiştirmeyi ve meta-operasyonları sağlar.

**Symbols:**
Symbols, JavaScript'te unique identifier'lar sağlar. Bu özellik, property collision'ları önler ve meta-programming'i destekler.

**Functional Programming - Derinlemesine Analiz:**

**Functional Programming'in Felsefesi:**
Functional programming, "immutability" ve "pure functions" prensiplerini benimser. Bu prensipler, kod güvenilirliğini artırır ve debugging'i kolaylaştırır.

**Higher-Order Functions:**
Higher-order functions, fonksiyonları parametre olarak alan veya fonksiyon döndüren fonksiyonlardır. Bu özellik, functional programming'in temelini oluşturur.

**Closures:**
Closures, fonksiyonların dış scope'daki değişkenlere erişim sağlama özelliğidir. Bu özellik, functional programming'de kritik öneme sahiptir.

**Asynchronous Programming - Derinlemesine Analiz:**

**Asynchronous Programming'in Felsefesi:**
Asynchronous programming, "non-blocking" prensibini benimser. Bu prensip, uygulamaların responsive kalmasını sağlar.

**Promises:**
Promises, asynchronous operations'ları yönetmek için kullanılır. Bu özellik, callback hell'i önler ve kod okunabilirliğini artırır.

**async/await:**
async/await, Promises'i daha okunabilir hale getirir. Bu özellik, asynchronous code'u synchronous code gibi yazmayı sağlar.

**Performance Optimization - Derinlemesine Analiz:**

**Performance Optimization'un Felsefesi:**
Performance optimization, "measure first, optimize second" prensibini benimser. Bu prensip, gerçek performans sorunlarına odaklanmayı sağlar.

**Memory Management:**
Memory management, memory leak'lerini önler ve memory kullanımını optimize eder. Bu yönetim, garbage collection ve memory profiling ile sağlanır.

**Execution Optimization:**
Execution optimization, JavaScript execution'ını optimize eder. Bu optimizasyon, V8 engine optimizations ve code patterns ile sağlanır.

**Advanced Patterns - Derinlemesine Analiz:**

**Design Patterns:**
Design patterns, yaygın programlama problemlerinin çözümleridir. Bu pattern'ler, Singleton, Observer, Factory gibi pattern'leri kapsar.

**Architectural Patterns:**
Architectural patterns, büyük uygulamaların mimarisini yönetir. Bu pattern'ler, MVC, MVP, MVVM gibi pattern'leri kapsar.

**İleri Seviye JavaScript'in Avantajları:**

**Code Quality:**
İleri seviye JavaScript, kod kalitesini artırır. Advanced patterns ve best practices, maintainable code sağlar.

**Performance:**
İleri seviye JavaScript, performansı artırır. Optimization techniques, faster execution sağlar.

**Scalability:**
İleri seviye JavaScript, ölçeklenebilirliği artırır. Advanced patterns, large applications'ı yönetmeyi kolaylaştırır.

**Maintainability:**
İleri seviye JavaScript, sürdürülebilirliği artırır. Clean code principles, long-term maintenance sağlar.

**İleri Seviye JavaScript'in Kullanım Senaryoları:**

**Large Applications:**
İleri seviye JavaScript, büyük uygulamalar için kritik öneme sahiptir. Bu uygulamalarda, advanced patterns ve optimization techniques gerekir.

**Performance-Critical Applications:**
İleri seviye JavaScript, performans kritik uygulamalar için idealdir. Bu uygulamalarda, optimization techniques kritik öneme sahiptir.

**Complex Business Logic:**
İleri seviye JavaScript, karmaşık business logic için idealdir. Bu logic'te, advanced patterns ve functional programming gerekir.

**Real-time Applications:**
İleri seviye JavaScript, gerçek zamanlı uygulamalar için idealdir. Bu uygulamalarda, asynchronous programming ve performance optimization gerekir.

#### 1.4.1 Metaprogramming - Derinlemesine Analiz

Metaprogramming, JavaScript'in en güçlü ve karmaşık özelliklerinden biridir. Bu konu, programların kendilerini değiştirebilme, analiz edebilme ve dönüştürebilme yeteneğini kapsar. Metaprogramming, JavaScript'i sadece bir scripting dili olmaktan çıkarıp, güçlü bir programlama dili haline getirir.

**Metaprogramming'in Felsefesi:**

Metaprogramming, "code that writes code" prensibini benimser. Bu prensip, programların kendilerini değiştirebilmesini ve adapte olabilmesini sağlar. Bu yaklaşım, dinamik programlama ve self-modifying code'u mümkün kılar.

**Metaprogramming'in Tarihsel Gelişimi:**

Metaprogramming, programlama dillerinin evriminde önemli bir rol oynar. Bu kavram, 1960'larda Lisp'te başlamış, 1980'lerde C++ template metaprogramming ile gelişmiş, ve günümüzde JavaScript'te Proxy, Reflect ve Symbol'ler ile modern halini almıştır.

**JavaScript'te Metaprogramming Araçları:**

**Proxy:**
Proxy, nesne davranışını değiştirmek için kullanılır. Bu özellik, property access, method calls ve object creation gibi operasyonları intercept eder.

**Reflect:**
Reflect, meta-object operations sağlar. Bu özellik, object manipulation'ları için programmatic interface sağlar.

**Symbols:**
Symbols, unique identifier'lar sağlar. Bu özellik, property collision'ları önler ve meta-programming'i destekler.

**Metaprogramming'in Kullanım Senaryoları:**

**Validation:**
Metaprogramming, input validation için kullanılır. Proxy'ler, property access'leri intercept ederek validation sağlar.

**Logging:**
Metaprogramming, method call logging için kullanılır. Proxy'ler, method calls'ları intercept ederek logging sağlar.

**Security:**
Metaprogramming, security için kullanılır. Proxy'ler, unauthorized access'leri önler.

**Performance Monitoring:**
Metaprogramming, performance monitoring için kullanılır. Proxy'ler, method calls'ları intercept ederek performance metrics sağlar.

**Metaprogramming'in Avantajları:**

**Flexibility:**
Metaprogramming, kod esnekliğini artırır. Runtime'da behavior değişiklikleri mümkün olur.

**Reusability:**
Metaprogramming, kod yeniden kullanılabilirliğini artırır. Generic solutions, farklı context'lerde kullanılabilir.

**Abstraction:**
Metaprogramming, abstraction level'ını artırır. Complex operations, simple interface'ler ile sağlanır.

**Metaprogramming'in Dezavantajları:**

**Complexity:**
Metaprogramming, kod karmaşıklığını artırır. Debugging ve maintenance zorlaşır.

**Performance:**
Metaprogramming, performance overhead yaratır. Proxy operations, direct operations'dan daha yavaştır.

**Readability:**
Metaprogramming, kod okunabilirliğini azaltır. Behavior, explicit değil implicit olur.

**Metaprogramming Nedir? - Derinlemesine Analiz:**

Metaprogramming, programların kendilerini değiştirebilme, analiz edebilme ve dönüştürebilme yeteneğidir. Bu kavram, "program yazan programlar" olarak tanımlanabilir. JavaScript'te metaprogramming, ES6 ile birlikte gelen Proxy, Reflect ve Symbol'ler ile sağlanır.

**Metaprogramming'in Tarihçesi:**
- **1960'lar**: Lisp'te ilk metaprogramming örnekleri
- **1980'ler**: C++ template metaprogramming
- **1990'lar**: Java reflection API
- **2015**: JavaScript ES6 ile Proxy ve Reflect
- **2017**: JavaScript ES2017 ile async/await metaprogramming

**Metaprogramming'in Faydaları:**
- **Kod Tekrarını Azaltma**: Benzer işlemleri otomatikleştirme
- **Dinamik Davranış**: Çalışma zamanında kod davranışını değiştirme
- **AOP (Aspect-Oriented Programming)**: Cross-cutting concerns'i ele alma
- **Validation ve Logging**: Otomatik veri doğrulama ve loglama
- **API Wrapping**: Mevcut API'leri genişletme ve sarmalama

**JavaScript'te Metaprogramming Araçları:**

**1. Proxy - Nesne Davranışını Değiştirme**

Proxy, bir nesnenin temel işlemlerini (özellik okuma, yazma, silme, fonksiyon çağırma vb.) özelleştirmek için kullanılan bir metaprogramming aracıdır. Proxy, "meta-object protocol" (MOP) sağlar.

**Proxy Ne Zaman Kullanılır?**
- **Validation**: Nesne özelliklerine değer atarken doğrulama
- **Logging**: Nesne erişimlerini loglama
- **Caching**: Pahalı hesaplamaları önbellekleme
- **Virtual Properties**: Dinamik özellik oluşturma
- **Security**: Nesne erişimlerini kontrol etme

**Proxy Handler Metodları:**
- `get(target, property, receiver)`: Özellik okuma
- `set(target, property, value, receiver)`: Özellik yazma
- `has(target, property)`: `in` operatörü
- `deleteProperty(target, property)`: Özellik silme
- `ownKeys(target)`: `Object.keys()` ve benzeri
- `apply(target, thisArg, argumentsList)`: Fonksiyon çağırma
- `construct(target, argumentsList, newTarget)`: `new` operatörü

**Proxy**:

```javascript
// Temel Proxy kullanımı
const target = {
    name: "John",
    age: 30
};

const handler = {
    get(target, property) {
        console.log(`Getting property: ${property}`);
        return target[property];
    },
    set(target, property, value) {
        console.log(`Setting property: ${property} = ${value}`);
        target[property] = value;
        return true;
    },
    has(target, property) {
        console.log(`Checking if property exists: ${property}`);
        return property in target;
    },
    deleteProperty(target, property) {
        console.log(`Deleting property: ${property}`);
        delete target[property];
        return true;
    }
};

const proxy = new Proxy(target, handler);

// Proxy kullanımı
console.log(proxy.name); // "Getting property: name" -> "John"
proxy.age = 31; // "Setting property: age = 31"
console.log('name' in proxy); // "Checking if property exists: name" -> true
delete proxy.age; // "Deleting property: age"

// Validation Proxy
const userProxy = new Proxy({}, {
    set(target, property, value) {
        if (property === 'age' && (typeof value !== 'number' || value < 0)) {
            throw new Error('Age must be a positive number');
        }
        if (property === 'email' && !value.includes('@')) {
            throw new Error('Invalid email format');
        }
        target[property] = value;
        return true;
    }
});

// userProxy.age = -5; // Error: Age must be a positive number
userProxy.age = 25; // OK
userProxy.email = "john@example.com"; // OK

// Function Proxy
function createLoggingFunction(fn) {
    return new Proxy(fn, {
        apply(target, thisArg, argumentsList) {
            console.log(`Calling function with arguments:`, argumentsList);
            const result = target.apply(thisArg, argumentsList);
            console.log(`Function returned:`, result);
            return result;
        }
    });
}

const add = createLoggingFunction((a, b) => a + b);
console.log(add(2, 3)); // Logs arguments and result

// Array Proxy
const arrayProxy = new Proxy([], {
    set(target, property, value) {
        if (property === 'length' && value < 0) {
            throw new Error('Array length cannot be negative');
        }
        target[property] = value;
        return true;
    }
});

arrayProxy.push(1, 2, 3); // OK
// arrayProxy.length = -1; // Error: Array length cannot be negative
```

**2. Reflect - Meta-Object Operations**

Reflect, JavaScript'te nesne işlemlerini programatik olarak gerçekleştirmek için kullanılan bir API'dir. Reflect, Proxy handler'ları ile birlikte kullanılmak üzere tasarlanmıştır ve her Proxy handler metoduna karşılık gelen bir Reflect metodu vardır.

**Reflect'in Tarihçesi:**
- **ES6 (2015)**: İlk kez tanıtıldı
- **Proxy ile birlikte**: Proxy handler'larında kullanım için tasarlandı
- **Functional Programming**: Fonksiyonel programlama yaklaşımını destekler

**Reflect'in Faydaları:**
- **Consistency**: Tüm nesne işlemleri için tutarlı API
- **Return Values**: Her işlem için net dönüş değerleri
- **Error Handling**: Hata yönetimi için daha iyi kontrol
- **Proxy Integration**: Proxy handler'larında kolay kullanım
- **Functional Style**: Fonksiyonel programlama desteği

**Reflect Metodları:**
- `Reflect.get(target, property, receiver)`: Özellik okuma
- `Reflect.set(target, property, value, receiver)`: Özellik yazma
- `Reflect.has(target, property)`: Özellik varlığını kontrol etme
- `Reflect.deleteProperty(target, property)`: Özellik silme
- `Reflect.ownKeys(target)`: Kendi özelliklerini alma
- `Reflect.defineProperty(target, property, descriptor)`: Özellik tanımlama
- `Reflect.getOwnPropertyDescriptor(target, property)`: Özellik tanımlayıcısını alma
- `Reflect.preventExtensions(target)`: Genişletmeyi engelleme
- `Reflect.isExtensible(target)`: Genişletilebilirlik kontrolü
- `Reflect.getPrototypeOf(target)`: Prototype alma
- `Reflect.setPrototypeOf(target, prototype)`: Prototype ayarlama
- `Reflect.apply(target, thisArg, argumentsList)`: Fonksiyon çağırma
- `Reflect.construct(target, argumentsList, newTarget)`: Constructor çağırma

**Reflect**:

```javascript
// Reflect ile nesne işlemleri
const obj = {
    name: "John",
    age: 30,
    _private: "secret"
};

// Reflect.get
console.log(Reflect.get(obj, 'name')); // "John"
console.log(Reflect.get(obj, 'age')); // 30

// Reflect.set
Reflect.set(obj, 'city', 'New York');
console.log(obj.city); // "New York"

// Reflect.has
console.log(Reflect.has(obj, 'name')); // true
console.log(Reflect.has(obj, 'salary')); // false

// Reflect.deleteProperty
Reflect.deleteProperty(obj, 'age');
console.log(obj.age); // undefined

// Reflect.ownKeys
console.log(Reflect.ownKeys(obj)); // ["name", "_private", "city"]

// Reflect ile Proxy kombinasyonu
const validationProxy = new Proxy(obj, {
    set(target, property, value) {
        if (property.startsWith('_')) {
            throw new Error('Cannot set private properties');
        }
        return Reflect.set(target, property, value);
    },
    get(target, property) {
        if (property.startsWith('_')) {
            throw new Error('Cannot access private properties');
        }
        return Reflect.get(target, property);
    },
    deleteProperty(target, property) {
        if (property.startsWith('_')) {
            throw new Error('Cannot delete private properties');
        }
        return Reflect.deleteProperty(target, property);
    }
});

// validationProxy._private = "new secret"; // Error: Cannot set private properties
// console.log(validationProxy._private); // Error: Cannot access private properties
validationProxy.name = "Jane"; // OK
```

**3. Symbols - Benzersiz Tanımlayıcılar**

Symbol, JavaScript'te benzersiz ve değiştirilemez primitive değer türüdür. Symbol'ler, özellikle nesne özellikleri için güvenli anahtarlar oluşturmak ve name collision'ları önlemek için kullanılır.

**Symbol'lerin Tarihçesi:**
- **ES6 (2015)**: İlk kez tanıtıldı
- **Ruby'den ilham**: Ruby'nin symbol sisteminden etkilenildi
- **Private Properties**: Özel özellikler için çözüm olarak tasarlandı
- **Well-known Symbols**: JavaScript'in dahili sembolleri eklendi

**Symbol'lerin Özellikleri:**
- **Benzersizlik**: Her symbol benzersizdir, eşit olamaz
- **Primitive Type**: String, number gibi primitive tiptir
- **Immutable**: Değiştirilemez
- **Object Keys**: Nesne anahtarı olarak kullanılabilir
- **Enumerable**: Varsayılan olarak enumerable değildir
- **Global Registry**: Symbol.for() ile global kayıt

**Symbol Kullanım Alanları:**
- **Private Properties**: Özel nesne özellikleri
- **Well-known Symbols**: JavaScript'in dahili davranışlarını özelleştirme
- **Metadata**: Nesnelere metadata ekleme
- **Name Collision Prevention**: İsim çakışmalarını önleme
- **Library Development**: Kütüphane geliştirmede güvenli anahtarlar

**Symbol Türleri:**
- **Local Symbols**: Symbol() ile oluşturulan yerel semboller
- **Global Symbols**: Symbol.for() ile oluşturulan global semboller
- **Well-known Symbols**: JavaScript'in dahili sembolleri

**Symbols**:

```javascript
// Temel Symbol kullanımı
const sym1 = Symbol();
const sym2 = Symbol('description');
const sym3 = Symbol('description');

console.log(sym1); // Symbol()
console.log(sym2); // Symbol(description)
console.log(sym2 === sym3); // false - her symbol benzersizdir

// Symbol'ler object key olarak kullanılabilir
const obj = {};
const sym = Symbol('id');
obj[sym] = 123;
obj['regular'] = 'value';

console.log(obj[sym]); // 123
console.log(Object.keys(obj)); // ["regular"] - symbol'ler görünmez
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id)]

// Well-known Symbols
const iterable = {
    [Symbol.iterator]: function* () {
        yield 1;
        yield 2;
        yield 3;
    }
};

for (const value of iterable) {
    console.log(value); // 1, 2, 3
}

// Symbol.toPrimitive
const obj = {
    value: 42,
    [Symbol.toPrimitive](hint) {
        if (hint === 'number') {
            return this.value;
        }
        if (hint === 'string') {
            return `Value: ${this.value}`;
        }
        return this.value;
    }
};

console.log(+obj); // 42 (number conversion)
console.log(`${obj}`); // "Value: 42" (string conversion)
console.log(obj + 1); // 43 (default conversion)

// Symbol.toStringTag
class MyClass {
    get [Symbol.toStringTag]() {
        return 'MyClass';
    }
}

const instance = new MyClass();
console.log(instance.toString()); // "[object MyClass]"

// Symbol.hasInstance
class MyArray {
    static [Symbol.hasInstance](instance) {
        return Array.isArray(instance);
    }
}

console.log([] instanceof MyArray); // true
console.log({} instanceof MyArray); // false
```

**Well-known Symbols**:

```javascript
// Symbol.iterator - Custom iterable
class Range {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }

    *[Symbol.iterator]() {
        for (let i = this.start; i <= this.end; i++) {
            yield i;
        }
    }
}

const range = new Range(1, 5);
for (const num of range) {
    console.log(num); // 1, 2, 3, 4, 5
}

// Symbol.asyncIterator - Async iterable
class AsyncRange {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }

    async *[Symbol.asyncIterator]() {
        for (let i = this.start; i <= this.end; i++) {
            await new Promise(resolve => setTimeout(resolve, 100));
            yield i;
        }
    }
}

async function iterateAsync() {
    const asyncRange = new AsyncRange(1, 3);
    for await (const num of asyncRange) {
        console.log(num); // 1, 2, 3 (with delay)
    }
}

// Symbol.match - Custom string matching
class MyMatcher {
    constructor(pattern) {
        this.pattern = pattern;
    }

    [Symbol.match](string) {
        const matches = string.match(new RegExp(this.pattern, 'g'));
        return matches ? matches.map(match => `Found: ${match}`) : null;
    }
}

const matcher = new MyMatcher('\\d+');
console.log('abc123def456'.match(matcher)); // ["Found: 123", "Found: 456"]

// Symbol.replace - Custom string replacement
class MyReplacer {
    constructor(find, replace) {
        this.find = find;
        this.replace = replace;
    }

    [Symbol.replace](string) {
        return string.replace(new RegExp(this.find, 'g'), this.replace);
    }
}

const replacer = new MyReplacer('\\d+', 'NUMBER');
console.log('abc123def456'.replace(replacer)); // "abcNUMBERdefNUMBER"
```

#### 1.4.2 Memory Management

**Bellek Yönetimi Nedir?**

Bellek yönetimi, programın çalışması sırasında belleğin nasıl tahsis edildiği, kullanıldığı ve serbest bırakıldığının kontrol edilmesidir. JavaScript'te bellek yönetimi otomatik olarak yapılır (garbage collection), ancak bellek sızıntılarını önlemek için dikkatli olmak gerekir.

**JavaScript Bellek Yönetiminin Tarihçesi:**
- **1995**: JavaScript'in ilk versiyonunda basit garbage collection
- **2008**: V8 engine ile gelişmiş garbage collection
- **2012**: Generational garbage collection
- **2015**: WeakMap/WeakSet ile zayıf referanslar
- **2021**: WeakRef ve FinalizationRegistry

**Bellek Yönetiminin Temel Kavramları:**
- **Heap**: Dinamik bellek alanı
- **Stack**: Fonksiyon çağrıları ve yerel değişkenler
- **Reference**: Nesne referansları
- **Reachability**: Erişilebilirlik
- **Garbage Collection**: Çöp toplama

**JavaScript'te Bellek Türleri:**
- **Primitive Values**: Stack'te saklanır (string, number, boolean)
- **Objects**: Heap'te saklanır (object, array, function)
- **References**: Stack'te saklanır, heap'teki objelere işaret eder

**Garbage Collection Algoritmaları:**
- **Mark and Sweep**: İşaretle ve temizle
- **Reference Counting**: Referans sayma
- **Generational**: Nesil tabanlı
- **Incremental**: Artımlı toplama

**Garbage Collection**:

```javascript
// Garbage Collection temel kavramları
function createObject() {
    const obj = {
        data: new Array(1000).fill('data'),
        timestamp: Date.now()
    };
    return obj;
}

// Obje kullanıldıktan sonra garbage collection tarafından temizlenir
let temp = createObject();
temp = null; // Obje artık erişilemez, GC tarafından temizlenebilir

// Circular reference örneği
function createCircularReference() {
    const obj1 = { name: 'Object 1' };
    const obj2 = { name: 'Object 2' };
    
    obj1.ref = obj2;
    obj2.ref = obj1; // Circular reference
    
    return obj1;
}

// Modern JavaScript engine'leri circular reference'ları da temizleyebilir
let circular = createCircularReference();
circular = null; // Her iki obje de temizlenir

// WeakMap ile circular reference'ları önleme
const weakMap = new WeakMap();

function createSafeCircularReference() {
    const obj1 = { name: 'Object 1' };
    const obj2 = { name: 'Object 2' };
    
    weakMap.set(obj1, obj2);
    weakMap.set(obj2, obj1);
    
    return obj1;
}
```

**Memory Leaks - Bellek Sızıntıları**

Bellek sızıntısı, programın artık kullanmadığı bellek alanlarını serbest bırakmaması durumudur. JavaScript'te garbage collection otomatik olarak çalışsa da, bellek sızıntıları hala oluşabilir.

**Bellek Sızıntısının Nedenleri:**
- **Global Variables**: Global değişkenler
- **Event Listeners**: Temizlenmeyen event listener'lar
- **Closures**: Büyük objeleri tutan closure'lar
- **Timers**: Temizlenmeyen timer'lar
- **DOM References**: DOM referansları
- **Circular References**: Döngüsel referanslar

**Bellek Sızıntısının Belirtileri:**
- **Yavaşlama**: Uygulama performansında düşüş
- **Crash**: Uygulama çökmesi
- **High Memory Usage**: Yüksek bellek kullanımı
- **Browser Freeze**: Tarayıcı donması

**Bellek Sızıntısını Önleme Yöntemleri:**
- **Weak References**: WeakMap, WeakSet kullanma
- **Event Cleanup**: Event listener'ları temizleme
- **Timer Cleanup**: Timer'ları temizleme
- **DOM Cleanup**: DOM referanslarını temizleme
- **Closure Optimization**: Closure'ları optimize etme

**Memory Leaks**:

```javascript
// 1. Global değişkenler
// YANLIŞ - Global değişken bellek sızıntısına neden olur
let globalData = [];

function addData() {
    globalData.push(new Array(1000).fill('data'));
}

// DOĞRU - Local scope kullan
function addDataLocal() {
    const localData = [];
    localData.push(new Array(1000).fill('data'));
    return localData;
}

// 2. Event listener'lar
// YANLIŞ - Event listener'lar temizlenmezse bellek sızıntısı
function createLeakyComponent() {
    const element = document.createElement('div');
    
    element.addEventListener('click', function() {
        console.log('Clicked');
    });
    
    // Element DOM'dan kaldırılsa bile event listener bellek sızıntısına neden olur
    return element;
}

// DOĞRU - Event listener'ları temizle
function createCleanComponent() {
    const element = document.createElement('div');
    
    const clickHandler = function() {
        console.log('Clicked');
    };
    
    element.addEventListener('click', clickHandler);
    
    // Cleanup function
    element.cleanup = function() {
        element.removeEventListener('click', clickHandler);
    };
    
    return element;
}

// 3. Closure'lar
// YANLIŞ - Closure büyük objeleri tutabilir
function createLeakyClosure() {
    const largeData = new Array(10000).fill('data');
    
    return function() {
        console.log('Function called');
        // largeData closure'da tutulur, bellek sızıntısına neden olur
    };
}

// DOĞRU - Closure'da sadece gerekli verileri tut
function createCleanClosure() {
    const largeData = new Array(10000).fill('data');
    const summary = largeData.length; // Sadece gerekli veri
    
    return function() {
        console.log(`Data count: ${summary}`);
        // largeData artık closure'da tutulmaz
    };
}

// 4. Timer'lar
// YANLIŞ - Timer'lar temizlenmezse bellek sızıntısı
function createLeakyTimer() {
    setInterval(() => {
        console.log('Timer tick');
    }, 1000);
    
    // Timer temizlenmezse bellek sızıntısına neden olur
}

// DOĞRU - Timer'ları temizle
function createCleanTimer() {
    const timerId = setInterval(() => {
        console.log('Timer tick');
    }, 1000);
    
    // Cleanup function
    return {
        stop: () => clearInterval(timerId)
    };
}

// 5. DOM referansları
// YANLIŞ - DOM referansları temizlenmezse bellek sızıntısı
function createLeakyDOMReference() {
    const elements = [];
    
    for (let i = 0; i < 1000; i++) {
        const element = document.createElement('div');
        elements.push(element);
    }
    
    // elements array'i DOM referanslarını tutar
    return elements;
}

// DOĞRU - DOM referanslarını temizle
function createCleanDOMReference() {
    const elements = [];
    
    for (let i = 0; i < 1000; i++) {
        const element = document.createElement('div');
        elements.push(element);
    }
    
    // Cleanup function
    return {
        elements,
        cleanup: () => {
            elements.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            elements.length = 0;
        }
    };
}
```

**WeakMap/WeakSet**:

```javascript
// WeakMap - Zayıf referanslar
const weakMap = new WeakMap();

// WeakMap sadece object key'leri kabul eder
const obj1 = { id: 1 };
const obj2 = { id: 2 };

weakMap.set(obj1, 'value1');
weakMap.set(obj2, 'value2');

console.log(weakMap.get(obj1)); // "value1"
console.log(weakMap.has(obj2)); // true

// Obje referansı kaldırıldığında WeakMap'ten de kaldırılır
obj1 = null; // obj1 artık erişilemez, WeakMap'ten de kaldırılır

// WeakMap iteration desteklemez
// for (let key of weakMap) { } // Error: weakMap is not iterable

// WeakMap kullanım örnekleri
// 1. Private data storage
const privateData = new WeakMap();

class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
        
        // Private data WeakMap'te saklanır
        privateData.set(this, {
            password: null,
            lastLogin: null,
            preferences: {}
        });
    }
    
    setPassword(password) {
        const data = privateData.get(this);
        data.password = password;
    }
    
    getLastLogin() {
        const data = privateData.get(this);
        return data.lastLogin;
    }
    
    setLastLogin(date) {
        const data = privateData.get(this);
        data.lastLogin = date;
    }
}

const user = new User('John', 'john@example.com');
user.setPassword('secret123');
user.setLastLogin(new Date());

// Private data'ya doğrudan erişim yok
// console.log(user.password); // undefined

// 2. DOM element metadata
const elementMetadata = new WeakMap();

function addMetadata(element, metadata) {
    elementMetadata.set(element, metadata);
}

function getMetadata(element) {
    return elementMetadata.get(element);
}

const button = document.createElement('button');
addMetadata(button, {
    clickCount: 0,
    lastClick: null,
    customData: 'some data'
});

button.addEventListener('click', function() {
    const metadata = getMetadata(this);
    metadata.clickCount++;
    metadata.lastClick = new Date();
    console.log(`Button clicked ${metadata.clickCount} times`);
});

// WeakSet - Zayıf referanslar ile set
const weakSet = new WeakSet();

const obj1 = { id: 1 };
const obj2 = { id: 2 };
const obj3 = { id: 3 };

weakSet.add(obj1);
weakSet.add(obj2);
weakSet.add(obj3);

console.log(weakSet.has(obj1)); // true
console.log(weakSet.has(obj2)); // true

// Obje referansı kaldırıldığında WeakSet'ten de kaldırılır
obj1 = null; // obj1 artık erişilemez, WeakSet'ten de kaldırılır

// WeakSet kullanım örnekleri
// 1. Object tracking
const processedObjects = new WeakSet();

function processObject(obj) {
    if (processedObjects.has(obj)) {
        console.log('Object already processed');
        return;
    }
    
    // Process object
    console.log('Processing object:', obj);
    processedObjects.add(obj);
}

const data1 = { value: 1 };
const data2 = { value: 2 };

processObject(data1); // "Processing object: {value: 1}"
processObject(data1); // "Object already processed"
processObject(data2); // "Processing object: {value: 2}"

// 2. DOM element tracking
const trackedElements = new WeakSet();

function trackElement(element) {
    trackedElements.add(element);
    element.classList.add('tracked');
}

function isTracked(element) {
    return trackedElements.has(element);
}

const div1 = document.createElement('div');
const div2 = document.createElement('div');

trackElement(div1);
console.log(isTracked(div1)); // true
console.log(isTracked(div2)); // false
```

**WeakRef**:

```javascript
// WeakRef - Zayıf referanslar (ES2021)
let obj = { data: 'important data' };
const weakRef = new WeakRef(obj);

// WeakRef'ten obje alınabilir
console.log(weakRef.deref()); // { data: 'important data' }

// Obje referansı kaldırıldığında
obj = null;

// Garbage collection'dan sonra WeakRef.deref() undefined döner
// (Bu örnekte hemen undefined dönmeyebilir, GC zamanına bağlı)

// WeakRef kullanım örnekleri
// 1. Cache implementation
class WeakCache {
    constructor() {
        this.cache = new Map();
    }
    
    set(key, value) {
        const weakRef = new WeakRef(value);
        this.cache.set(key, weakRef);
    }
    
    get(key) {
        const weakRef = this.cache.get(key);
        if (!weakRef) {
            return undefined;
        }
        
        const value = weakRef.deref();
        if (value === undefined) {
            // Obje garbage collection tarafından temizlenmiş
            this.cache.delete(key);
            return undefined;
        }
        
        return value;
    }
    
    has(key) {
        return this.get(key) !== undefined;
    }
}

const cache = new WeakCache();
const obj1 = { id: 1, data: 'data1' };
const obj2 = { id: 2, data: 'data2' };

cache.set('key1', obj1);
cache.set('key2', obj2);

console.log(cache.get('key1')); // { id: 1, data: 'data1' }
console.log(cache.has('key2')); // true

// Obje referansı kaldırıldığında
obj1 = null;

// Cache'den de kaldırılır (GC sonrası)
console.log(cache.get('key1')); // undefined

// 2. FinalizationRegistry - Obje temizlendiğinde callback
const registry = new FinalizationRegistry((heldValue) => {
    console.log(`Object with value ${heldValue} was garbage collected`);
});

let obj = { data: 'important data' };
registry.register(obj, 'important data');

// Obje referansı kaldırıldığında
obj = null;

// Garbage collection sonrası callback çalışır
// "Object with value important data was garbage collected"
```

#### 1.4.3 Performance Optimization

**Performans Optimizasyonu Nedir?**

Performans optimizasyonu, uygulamanın hızını, bellek kullanımını ve kullanıcı deneyimini iyileştirmek için yapılan tekniklerdir. JavaScript uygulamalarında performans optimizasyonu kritik önem taşır.

**Performans Optimizasyonunun Tarihçesi:**
- **1995**: JavaScript'in ilk versiyonunda basit optimizasyonlar
- **2008**: V8 engine ile JIT compilation
- **2010**: Modern JavaScript engine'leri
- **2015**: ES6 ile yeni optimizasyon teknikleri
- **2020**: Modern build tools ve bundlers

**Performans Metrikleri:**
- **First Contentful Paint (FCP)**: İlk içerik görüntüleme
- **Largest Contentful Paint (LCP)**: En büyük içerik görüntüleme
- **First Input Delay (FID)**: İlk giriş gecikmesi
- **Cumulative Layout Shift (CLS)**: Kümülatif düzen kayması
- **Time to Interactive (TTI)**: Etkileşim zamanı

**Optimizasyon Teknikleri:**
- **Debouncing/Throttling**: Olay işleme optimizasyonu
- **Lazy Loading**: Gecikmeli yükleme
- **Code Splitting**: Kod bölme
- **Tree Shaking**: Kullanılmayan kodları kaldırma
- **Bundle Optimization**: Paket optimizasyonu
- **Caching**: Önbellekleme
- **Minification**: Kod sıkıştırma

**Debouncing/Throttling - Olay İşleme Optimizasyonu**

Debouncing ve throttling, sık tetiklenen olayları optimize etmek için kullanılan tekniklerdir. Bu teknikler, gereksiz işlemleri azaltarak performansı artırır.

**Debouncing Nedir?**
Debouncing, bir fonksiyonun son çağrıdan belirli bir süre sonra çalıştırılmasını sağlar. Eğer bu süre içinde fonksiyon tekrar çağrılırsa, önceki çağrı iptal edilir.

**Throttling Nedir?**
Throttling, bir fonksiyonun belirli süre aralıklarında maksimum bir kez çalıştırılmasını sağlar. Bu süre içinde yapılan diğer çağrılar göz ardı edilir.

**Ne Zaman Kullanılır?**
- **Search Input**: Arama girişi
- **Scroll Events**: Kaydırma olayları
- **Resize Events**: Boyut değiştirme olayları
- **Button Clicks**: Buton tıklamaları
- **API Calls**: API çağrıları

**Debouncing/Throttling**:

```javascript
// Debouncing - Son çağrıdan belirli süre sonra fonksiyonu çalıştır
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Throttling - Belirli süre aralıklarında fonksiyonu çalıştır
function throttle(func, limit) {
    let inThrottle;
    return function executedFunction(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Kullanım örnekleri
// 1. Search input debouncing
const searchInput = document.getElementById('search');
const debouncedSearch = debounce((query) => {
    console.log('Searching for:', query);
    // API call
}, 300);

searchInput.addEventListener('input', (e) => {
    debouncedSearch(e.target.value);
});

// 2. Scroll event throttling
const throttledScroll = throttle(() => {
    console.log('Scroll event');
    // Expensive scroll operations
}, 100);

window.addEventListener('scroll', throttledScroll);
```

**Lazy Loading - Gecikmeli Yükleme**

Lazy loading, kaynakların (resimler, kod, veriler) sadece ihtiyaç duyulduğunda yüklenmesini sağlayan bir optimizasyon tekniğidir. Bu teknik, ilk sayfa yükleme süresini azaltır ve bant genişliği kullanımını optimize eder.

**Lazy Loading'in Tarihçesi:**
- **2000'ler**: İlk lazy loading örnekleri
- **2010**: Intersection Observer API önerisi
- **2016**: Intersection Observer API standardizasyonu
- **2018**: Modern tarayıcılarda yaygın destek
- **2020**: Native lazy loading desteği

**Lazy Loading'in Faydaları:**
- **Faster Initial Load**: Daha hızlı ilk yükleme
- **Bandwidth Savings**: Bant genişliği tasarrufu
- **Better User Experience**: Daha iyi kullanıcı deneyimi
- **Reduced Server Load**: Azaltılmış sunucu yükü
- **Battery Life**: Mobil cihazlarda pil tasarrufu

**Lazy Loading Türleri:**
- **Image Lazy Loading**: Resim gecikmeli yükleme
- **Component Lazy Loading**: Bileşen gecikmeli yükleme
- **Data Lazy Loading**: Veri gecikmeli yükleme
- **Route Lazy Loading**: Rota gecikmeli yükleme
- **Library Lazy Loading**: Kütüphane gecikmeli yükleme

**Lazy Loading Teknikleri:**
- **Intersection Observer**: Modern API
- **Scroll Events**: Kaydırma olayları
- **Viewport Detection**: Görünüm alanı tespiti
- **Dynamic Imports**: Dinamik import'lar
- **Native Lazy Loading**: Yerel lazy loading

**Lazy Loading**:

```javascript
// 1. Image lazy loading
class LazyImageLoader {
    constructor() {
        this.imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.remove('lazy');
                    this.imageObserver.unobserve(img);
                }
            });
        });
    }
    
    observe(images) {
        images.forEach(img => this.imageObserver.observe(img));
    }
}

// Kullanım
const lazyLoader = new LazyImageLoader();
const lazyImages = document.querySelectorAll('img[data-src]');
lazyLoader.observe(lazyImages);

// 2. Component lazy loading
class LazyComponentLoader {
    constructor() {
        this.componentObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const component = entry.target;
                    this.loadComponent(component);
                    this.componentObserver.unobserve(component);
                }
            });
        });
    }
    
    async loadComponent(component) {
        const componentName = component.dataset.component;
        try {
            const module = await import(`./components/${componentName}.js`);
            const ComponentClass = module.default;
            const instance = new ComponentClass();
            component.innerHTML = instance.render();
        } catch (error) {
            console.error('Failed to load component:', error);
        }
    }
    
    observe(components) {
        components.forEach(component => this.componentObserver.observe(component));
    }
}
```

**Code Splitting**:

```javascript
// 1. Dynamic imports
async function loadFeature(featureName) {
    try {
        const module = await import(`./features/${featureName}.js`);
        return module.default;
    } catch (error) {
        console.error(`Failed to load feature ${featureName}:`, error);
        throw error;
    }
}

// Kullanım
document.getElementById('loadFeatureBtn').addEventListener('click', async () => {
    try {
        const feature = await loadFeature('advancedSearch');
        feature.init();
    } catch (error) {
        console.error('Feature loading failed:', error);
    }
});

// 2. Route-based code splitting
class RouteSplitter {
    constructor() {
        this.routes = new Map();
    }
    
    async loadRoute(routeName) {
        if (this.routes.has(routeName)) {
            return this.routes.get(routeName);
        }
        
        const route = await import(`./routes/${routeName}.js`);
        this.routes.set(routeName, route.default);
        return route.default;
    }
    
    async navigate(routeName) {
        const route = await this.loadRoute(routeName);
        route.render();
    }
}
```

**Tree Shaking**:

```javascript
// 1. ES6 modules ile tree shaking
// math.js - Sadece kullanılan fonksiyonlar bundle'a dahil edilir
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export const multiply = (a, b) => a * b;
export const divide = (a, b) => a / b;

// main.js - Sadece add ve multiply kullanılıyor
import { add, multiply } from './math.js';

console.log(add(2, 3)); // 5
console.log(multiply(4, 5)); // 20

// 2. Side-effect free modules
// utils.js - Side effect yok, tree shaking için güvenli
export const formatDate = (date) => {
    return date.toLocaleDateString();
};

export const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
    }).format(amount);
};
```

**Bundle Optimization**:

```javascript
// 1. Bundle analysis
class BundleAnalyzer {
    constructor() {
        this.modules = new Map();
        this.dependencies = new Map();
    }
    
    analyzeModule(moduleName, size, dependencies = []) {
        this.modules.set(moduleName, {
            size,
            dependencies,
            timestamp: Date.now()
        });
        
        dependencies.forEach(dep => {
            if (!this.dependencies.has(dep)) {
                this.dependencies.set(dep, new Set());
            }
            this.dependencies.get(dep).add(moduleName);
        });
    }
    
    getLargestModules(limit = 10) {
        return Array.from(this.modules.entries())
            .sort((a, b) => b[1].size - a[1].size)
            .slice(0, limit);
    }
    
    getUnusedModules() {
        const used = new Set();
        const all = new Set(this.modules.keys());
        
        // Mark modules as used if they're imported
        this.modules.forEach((module, name) => {
            if (module.dependencies.length > 0) {
                used.add(name);
            }
        });
        
        return Array.from(all).filter(module => !used.has(module));
    }
}
```

#### 1.4.4 Design Patterns

**Design Pattern Nedir?**

Design pattern (tasarım deseni), yazılım geliştirmede karşılaşılan yaygın problemlere kanıtlanmış, yeniden kullanılabilir çözümler sunan şablonlardır. Bu desenler, kodun daha okunabilir, sürdürülebilir ve genişletilebilir olmasını sağlar.

**Design Pattern'ların Tarihçesi:**
- **1977**: Christopher Alexander - "A Pattern Language"
- **1994**: Gang of Four (GoF) - "Design Patterns: Elements of Reusable Object-Oriented Software"
- **1995**: JavaScript'te pattern kullanımı başladı
- **2000'ler**: Web development'ta pattern'lar yaygınlaştı
- **2010'lar**: Modern JavaScript framework'lerinde pattern'lar

**Design Pattern Kategorileri:**
- **Creational Patterns**: Nesne oluşturma desenleri
- **Structural Patterns**: Nesne yapısı desenleri
- **Behavioral Patterns**: Nesne davranışı desenleri

**JavaScript'te Yaygın Pattern'lar:**
- **Module Pattern**: Kod organizasyonu
- **Observer Pattern**: Olay tabanlı programlama
- **Singleton Pattern**: Tekil nesne deseni
- **Factory Pattern**: Nesne oluşturma deseni
- **Decorator Pattern**: Nesne genişletme deseni
- **Strategy Pattern**: Algoritma değiştirme deseni
- **Command Pattern**: Komut deseni

**Pattern'ların Faydaları:**
- **Code Reusability**: Kod yeniden kullanılabilirliği
- **Maintainability**: Sürdürülebilirlik
- **Scalability**: Ölçeklenebilirlik
- **Team Communication**: Takım iletişimi
- **Best Practices**: En iyi uygulamalar

**Module Pattern - Kod Organizasyonu**

Module pattern, JavaScript'te kod organizasyonu ve encapsulation sağlamak için kullanılan en yaygın pattern'lardan biridir. Bu pattern, private ve public API'ler oluşturmayı sağlar.

**Module Pattern'in Özellikleri:**
- **Encapsulation**: Veri gizleme
- **Private Variables**: Özel değişkenler
- **Public API**: Genel arayüz
- **Namespace**: İsim alanı
- **Dependency Management**: Bağımlılık yönetimi

**Module Pattern Türleri:**
- **Basic Module**: Temel modül
- **Revealing Module**: Açığa çıkaran modül
- **AMD Module**: Asynchronous Module Definition
- **CommonJS Module**: Node.js modül sistemi
- **ES6 Module**: Modern JavaScript modül sistemi

**Module Pattern**:

```javascript
// 1. Basic Module Pattern
const UserModule = (function() {
    // Private variables
    let users = [];
    let currentUser = null;
    
    // Private functions
    function validateUser(user) {
        return user && user.name && user.email;
    }
    
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    // Public API
    return {
        addUser: function(userData) {
            if (!validateUser(userData)) {
                throw new Error('Invalid user data');
            }
            
            const user = {
                id: generateId(),
                name: userData.name,
                email: userData.email,
                createdAt: new Date()
            };
            
            users.push(user);
            return user;
        },
        
        getUsers: function() {
            return [...users]; // Return copy to prevent external modification
        },
        
        getUserById: function(id) {
            return users.find(user => user.id === id);
        },
        
        setCurrentUser: function(user) {
            currentUser = user;
        },
        
        getCurrentUser: function() {
            return currentUser;
        },
        
        removeUser: function(id) {
            const index = users.findIndex(user => user.id === id);
            if (index !== -1) {
                users.splice(index, 1);
                return true;
            }
            return false;
        }
    };
})();

// Kullanım
const user1 = UserModule.addUser({ name: 'John', email: 'john@example.com' });
const user2 = UserModule.addUser({ name: 'Jane', email: 'jane@example.com' });
console.log(UserModule.getUsers());

// 2. Revealing Module Pattern
const CalculatorModule = (function() {
    // Private variables
    let result = 0;
    let history = [];
    
    // Private functions
    function addToHistory(operation, value, newResult) {
        history.push({
            operation,
            value,
            previousResult: result,
            newResult,
            timestamp: new Date()
        });
    }
    
    function validateNumber(num) {
        if (typeof num !== 'number' || isNaN(num)) {
            throw new Error('Invalid number');
        }
    }
    
    // Public API
    return {
        add: function(num) {
            validateNumber(num);
            const newResult = result + num;
            addToHistory('add', num, newResult);
            result = newResult;
            return this;
        },
        
        subtract: function(num) {
            validateNumber(num);
            const newResult = result - num;
            addToHistory('subtract', num, newResult);
            result = newResult;
            return this;
        },
        
        multiply: function(num) {
            validateNumber(num);
            const newResult = result * num;
            addToHistory('multiply', num, newResult);
            result = newResult;
            return this;
        },
        
        divide: function(num) {
            validateNumber(num);
            if (num === 0) {
                throw new Error('Division by zero');
            }
            const newResult = result / num;
            addToHistory('divide', num, newResult);
            result = newResult;
            return this;
        },
        
        getResult: function() {
            return result;
        },
        
        getHistory: function() {
            return [...history];
        },
        
        clear: function() {
            result = 0;
            history = [];
            return this;
        }
    };
})();

// Kullanım
CalculatorModule.add(5).multiply(2).subtract(3).divide(2);
console.log(CalculatorModule.getResult()); // 3.5
console.log(CalculatorModule.getHistory());
```

**Observer Pattern - Olay Tabanlı Programlama**

Observer pattern, bir nesnenin durumu değiştiğinde ona bağımlı olan tüm nesneleri otomatik olarak bilgilendiren bir behavioral design pattern'dir. Bu pattern, loose coupling (gevşek bağlantı) sağlar.

**Observer Pattern'in Tarihçesi:**
- **1994**: Gang of Four tarafından tanımlandı
- **2000'ler**: JavaScript'te event system olarak kullanıldı
- **2010'lar**: Modern framework'lerde yaygınlaştı
- **2015**: ES6 ile daha gelişmiş implementasyonlar

**Observer Pattern'in Özellikleri:**
- **Loose Coupling**: Gevşek bağlantı
- **One-to-Many**: Bir-çok ilişki
- **Dynamic Relationships**: Dinamik ilişkiler
- **Event-Driven**: Olay tabanlı
- **Decoupled**: Ayrıştırılmış

**Observer Pattern Kullanım Alanları:**
- **Event Systems**: Olay sistemleri
- **Model-View**: Model-görünüm ilişkisi
- **Publish-Subscribe**: Yayın-abone sistemi
- **Reactive Programming**: Reaktif programlama
- **State Management**: Durum yönetimi

**Observer Pattern Bileşenleri:**
- **Subject**: Gözlemlenen nesne
- **Observer**: Gözlemci nesne
- **Concrete Subject**: Somut konu
- **Concrete Observer**: Somut gözlemci

**Observer Pattern**:

```javascript
// 1. Basic Observer Pattern
class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
        return this;
    }
    
    off(event, callback) {
        if (!this.events[event]) return this;
        
        this.events[event] = this.events[event].filter(cb => cb !== callback);
        return this;
    }
    
    emit(event, ...args) {
        if (!this.events[event]) return this;
        
        this.events[event].forEach(callback => {
            try {
                callback(...args);
            } catch (error) {
                console.error('Error in event callback:', error);
            }
        });
        return this;
    }
    
    once(event, callback) {
        const onceCallback = (...args) => {
            callback(...args);
            this.off(event, onceCallback);
        };
        return this.on(event, onceCallback);
    }
}

// Kullanım
const emitter = new EventEmitter();

emitter.on('user:login', (user) => {
    console.log(`User ${user.name} logged in`);
});

emitter.on('user:logout', (user) => {
    console.log(`User ${user.name} logged out`);
});

emitter.emit('user:login', { name: 'John', id: 1 });

// 2. Subject-Observer Pattern
class Subject {
    constructor() {
        this.observers = [];
    }
    
    addObserver(observer) {
        if (!this.observers.includes(observer)) {
            this.observers.push(observer);
        }
        return this;
    }
    
    removeObserver(observer) {
        this.observers = this.observers.filter(obs => obs !== observer);
        return this;
    }
    
    notify(data) {
        this.observers.forEach(observer => {
            observer.update(data);
        });
        return this;
    }
}

class Observer {
    constructor(name) {
        this.name = name;
    }
    
    update(data) {
        console.log(`${this.name} received:`, data);
    }
}

// Kullanım
const subject = new Subject();
const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');

subject.addObserver(observer1).addObserver(observer2);
subject.notify({ message: 'Hello World' });

// 3. Real-world example: News Agency
class NewsAgency extends Subject {
    constructor() {
        super();
        this.news = [];
    }
    
    publishNews(news) {
        this.news.push(news);
        this.notify(news);
    }
    
    getLatestNews() {
        return this.news[this.news.length - 1];
    }
}

class NewsChannel extends Observer {
    constructor(name) {
        super(name);
        this.news = [];
    }
    
    update(news) {
        this.news.push(news);
        console.log(`${this.name} broadcasting: ${news.title}`);
    }
}

const agency = new NewsAgency();
const channel1 = new NewsChannel('CNN');
const channel2 = new NewsChannel('BBC');

agency.addObserver(channel1).addObserver(channel2);
agency.publishNews({ title: 'Breaking News', content: 'Something important happened' });
```

**Singleton Pattern - Tekil Nesne Deseni**

Singleton pattern, bir sınıfın sadece bir instance'ının (örneğinin) oluşturulmasını garanti eden bir creational design pattern'dir. Bu pattern, global erişim noktası sağlar ve kaynak yönetimini kontrol eder.

**Singleton Pattern'in Tarihçesi:**
- **1994**: Gang of Four tarafından tanımlandı
- **2000'ler**: JavaScript'te yaygın kullanım
- **2010'lar**: Modern framework'lerde dependency injection
- **2015**: ES6 ile class-based implementasyonlar

**Singleton Pattern'in Özellikleri:**
- **Single Instance**: Tek örnek
- **Global Access**: Global erişim
- **Lazy Initialization**: Gecikmeli başlatma
- **Thread Safety**: Thread güvenliği (JavaScript'te gerekli değil)
- **Resource Management**: Kaynak yönetimi

**Singleton Pattern Kullanım Alanları:**
- **Database Connections**: Veritabanı bağlantıları
- **Logging**: Loglama sistemleri
- **Configuration**: Yapılandırma yönetimi
- **Cache**: Önbellek sistemleri
- **State Management**: Durum yönetimi

**Singleton Pattern Avantajları:**
- **Controlled Access**: Kontrollü erişim
- **Memory Efficiency**: Bellek verimliliği
- **Global State**: Global durum
- **Lazy Loading**: Gecikmeli yükleme

**Singleton Pattern Dezavantajları:**
- **Global State**: Global durum (test zorluğu)
- **Tight Coupling**: Sıkı bağlantı
- **Hidden Dependencies**: Gizli bağımlılıklar
- **Testing Difficulties**: Test zorlukları

**Singleton Pattern**:

```javascript
// 1. Basic Singleton
class DatabaseConnection {
    constructor() {
        if (DatabaseConnection.instance) {
            return DatabaseConnection.instance;
        }
        
        this.connection = null;
        this.isConnected = false;
        DatabaseConnection.instance = this;
    }
    
    connect(url) {
        if (this.isConnected) {
            console.log('Already connected');
            return this;
        }
        
        this.connection = url;
        this.isConnected = true;
        console.log(`Connected to ${url}`);
        return this;
    }
    
    disconnect() {
        if (!this.isConnected) {
            console.log('Not connected');
            return this;
        }
        
        this.connection = null;
        this.isConnected = false;
        console.log('Disconnected');
        return this;
    }
    
    query(sql) {
        if (!this.isConnected) {
            throw new Error('Not connected to database');
        }
        console.log(`Executing: ${sql}`);
        return { result: 'success' };
    }
}

// Kullanım
const db1 = new DatabaseConnection();
const db2 = new DatabaseConnection();

console.log(db1 === db2); // true - Same instance

db1.connect('mongodb://localhost:27017/mydb');
db2.query('SELECT * FROM users'); // Works because it's the same instance

// 2. Singleton with lazy initialization
class Logger {
    constructor() {
        if (Logger.instance) {
            return Logger.instance;
        }
        
        this.logs = [];
        this.level = 'INFO';
        Logger.instance = this;
    }
    
    setLevel(level) {
        this.level = level;
        return this;
    }
    
    log(message, level = 'INFO') {
        const logEntry = {
            message,
            level,
            timestamp: new Date(),
            id: Date.now()
        };
        
        this.logs.push(logEntry);
        console.log(`[${level}] ${message}`);
        return this;
    }
    
    getLogs() {
        return [...this.logs];
    }
    
    clearLogs() {
        this.logs = [];
        return this;
    }
}

// Kullanım
const logger1 = new Logger();
const logger2 = new Logger();

console.log(logger1 === logger2); // true

logger1.log('Application started');
logger2.log('User logged in', 'DEBUG');
logger1.log('Database connected', 'INFO');

console.log(logger1.getLogs().length); // 3

// 3. Singleton with module pattern
const ConfigManager = (function() {
    let instance = null;
    
    function createInstance() {
        const config = {
            apiUrl: 'https://api.example.com',
            timeout: 5000,
            retries: 3,
            debug: false
        };
        
        return {
            get: function(key) {
                return config[key];
            },
            
            set: function(key, value) {
                config[key] = value;
                return this;
            },
            
            getAll: function() {
                return { ...config };
            },
            
            reset: function() {
                Object.keys(config).forEach(key => {
                    delete config[key];
                });
                return this;
            }
        };
    }
    
    return {
        getInstance: function() {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();

// Kullanım
const config1 = ConfigManager.getInstance();
const config2 = ConfigManager.getInstance();

console.log(config1 === config2); // true

config1.set('apiUrl', 'https://new-api.example.com');
console.log(config2.get('apiUrl')); // 'https://new-api.example.com'
```

### 1.5 MDN JavaScript Dokümantasyonu - Kapsamlı Rehber

Bu bölüm, [MDN JavaScript dokümantasyonundan](https://developer.mozilla.org/en-US/docs/Web/JavaScript) alınan tüm ayrıntıları Türkçeye çevirerek özet halinde sunar. Bu kapsamlı rehber, JavaScript'in tüm özelliklerini, kullanım alanlarını ve modern web geliştirmedeki yerini detaylı olarak açıklar.

#### 1.5.1 JavaScript'e Giriş

**JavaScript Nedir?**

JavaScript (JS), birinci sınıf fonksiyonlara sahip hafif, yorumlanan (veya just-in-time derlenen) bir programlama dilidir. En çok web sayfaları için scripting dili olarak bilinse de, Node.js, Apache CouchDB ve Adobe Acrobat gibi birçok tarayıcı dışı ortamda da kullanılır. JavaScript, prototip tabanlı, çöp toplamalı, dinamik bir dildir ve imperative, fonksiyonel ve nesne yönelimli gibi birden fazla paradigması destekler.

**JavaScript'in Dinamik Yetenekleri:**

- **Runtime Object Construction**: Çalışma zamanında nesne oluşturma
- **Variable Parameter Lists**: Değişken parametre listeleri
- **Function Variables**: Fonksiyon değişkenleri
- **Dynamic Script Creation**: eval ile dinamik script oluşturma
- **Object Introspection**: for...in ve Object utilities ile nesne iç gözlemi
- **Source-code Recovery**: JavaScript fonksiyonları kaynak metinlerini saklar ve toString() ile alınabilir

**JavaScript vs Java:**

JavaScript'i Java programlama dili ile karıştırmayın - **JavaScript "Yorumlanmış Java" değildir**. Hem "Java" hem de "JavaScript", Oracle'ın ABD ve diğer ülkelerdeki ticari markaları veya kayıtlı ticari markalarıdır. Ancak, iki programlama dili çok farklı syntax, semantik ve kullanıma sahiptir.

#### 1.5.2 JavaScript Standartları

**ECMAScript Standartları:**

JavaScript standartları, ECMAScript Language Specification (ECMA-262) ve ECMAScript Internationalization API specification (ECMA-402)'dir. Bir tarayıcı bir özelliği uyguladığında, bunu dokümante etmeye çalışırız. Bu, yeni ECMAScript özellikleri için bazı önerilerin zaten tarayıcılarda uygulandığı durumlarda, MDN makalelerindeki dokümantasyon ve örneklerin bu yeni özelliklerden bazılarını kullanabileceği anlamına gelir.

#### 1.5.3 Başlangıç Eğitimleri

**İlk Web Siteniz: Etkileşim Ekleme**

Bu makale, web geliştirmeye tamamen yeni olan kişilere yönelik olarak JavaScript'in ne olduğu ve nasıl kullanılacağı hakkında kısa bir tur sağlar.

**JavaScript ile Dinamik Scripting**

Learn web development bölümümüzün JavaScript modülü, tüm JavaScript temellerini sıfırdan öğretir.

**JavaScript Framework'leri ve Kütüphaneleri**

JavaScript framework'leri, modern front-end web geliştirmenin temel bir parçasıdır ve geliştiricilere ölçeklenebilir, etkileşimli web uygulamaları oluşturmak için denenmiş ve test edilmiş araçlar sağlar. Birçok modern şirket, framework'leri araç setlerinin standart bir parçası olarak kullanır, bu nedenle birçok front-end geliştirme işi artık framework deneyimi gerektirir.

#### 1.5.4 JavaScript Rehberleri

**Temel Dil Rehberleri**

**JavaScript Rehberi**: JavaScript dilinin çok daha ayrıntılı bir rehberi, JavaScript'te veya başka bir dilde önceki programlama deneyimi olanlara yöneliktir.

**Orta Seviye**

**Gelişmiş JavaScript Nesneleri**: JavaScript'in nesne yönelimli doğası, dilin bilginizi daha da ileri götürmek ve daha verimli kod yazmak istiyorsanız anlamak önemlidir.

**Asenkron JavaScript**: Bu modülde, asenkron JavaScript'e bakıyoruz, neden önemli olduğunu ve sunucudan kaynak getirme gibi potansiyel blokaj operasyonlarını etkili bir şekilde ele almak için nasıl kullanılabileceğini inceliyoruz.

**İstemci Tarafı Web API'leri**: API'lerin ne olduğunu ve geliştirme çalışmanızda sık sık karşılaşacağınız en yaygın API'lerden bazılarını nasıl kullanacağınızı keşfediyoruz.

**JavaScript Dil Genel Bakış**: Diğer programlama dillerinden gelenlerin hızla öğrenmesi için JavaScript'in temel syntax ve semantiğinin genel bakışı.

**JavaScript Veri Yapıları**: JavaScript'te mevcut veri yapılarının genel bakışı.

**Eşitlik Karşılaştırmaları ve Aynılık**: JavaScript, üç farklı değer karşılaştırma operasyonu sağlar: `===` kullanarak katı eşitlik, `==` kullanarak gevşek eşitlik ve Object.is() metodu.

**Özelliklerin Numaralandırılabilirliği ve Sahipliği**: Bir grup nesne özelliğini tek tek ziyaret eden farklı metodların, özelliklerin numaralandırılabilirliği ve sahipliğini nasıl ele aldığı.

**Kapanışlar (Closures) - Detaylı Analiz**

**Kapanış Nedir?**

Kapanış (Closure), JavaScript'in en güçlü ve önemli özelliklerinden biridir. Bir kapanış, bir fonksiyon ve o fonksiyonun tanımlandığı sözcüksel ortamın (lexical environment) kombinasyonudur. Bu özellik, fonksiyonların dış scope'daki değişkenlere erişim sağlamasını mümkün kılar.

**Kapanışların Tarihçesi:**

Kapanışlar, 1960'larda Lisp programlama dilinde ortaya çıkmıştır. JavaScript'te ise 1995'te Brendan Eich tarafından dilin temel özelliklerinden biri olarak tasarlanmıştır. Bu özellik, JavaScript'in functional programming yeteneklerinin temelini oluşturur.

**Kapanışlar Nasıl Çalışır?**

JavaScript'te her fonksiyon, oluşturulduğu sırada çevresindeki değişkenlere referans tutar. Bu referanslar, fonksiyon çağrıldığında bile korunur. Bu mekanizma, kapanışların temelini oluşturur.

```javascript
// Temel kapanış örneği
function outerFunction(x) {
    // Dış fonksiyon
    return function innerFunction(y) {
        // İç fonksiyon, dış fonksiyonun parametresine erişir
        return x + y;
    };
}

const addFive = outerFunction(5);
console.log(addFive(3)); // 8
```

**Kapanışların Kullanım Alanları:**

**1. Data Privacy (Veri Gizliliği):**
Kapanışlar, private değişkenler oluşturmak için kullanılır.

```javascript
function createCounter() {
    let count = 0; // Private değişken
    
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

const counter = createCounter();
console.log(counter.getCount()); // 0
counter.increment();
console.log(counter.getCount()); // 1
// count değişkenine doğrudan erişim yok
```

**2. Function Factories (Fonksiyon Fabrikaları):**
Kapanışlar, benzer fonksiyonlar oluşturmak için kullanılır.

```javascript
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

**3. Event Handlers (Olay İşleyicileri):**
Kapanışlar, event handler'larda değişkenleri korumak için kullanılır.

```javascript
function setupButtons() {
    for (let i = 0; i < 3; i++) {
        document.getElementById(`button${i}`).onclick = function() {
            console.log(`Button ${i} clicked`); // i değeri korunur
        };
    }
}
```

**4. Module Pattern (Modül Deseni):**
Kapanışlar, modül pattern'i oluşturmak için kullanılır.

```javascript
const myModule = (function() {
    let privateVar = 0;
    
    return {
        publicMethod: function() {
            return ++privateVar;
        },
        anotherPublicMethod: function() {
            return privateVar * 2;
        }
    };
})();
```

**Kapanışların Alternatifleri:**

**1. Classes (ES6+):**
Modern JavaScript'te sınıflar, kapanışların bazı kullanım alanlarının alternatifi olabilir.

```javascript
class Counter {
    #count = 0; // Private field
    
    increment() {
        return ++this.#count;
    }
    
    getCount() {
        return this.#count;
    }
}
```

**2. WeakMap:**
WeakMap, private veri saklamak için alternatif sağlar.

```javascript
const privateData = new WeakMap();

class MyClass {
    constructor() {
        privateData.set(this, { count: 0 });
    }
    
    increment() {
        const data = privateData.get(this);
        return ++data.count;
    }
}
```

**3. Symbol:**
Symbol'ler, private property'ler oluşturmak için kullanılabilir.

```javascript
const _count = Symbol('count');

class Counter {
    constructor() {
        this[_count] = 0;
    }
    
    increment() {
        return ++this[_count];
    }
}
```

**Kapanışların Avantajları:**

- **Data Encapsulation**: Veri kapsülleme sağlar
- **Memory Efficiency**: Bellek verimliliği
- **Functional Programming**: Fonksiyonel programlama desteği
- **Backward Compatibility**: Geriye uyumluluk

**Kapanışların Dezavantajları:**

- **Memory Leaks**: Bellek sızıntısı riski
- **Performance Overhead**: Performans yükü
- **Debugging Difficulty**: Hata ayıklama zorluğu
- **Complexity**: Karmaşıklık artışı

**Best Practices (En İyi Uygulamalar):**

**1. Memory Management:**
Kapanışlarda gereksiz referansları temizleyin.

```javascript
function createHandler() {
    const largeData = new Array(1000000).fill('data');
    
    return function(event) {
        // Sadece gerekli veriyi kullan
        console.log(event.type);
        // largeData'ya referans tutulur, dikkatli olun
    };
}
```

**2. Avoid Global Variables:**
Global değişkenlerden kaçının.

```javascript
// Kötü
let globalCount = 0;
function badCounter() {
    return ++globalCount;
}

// İyi
function goodCounter() {
    let count = 0;
    return () => ++count;
}
```

**3. Use Modern Alternatives:**
Modern JavaScript özelliklerini tercih edin.

```javascript
// Kapanış yerine
const counter = (() => {
    let count = 0;
    return {
        increment: () => ++count,
        getCount: () => count
    };
})();

// Modern alternatif
class ModernCounter {
    #count = 0;
    
    increment() {
        return ++this.#count;
    }
    
    getCount() {
        return this.#count;
    }
}
```

**Kapanışların Modern Kullanımı:**

**1. React Hooks:**
React'te custom hook'lar kapanışları kullanır.

```javascript
function useCounter(initialValue = 0) {
    const [count, setCount] = useState(initialValue);
    
    const increment = useCallback(() => {
        setCount(prev => prev + 1);
    }, []);
    
    return { count, increment };
}
```

**2. Async Operations:**
Asenkron işlemlerde kapanışlar kullanılır.

```javascript
function createAsyncHandler(url) {
    return async function(data) {
        const response = await fetch(url, {
            method: 'POST',
            body: JSON.stringify(data)
        });
        return response.json();
    };
}
```

**Kapanışların Geleceği:**

Modern JavaScript'te kapanışlar hala önemli olsa da, sınıflar, private fields ve diğer modern özellikler bazı kullanım alanlarının alternatifi olmuştur. Ancak kapanışlar, functional programming ve event handling gibi alanlarda hala kritik öneme sahiptir.

**Sonuç:**

Kapanışlar, JavaScript'in temel özelliklerinden biridir ve modern web geliştirmede hala yaygın olarak kullanılır. Bu özelliği anlamak, JavaScript'te etkili kod yazmak için kritik öneme sahiptir. Ancak modern alternatifleri de göz önünde bulundurarak, doğru yerde doğru tekniği kullanmak önemlidir.

**İleri Seviye**

**Kalıtım ve Prototip Zinciri - Detaylı Analiz**

**Prototip Tabanlı Kalıtım Nedir?**

JavaScript'te kalıtım, prototip tabanlı bir sistem kullanır. Bu sistem, geleneksel sınıf tabanlı kalıtımdan farklı olarak, nesneler arasında doğrudan prototip zinciri oluşturur. Her nesne, başka bir nesnenin prototipi olabilir ve bu zincir, Object.prototype'a kadar uzanır.

**Prototip Zincirinin Tarihçesi:**

Prototip tabanlı kalıtım, 1980'lerde Self programlama dilinde ortaya çıkmıştır. JavaScript'te ise 1995'te Brendan Eich tarafından dilin temel özelliklerinden biri olarak tasarlanmıştır. Bu sistem, JavaScript'i diğer programlama dillerinden ayıran en önemli özelliklerden biridir.

**Prototip Zinciri Nasıl Çalışır?**

JavaScript'te her nesne, [[Prototype]] adında gizli bir özelliğe sahiptir. Bu özellik, başka bir nesneye referans tutar ve prototip zincirini oluşturur.

```javascript
// Prototip zinciri örneği
const animal = {
    type: 'animal',
    makeSound() {
        console.log('Some sound');
    }
};

const dog = Object.create(animal);
dog.breed = 'Labrador';

const puppy = Object.create(dog);
puppy.age = 2;

console.log(puppy.type); // 'animal' - prototip zincirinden gelir
console.log(puppy.breed); // 'Labrador' - prototip zincirinden gelir
console.log(puppy.age); // 2 - kendi özelliği
```

**Prototip Zincirinin Özellikleri:**

**1. Property Lookup (Özellik Arama):**
JavaScript, bir özelliği ararken önce nesnenin kendi özelliklerine bakar, bulamazsa prototip zincirinde arar.

```javascript
const parent = { name: 'Parent' };
const child = Object.create(parent);
child.age = 10;

console.log(child.name); // 'Parent' - prototip zincirinden
console.log(child.age); // 10 - kendi özelliği
console.log(child.nonExistent); // undefined - hiçbir yerde bulunamadı
```

**2. Property Shadowing (Özellik Gölgeleme):**
Nesne, prototipindeki bir özelliği kendi özelliği ile gölgeleyebilir.

```javascript
const parent = { value: 1 };
const child = Object.create(parent);
child.value = 2; // Prototip özelliğini gölgeler

console.log(child.value); // 2 - kendi özelliği
console.log(parent.value); // 1 - prototip özelliği değişmedi
```

**3. Method Overriding (Metod Geçersiz Kılma):**
Nesne, prototipindeki bir metodu kendi metodu ile geçersiz kılabilir.

```javascript
const animal = {
    speak() {
        console.log('Animal sound');
    }
};

const dog = Object.create(animal);
dog.speak = function() {
    console.log('Woof!');
};

dog.speak(); // 'Woof!' - kendi metodu
```

**Prototip Zincirinin Kullanım Alanları:**

**1. Inheritance (Kalıtım):**
Prototip zinciri, kalıtım sağlar.

```javascript
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

function Student(name, grade) {
    Person.call(this, name);
    this.grade = grade;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.study = function() {
    console.log(`${this.name} is studying`);
};

const student = new Student('John', 'A');
student.greet(); // 'Hello, I'm John'
student.study(); // 'John is studying'
```

**2. Mixins (Karışımlar):**
Prototip zinciri, mixin pattern'i oluşturmak için kullanılır.

```javascript
const canFly = {
    fly() {
        console.log('Flying...');
    }
};

const canSwim = {
    swim() {
        console.log('Swimming...');
    }
};

function Duck() {
    this.name = 'Duck';
}

Object.assign(Duck.prototype, canFly, canSwim);

const duck = new Duck();
duck.fly(); // 'Flying...'
duck.swim(); // 'Swimming...'
```

**3. Object Composition (Nesne Kompozisyonu):**
Prototip zinciri, nesne kompozisyonu sağlar.

```javascript
const eventEmitter = {
    on(event, callback) {
        this._events = this._events || {};
        this._events[event] = this._events[event] || [];
        this._events[event].push(callback);
    },
    
    emit(event, data) {
        if (this._events && this._events[event]) {
            this._events[event].forEach(callback => callback(data));
        }
    }
};

const user = Object.create(eventEmitter);
user.name = 'John';

user.on('login', (data) => {
    console.log(`${user.name} logged in: ${data}`);
});

user.emit('login', '2024-01-01');
```

**Prototip Zincirinin Alternatifleri:**

**1. ES6 Classes:**
Modern JavaScript'te sınıflar, prototip zincirinin daha okunabilir bir alternatifi sağlar.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log('Animal sound');
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    speak() {
        console.log('Woof!');
    }
}
```

**2. Composition over Inheritance:**
Kalıtım yerine kompozisyon kullanmak.

```javascript
const canEat = {
    eat() {
        console.log('Eating...');
    }
};

const canSleep = {
    sleep() {
        console.log('Sleeping...');
    }
};

function createAnimal(name) {
    return Object.assign({}, canEat, canSleep, { name });
}

const animal = createAnimal('Buddy');
animal.eat(); // 'Eating...'
animal.sleep(); // 'Sleeping...'
```

**3. Factory Functions:**
Fabrika fonksiyonları, prototip zinciri yerine kullanılabilir.

```javascript
function createPerson(name) {
    return {
        name,
        greet() {
            console.log(`Hello, I'm ${this.name}`);
        }
    };
}

function createStudent(name, grade) {
    const person = createPerson(name);
    return {
        ...person,
        grade,
        study() {
            console.log(`${this.name} is studying`);
        }
    };
}
```

**Prototip Zincirinin Avantajları:**

- **Flexibility**: Esneklik sağlar
- **Dynamic**: Dinamik özellik ekleme
- **Memory Efficiency**: Bellek verimliliği
- **Runtime Modification**: Çalışma zamanında değişiklik

**Prototip Zincirinin Dezavantajları:**

- **Complexity**: Karmaşıklık
- **Performance**: Performans overhead
- **Debugging Difficulty**: Hata ayıklama zorluğu
- **Unpredictable Behavior**: Öngörülemeyen davranış

**Best Practices (En İyi Uygulamalar):**

**1. Use Object.create() for Clean Inheritance:**
Temiz kalıtım için Object.create() kullanın.

```javascript
// İyi
const parent = { name: 'Parent' };
const child = Object.create(parent);

// Kötü
const child = {};
child.__proto__ = parent; // __proto__ kullanmayın
```

**2. Avoid Modifying Built-in Prototypes:**
Yerleşik prototipleri değiştirmekten kaçının.

```javascript
// Kötü
Array.prototype.myMethod = function() {
    // Custom method
};

// İyi
function myArrayMethod(arr) {
    // Utility function
}
```

**3. Use Modern Alternatives When Possible:**
Mümkün olduğunda modern alternatifleri kullanın.

```javascript
// Prototip zinciri yerine
class ModernAnimal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log('Animal sound');
    }
}
```

**Prototip Zincirinin Modern Kullanımı:**

**1. React Component Inheritance:**
React'te component kalıtımı.

```javascript
class BaseComponent extends React.Component {
    componentDidMount() {
        console.log('Base component mounted');
    }
}

class MyComponent extends BaseComponent {
    render() {
        return <div>My Component</div>;
    }
}
```

**2. Node.js EventEmitter:**
Node.js'te EventEmitter kullanımı.

```javascript
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {
    constructor() {
        super();
    }
}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
    console.log('Event occurred');
});
```

**Prototip Zincirinin Geleceği:**

Modern JavaScript'te prototip zinciri hala önemli olsa da, sınıflar ve diğer modern özellikler bazı kullanım alanlarının alternatifi olmuştur. Ancak prototip zinciri, JavaScript'in temel özelliklerinden biri olarak kalacaktır.

**Sonuç:**

Prototip zinciri, JavaScript'in en güçlü ve esnek özelliklerinden biridir. Bu sistemi anlamak, JavaScript'te etkili kod yazmak için kritik öneme sahiptir. Ancak modern alternatifleri de göz önünde bulundurarak, doğru yerde doğru tekniği kullanmak önemlidir.

**Bellek Yönetimi - Detaylı Analiz**

**JavaScript Bellek Yönetimi Nedir?**

JavaScript'te bellek yönetimi, otomatik çöp toplama (garbage collection) sistemi ile yapılır. Bu sistem, geliştiricilerin manuel olarak bellek yönetimi yapmasını gerektirmez, ancak bellek sızıntılarını önlemek için bellek yaşam döngüsünü anlamak önemlidir.

**Bellek Yaşam Döngüsünün Tarihçesi:**

Otomatik bellek yönetimi, 1950'lerde Lisp programlama dilinde ortaya çıkmıştır. JavaScript'te ise 1995'te Brendan Eich tarafından dilin temel özelliklerinden biri olarak tasarlanmıştır. Bu sistem, JavaScript'i güvenli ve kullanımı kolay bir dil yapar.

**Bellek Yaşam Döngüsü Nasıl Çalışır?**

JavaScript'te bellek yaşam döngüsü üç aşamadan oluşur: tahsis (allocation), kullanım (usage) ve serbest bırakma (release).

```javascript
// Bellek tahsisi
let obj = { name: 'John', age: 30 }; // Bellek tahsis edilir

// Bellek kullanımı
console.log(obj.name); // Bellek kullanılır

// Bellek serbest bırakma (otomatik)
obj = null; // Referans kaldırılır, çöp toplama için işaretlenir
```

**Bellek Tahsisi (Memory Allocation):**

JavaScript'te bellek tahsisi, değişken tanımlama ve nesne oluşturma sırasında gerçekleşir.

```javascript
// Primitive değerler için bellek tahsisi
let number = 42; // Stack'te tahsis edilir
let string = 'Hello'; // Stack'te tahsis edilir

// Object değerler için bellek tahsisi
let obj = { name: 'John' }; // Heap'te tahsis edilir
let arr = [1, 2, 3]; // Heap'te tahsis edilir
let func = function() {}; // Heap'te tahsis edilir
```

**Bellek Kullanımı (Memory Usage):**

Bellek kullanımı, değişkenlere erişim ve işlemler sırasında gerçekleşir.

```javascript
// Bellek kullanımı örnekleri
let user = { name: 'John', age: 30 };

// Property erişimi
console.log(user.name); // Bellek kullanılır

// Method çağrısı
user.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};
user.greet(); // Bellek kullanılır

// Array işlemleri
let numbers = [1, 2, 3];
numbers.push(4); // Bellek kullanılır
```

**Bellek Serbest Bırakma (Memory Release):**

Bellek serbest bırakma, çöp toplama sistemi tarafından otomatik olarak yapılır.

```javascript
// Bellek serbest bırakma örnekleri
let obj = { name: 'John' };

// Referans kaldırma
obj = null; // Çöp toplama için işaretlenir

// Scope sona erme
function createObject() {
    let localObj = { name: 'Local' };
    return localObj;
}

let globalObj = createObject();
// localObj scope'u sona erdi, çöp toplama için işaretlenir
```

**Çöp Toplama (Garbage Collection):**

JavaScript'te çöp toplama, erişilemeyen nesneleri otomatik olarak temizler.

**1. Mark and Sweep Algorithm:**
En yaygın kullanılan çöp toplama algoritmasıdır.

```javascript
// Mark and Sweep örneği
let obj1 = { name: 'Object 1' };
let obj2 = { name: 'Object 2' };

obj1.ref = obj2;
obj2.ref = obj1;

// Referansları kaldır
obj1 = null;
obj2 = null;

// Çöp toplama: Her iki nesne de erişilemez, temizlenir
```

**2. Reference Counting:**
Referans sayma algoritması, döngüsel referansları tespit edemez.

```javascript
// Döngüsel referans örneği
let obj1 = { name: 'Object 1' };
let obj2 = { name: 'Object 2' };

obj1.ref = obj2;
obj2.ref = obj1;

// Referansları kaldır
obj1 = null;
obj2 = null;

// Reference counting: Döngüsel referans nedeniyle temizlenmez
// Mark and sweep: Döngüsel referansı tespit eder ve temizler
```

**3. Generational Garbage Collection:**
Nesneleri yaşlarına göre kategorize eder.

```javascript
// Generational GC örneği
function createShortLivedObject() {
    return { name: 'Short lived' };
}

function createLongLivedObject() {
    return { name: 'Long lived' };
}

// Kısa ömürlü nesneler: Genç nesil (Young Generation)
let shortLived = createShortLivedObject();

// Uzun ömürlü nesneler: Yaşlı nesil (Old Generation)
let longLived = createLongLivedObject();
```

**Bellek Sızıntıları (Memory Leaks):**

Bellek sızıntıları, kullanılmayan bellek alanlarının serbest bırakılmamasıdır.

**1. Global Variables (Global Değişkenler):**
Global değişkenler, çöp toplama tarafından temizlenmez.

```javascript
// Bellek sızıntısı
function createGlobalVariable() {
    globalVar = { name: 'Global' }; // var, let, const kullanılmadı
}

// Çözüm
function createLocalVariable() {
    let localVar = { name: 'Local' };
    return localVar;
}
```

**2. Event Listeners (Olay Dinleyicileri):**
Event listener'lar, referansları korur.

```javascript
// Bellek sızıntısı
function addEventListener() {
    const button = document.getElementById('button');
    button.addEventListener('click', function() {
        console.log('Button clicked');
    });
    // Event listener kaldırılmadı
}

// Çözüm
function addEventListenerWithCleanup() {
    const button = document.getElementById('button');
    const handler = function() {
        console.log('Button clicked');
    };
    
    button.addEventListener('click', handler);
    
    // Cleanup
    return () => button.removeEventListener('click', handler);
}
```

**3. Closures (Kapanışlar):**
Kapanışlar, dış scope'daki değişkenlere referans tutar.

```javascript
// Bellek sızıntısı
function createClosure() {
    const largeData = new Array(1000000).fill('data');
    
    return function() {
        console.log('Closure executed');
        // largeData'ya referans tutulur
    };
}

// Çözüm
function createClosureWithCleanup() {
    const largeData = new Array(1000000).fill('data');
    
    return function() {
        console.log('Closure executed');
        // largeData kullanıldıktan sonra temizle
        largeData.length = 0;
    };
}
```

**4. DOM References (DOM Referansları):**
DOM referansları, bellek sızıntısına neden olabilir.

```javascript
// Bellek sızıntısı
function createDOMReference() {
    const element = document.createElement('div');
    const data = new Array(1000000).fill('data');
    
    element.data = data; // DOM element'e büyük veri eklenir
    
    document.body.appendChild(element);
    // Element DOM'dan kaldırılsa bile data referansı korunur
}

// Çözüm
function createDOMReferenceWithCleanup() {
    const element = document.createElement('div');
    const data = new Array(1000000).fill('data');
    
    element.data = data;
    document.body.appendChild(element);
    
    // Cleanup
    return () => {
        element.data = null;
        element.remove();
    };
}
```

**Bellek Yönetiminin Alternatifleri:**

**1. Manual Memory Management:**
C/C++ gibi dillerde manuel bellek yönetimi yapılır.

```javascript
// JavaScript'te manuel bellek yönetimi benzeri
class MemoryManager {
    constructor() {
        this.allocated = new Set();
    }
    
    allocate(size) {
        const memory = new Array(size);
        this.allocated.add(memory);
        return memory;
    }
    
    deallocate(memory) {
        this.allocated.delete(memory);
        memory.length = 0;
    }
    
    cleanup() {
        this.allocated.forEach(memory => {
            memory.length = 0;
        });
        this.allocated.clear();
    }
}
```

**2. Weak References:**
WeakMap ve WeakSet, zayıf referanslar sağlar.

```javascript
// WeakMap kullanımı
const weakMap = new WeakMap();

function createObjectWithWeakRef() {
    const obj = { name: 'Object' };
    const data = new Array(1000000).fill('data');
    
    weakMap.set(obj, data);
    
    return obj;
    // obj referansı kaldırıldığında, weakMap'ten de kaldırılır
}

// WeakSet kullanımı
const weakSet = new WeakSet();

function addToWeakSet(obj) {
    weakSet.add(obj);
    // obj referansı kaldırıldığında, weakSet'ten de kaldırılır
}
```

**3. Object Pooling:**
Nesne havuzu, bellek tahsisini azaltır.

```javascript
// Object pooling örneği
class ObjectPool {
    constructor(createFn, resetFn) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
    }
    
    get() {
        if (this.pool.length > 0) {
            return this.pool.pop();
        }
        return this.createFn();
    }
    
    release(obj) {
        this.resetFn(obj);
        this.pool.push(obj);
    }
}

// Kullanım
const pool = new ObjectPool(
    () => ({ x: 0, y: 0, active: false }),
    (obj) => { obj.x = 0; obj.y = 0; obj.active = false; }
);

const obj = pool.get();
// Kullanım
pool.release(obj);
```

**Bellek Yönetiminin Avantajları:**

- **Automatic**: Otomatik bellek yönetimi
- **Safe**: Güvenli bellek erişimi
- **Developer Friendly**: Geliştirici dostu
- **No Manual Cleanup**: Manuel temizlik gerektirmez

**Bellek Yönetiminin Dezavantajları:**

- **Performance Overhead**: Performans yükü
- **Unpredictable Timing**: Öngörülemeyen zamanlama
- **Memory Leaks**: Bellek sızıntısı riski
- **Limited Control**: Sınırlı kontrol

**Best Practices (En İyi Uygulamalar):**

**1. Avoid Global Variables:**
Global değişkenlerden kaçının.

```javascript
// Kötü
let globalData = new Array(1000000).fill('data');

// İyi
function useLocalData() {
    let localData = new Array(1000000).fill('data');
    // Kullanım
    localData = null; // Referansı kaldır
}
```

**2. Clean Up Event Listeners:**
Event listener'ları temizleyin.

```javascript
// İyi
function setupEventListener() {
    const button = document.getElementById('button');
    const handler = () => console.log('Clicked');
    
    button.addEventListener('click', handler);
    
    // Cleanup
    return () => button.removeEventListener('click', handler);
}
```

**3. Use Weak References:**
Zayıf referansları kullanın.

```javascript
// İyi
const weakMap = new WeakMap();

function storeData(obj, data) {
    weakMap.set(obj, data);
    // obj referansı kaldırıldığında otomatik temizlenir
}
```

**4. Monitor Memory Usage:**
Bellek kullanımını izleyin.

```javascript
// Bellek kullanımını izleme
function monitorMemory() {
    if (performance.memory) {
        console.log('Used:', performance.memory.usedJSHeapSize);
        console.log('Total:', performance.memory.totalJSHeapSize);
        console.log('Limit:', performance.memory.jsHeapSizeLimit);
    }
}
```

**Bellek Yönetiminin Modern Kullanımı:**

**1. React Component Cleanup:**
React'te component cleanup.

```javascript
function MyComponent() {
    useEffect(() => {
        const timer = setInterval(() => {
            console.log('Timer tick');
        }, 1000);
        
        // Cleanup
        return () => clearInterval(timer);
    }, []);
    
    return <div>My Component</div>;
}
```

**2. Node.js Memory Management:**
Node.js'te bellek yönetimi.

```javascript
// Node.js bellek yönetimi
const v8 = require('v8');

function logMemoryUsage() {
    const usage = process.memoryUsage();
    console.log('RSS:', usage.rss);
    console.log('Heap Used:', usage.heapUsed);
    console.log('Heap Total:', usage.heapTotal);
    console.log('External:', usage.external);
}

// Garbage collection tetikleme
if (global.gc) {
    global.gc();
}
```

**Bellek Yönetiminin Geleceği:**

Modern JavaScript'te bellek yönetimi, daha gelişmiş çöp toplama algoritmaları ve bellek izleme araçları ile gelişmektedir. WebAssembly ve diğer teknolojiler, bellek yönetiminde yeni yaklaşımlar sunmaktadır.

**Sonuç:**

Bellek yönetimi, JavaScript'te kritik öneme sahiptir. Otomatik çöp toplama sistemi, geliştiricilerin işini kolaylaştırır, ancak bellek sızıntılarını önlemek için dikkatli olmak gerekir. Modern araçlar ve best practice'ler, etkili bellek yönetimi sağlar.

#### 1.5.5 JavaScript Referansı

**Standart Nesneler**

Standart yerleşik nesneleri tanıyın: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet ve diğerleri.

**İfadeler ve Operatörler**

JavaScript'in instanceof, typeof, new, this operatörlerinin davranışı, operatör önceliği ve daha fazlası hakkında daha fazla bilgi edinin.

**İfadeler ve Bildirimler**

do-while, for-in, for-of, try-catch, let, var, const, if-else, switch ve daha fazla JavaScript ifadesi ve anahtar kelimesinin nasıl çalıştığını öğrenin.

**Fonksiyonlar**

Uygulamalarınızı geliştirmek için JavaScript'in fonksiyonlarıyla nasıl çalışacağınızı öğrenin.

**Sınıflar**

JavaScript sınıfları, nesne yönelimli programlama yapmanın en uygun yoludur.

#### 1.5.6 JavaScript Hata Türleri

**SyntaxError (Sözdizimi Hatası)**

- **'arguments'/'eval' strict mode kodunda tanımlanamaz veya atanamaz**
- **"0" önekli sekizlik literal'lar kullanımdan kaldırıldı**
- **Basit olmayan parametreli fonksiyonda "use strict" izin verilmiyor**
- **"x" ayrılmış tanımlayıcı**
- **await sadece async fonksiyonlarda, async generator'larda ve modüllerde geçerli**
- **await/yield ifadesi parametrede kullanılamaz**
- **`||` ve `&&` ifadeleri içinde `??` parantezsiz kullanılamaz**

**TypeError (Tip Hatası)**

- **'x' yinelenebilir değil**
- **"x" bir constructor değil**
- **"x" bir fonksiyon değil**
- **"x" null olmayan bir nesne değil**
- **"x" salt okunur**
- **BigInt değeri JSON'da serileştirilemez**
- **BigInt'i sayıya dönüştüremez**
- **const "x"e geçersiz atama**
- **Boş dizi azaltma, başlangıç değeri olmadan**

**ReferenceError (Referans Hatası)**

- **Tanımlanmamış değişken "x"e atama**
- **Türetilmiş sınıf constructor'ında 'this' kullanmadan önce super constructor çağrılmalı**
- **Türetilmiş sınıf constructor'ında super() iki kez çağrıldı**

**URIError (URI Hatası)**

- **Bozuk URI dizisi**

#### 1.5.7 JavaScript Teknolojileri Genel Bakış

**Temel Teknolojiler**

- **ECMAScript**: JavaScript'in resmi standartı
- **DOM (Document Object Model)**: HTML ve XML belgelerinin programmatik temsili
- **Web APIs**: Tarayıcıda kullanılabilir API'ler

**Modern JavaScript Özellikleri**

- **ES6+ Özellikleri**: Arrow functions, classes, modules, destructuring
- **Asenkron Programlama**: Promises, async/await, generators
- **Modern Veri Yapıları**: Map, Set, WeakMap, WeakSet
- **Metaprogramming**: Proxy, Reflect, Symbols

**JavaScript Ekosistemi**

- **Node.js**: Server-side JavaScript runtime
- **NPM**: JavaScript paket yöneticisi
- **Framework'ler**: React, Vue, Angular, Svelte
- **Build Tools**: Webpack, Vite, Parcel, Rollup
- **Testing**: Jest, Mocha, Jasmine, Cypress

#### 1.5.8 JavaScript Çalıştırma Modeli

**Execution Context (Çalıştırma Bağlamı)**

JavaScript'te her kod parçası bir execution context içinde çalışır. Bu bağlam, değişkenlerin, fonksiyonların ve this değerinin nasıl çalıştığını belirler.

**Call Stack (Çağrı Yığını)**

JavaScript, tek threaded bir dildir ve call stack kullanarak fonksiyon çağrılarını yönetir. Her fonksiyon çağrısı stack'e eklenir ve tamamlandığında stack'ten çıkarılır.

**Event Loop (Olay Döngüsü)**

JavaScript'in asenkron davranışı, event loop ile yönetilir. Bu döngü, call stack, callback queue ve microtask queue'yu koordine eder.

#### 1.5.9 Sözcüksel Dil Bilgisi

**Tokenization (Tokenleştirme)**

JavaScript engine, kaynak kodu token'lara ayırır. Bu token'lar, anahtar kelimeler, tanımlayıcılar, operatörler ve literal'lar olabilir.

**Automatic Semicolon Insertion (Otomatik Noktalı Virgül Ekleme)**

JavaScript, belirli durumlarda otomatik olarak noktalı virgül ekler. Bu özellik, kod yazmayı kolaylaştırır ancak beklenmeyen davranışlara neden olabilir.

**Strict Mode (Katı Mod)**

Strict mode, JavaScript'in daha katı bir versiyonunu etkinleştirir. Bu mod, bazı hataları önler ve daha güvenli kod yazmayı sağlar.

#### 1.5.10 Yineleme Protokolleri

**Iterable Protocol (Yinelenebilir Protokol)**

Bir nesne, Symbol.iterator metoduna sahipse yinelenebilir olur. Bu protokol, for...of döngüleri ve spread operatörü ile kullanılır.

**Iterator Protocol (Yineleyici Protokol)**

Bir iterator, next() metoduna sahip bir nesnedir. Bu metod, {value, done} şeklinde bir obje döndürür.

**Generator Functions (Üretici Fonksiyonlar)**

Generator fonksiyonlar, iterator'lar oluşturmanın kolay bir yoludur. Bu fonksiyonlar, function* syntax'ı kullanır ve yield anahtar kelimesi ile değer döndürür.

#### 1.5.11 Şablon Literalleri

**Template Literals (Şablon Literalleri)**

Template literal'lar, string'leri oluşturmanın modern bir yoludur. Backtick (`) karakteri ile tanımlanır ve ${} syntax'ı ile değişken gömme sağlar.

**Tagged Templates (Etiketli Şablonlar)**

Tagged template'ler, template literal'ları işleyen fonksiyonlardır. Bu fonksiyonlar, string parçalarını ve değerleri ayrı ayrı alır.

**Raw Strings (Ham String'ler)**

Raw string'ler, escape karakterlerinin işlenmediği string'lerdir. String.raw ile oluşturulur.

#### 1.5.12 Trailing Commas (Sondaki Virgüller)

**Trailing Commas (Sondaki Virgüller)**

JavaScript, array'ler, object'ler ve function parametrelerinde sondaki virgüllere izin verir. Bu özellik, kod düzenlemesini kolaylaştırır.

**Kullanım Alanları**

- **Array Literals**: `[1, 2, 3,]`
- **Object Literals**: `{a: 1, b: 2,}`
- **Function Parameters**: `function(a, b,) {}`
- **Function Calls**: `func(a, b,)`

#### 1.5.13 Kullanımdan Kaldırılan Özellikler

**Deprecated Features (Kullanımdan Kaldırılan Özellikler)**

JavaScript'te bazı özellikler kullanımdan kaldırılmıştır. Bu özellikler hala çalışır ancak gelecekte kaldırılabilir.

**Kullanımdan Kaldırılan Özellikler**

- **var**: let ve const ile değiştirildi
- **function declarations in blocks**: let ve const ile değiştirildi
- **arguments object**: rest parameters ile değiştirildi
- **eval()**: güvenlik nedenleriyle önerilmiyor

#### 1.5.14 JavaScript'in Geleceği

**Yaklaşan Özellikler**

JavaScript sürekli gelişmektedir. TC39 komitesi, yeni özellikler önerir ve bunları standartlaştırır.

**Stage 3 Özellikler**

- **Top-level await**: Modül seviyesinde await
- **Private fields**: Sınıf özel alanları
- **Static class blocks**: Sınıf statik blokları

**Stage 2 Özellikler**

- **Decorators**: Sınıf ve metod dekoratörleri
- **Pipeline operator**: Fonksiyon zincirleme operatörü

**JavaScript'in Evrimi**

JavaScript, web'in evrimi ile birlikte gelişmektedir. WebAssembly, Progressive Web Apps ve modern web standartları, JavaScript'in geleceğini şekillendirmektedir.

Bu kapsamlı rehber, [MDN JavaScript dokümantasyonundan](https://developer.mozilla.org/en-US/docs/Web/JavaScript) alınan tüm ayrıntıları kapsar ve JavaScript'in modern web geliştirmedeki yerini ve önemini vurgular. JavaScript, sadece bir scripting dili değil, aynı zamanda modern yazılım geliştirmenin temel taşlarından biridir.

